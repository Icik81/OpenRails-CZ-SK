// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* LOCOMOTIVE CLASSES
 * 
 * Used as a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  MSTSLocomotive - defines the behaviour, ie physics, motion, power generated etc
 *  MSTSLocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCar - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */

//#define ALLOW_ORTS_SPECIFIC_ENG_PARAMETERS

// Debug for Advanced Adhesion Model
//#define DEBUG_ADHESION

using GNU.Gettext;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using Orts.Common;
using Orts.Formats.Msts;
using Orts.Formats.OR;
using Orts.MultiPlayer;
using Orts.Parsers.Msts;
using Orts.Simulation.AIs;
using Orts.Simulation.Physics;
using Orts.Simulation.Properties;
using Orts.Simulation.RollingStocks.SubSystems;
using Orts.Simulation.RollingStocks.SubSystems.Brakes;
using Orts.Simulation.RollingStocks.SubSystems.Brakes.MSTS;
using Orts.Simulation.RollingStocks.SubSystems.Controllers;
using Orts.Simulation.RollingStocks.SubSystems.PowerSupplies;
using Orts.Simulation.RollingStocks.SubSystems.PowerTransmissions;
using Orts.Simulation.Timetables;
using ORTS.Common;
using ORTS.Common.Input;
using ORTS.Scripting.Api;
using ORTS.Settings;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
using static Orts.Simulation.RollingStocks.SubSystems.Controllers.MultiPositionController;
using static Orts.Simulation.RollingStocks.SubSystems.CruiseControl;
using static Orts.Simulation.RollingStocks.SubSystems.Mirel;
using Event = Orts.Common.Event;

namespace Orts.Simulation.RollingStocks
{

    ///////////////////////////////////////////////////
    ///   SIMULATION BEHAVIOUR
    ///////////////////////////////////////////////////

    public enum CabViewType
    {
        Front = 0,
        Rear = 1,
        Void = 2
    }

    /// <summary>
    /// Adds Throttle, Direction, Horn, Sander and Wiper control
    /// to the basic TrainCar.
    /// Use as a base for Electric, Diesel or Steam locomotives.
    /// </summary>
    public partial class MSTSLocomotive : MSTSWagon
    {

        public enum CombinedControl
        {
            None,
            ThrottleDynamic,
            ThrottleAir,
            ThrottleDynamicAir,
            DynamicAir,
        }

        public enum SoundState
        {
            Stopped,
            Sound,
            ContinuousSound
        }

        // simulation parameters
        public bool ManualHorn = false;
        public bool TCSHorn = false;
        public bool Horn = false;
        protected bool PreviousHorn = false;

        public bool ManualBell = false;
        public SoundState BellState = SoundState.Stopped;
        public bool Bell = false;
        protected bool PreviousBell = false;

        public bool VacuumExhausterPressed = false;
        public bool FastVacuumExhausterFitted = false;

        public bool AlerterSnd;
        public bool VigilanceMonitor;
        public bool Sander;
        public bool Wiper;
        public bool BailOff;
        public bool DynamicBrake;
        public float MaxPowerW;
        public float MaxForceN;
        public float AbsTractionSpeedMpS;
        public float MaxCurrentA = 0;
        public float MaxSpeedMpS = 1e3f;
        public float UnloadingSpeedMpS;
        public float MainResPressurePSI = 130;
        public bool CompressorIsOn;
        public float AverageForceN;
        public bool PowerOn;
        public float PowerOnDelayS;
        public bool[] CabLightOn = new bool[3];
        public bool[] CabFloodLightOn = new bool[3];
        public bool ShowCab = true;
        public bool MilepostUnitsMetric;
        public float DrvWheelWeightKg; // current weight on locomotive drive wheels, includes drag factor (changes as mass changes)
        public float InitialDrvWheelWeightKg; // initialising weight on locomotive drive wheels, includes drag factor
        public bool CabRadioOn;
        public bool OnLineCabRadio;
        public string OnLineCabRadioURL;
        public bool Battery;
        public bool PowerKey;
        public bool BrakeRelease = false;
        public bool Up = false;
        public bool Down = false;

        // Water trough filling
        public bool HasWaterScoop = false; // indicates whether loco + tender have a water scoop or not
        public float ScoopMaxPickupSpeedMpS = 200.0f; // Maximum scoop pickup speed - used in steam locomotive viewer
        public bool ScoopIsBroken = false; // becomes broken if activated where there is no trough
        public bool RefillingFromTrough = false; // refilling from through is ongoing
        public float WaterScoopFillElevationM; // height water has to be raised to fill tender
        public float WaterScoopDepthM; // depth that water scoop goes into trough (pan)
        public float WaterScoopWidthM; // width of water scoop
        public float WaterScoopVelocityMpS; // Velocity of water entering water scoop
        public float WaterScoopDragForceN; // drag force due to scoop being in water trough
        public float WaterScoopedQuantityLpS; // Amount of water scooped up by water scoop per second
        public float WaterScoopInputAmountL; // Water scooped in elapsed time
        public float WaterScoopMinSpeedMpS; // Minimum speed for water pickup
        public bool IsWaterScoopDown = false;
        public bool WaterScoopDown;
        public const float GravitationalAccelerationFtpSpS = 32.26f;
        public float TenderWaterLevelFraction;
        public float WaterScoopTotalWaterL;
        bool WaterScoopOverTroughFlag = false;
        bool WaterScoopNotFittedFlag = false;
        bool WaterScoopSlowSpeedFlag = false;
        bool WaterScoopDirectionFlag = false;
        public bool IsWaterScoopPlayerLocomotive = false;
        bool WaterScoopSoundOn = false;
        public float MaxTotalCombinedWaterVolumeUKG;
        public MSTSNotchController WaterController = new MSTSNotchController(0, 1, 0.01f);
        public float CombinedTenderWaterVolumeUKG          // Decreased by running injectors and increased by refilling
        {
            get { return WaterController.CurrentValue * MaxTotalCombinedWaterVolumeUKG; }
            set { WaterController.CurrentValue = value / MaxTotalCombinedWaterVolumeUKG; }
        }

        public float CurrentLocomotiveSteamHeatBoilerWaterCapacityL
        {
            get { return WaterController.CurrentValue * MaximumSteamHeatBoilerWaterTankCapacityL; }
            set { WaterController.CurrentValue = value / MaximumSteamHeatBoilerWaterTankCapacityL; }
        }
        public float IsTenderRequired = 1.0f;  // Flag indicates that a tender is required for operation of the locomotive. Typically tank locomotives do not require a tender. Assume by default that tender is required.

        public float BoilerPressurePSI;     // Steam Gauge pressure - what the engineer sees.
        public float MaxBoilerPressurePSI = 180f;  // maximum boiler pressure, safety valve setting

        // Vacuum Reservoir and Exhauster Settings

        // Steam heating Flags
        public bool IsSteamInitial = true;        // To initialise steam heat
        public bool IsSteamHeatFirstTime = true;  // Flag for first pass at steam heating.
        public bool IsSteamHeatFitted = false;    // Is steam heating fitted to locomotive
        public float CurrentSteamHeatPressurePSI = 0.0f;   // Current pressure in steam heat system

        public string LocomotiveName; // Name of locomotive from ENG file

        // Carriage Steam Heating Parameters
        public float MaxSteamHeatPressurePSI;    // Maximum Steam heating pressure
        public Interpolator SteamHeatPressureToTemperaturePSItoF;
        public Interpolator SteamDensityPSItoLBpFT3;   // saturated steam density given pressure
        public Interpolator SteamHeatPSItoBTUpLB;      // total heat in saturated steam given pressure
        public bool IsSteamHeatingBoilerFitted = false;   // Flag to indicate when steam heat boiler van is fitted
        public float CalculatedCarHeaterSteamUsageLBpS;

        // Adhesion Debug
        // Commented out as never used
        //bool DebugSpeedReached;
        //float DebugSpeedIncrement = 5.0f; // Speed increment for debug display - in mph
        //float DebugSpeed = 5.0f; // Initialise at 5 mph
        //float DebugTimer = 0.0f;

        // Adhesion parameters
        float BaseFrictionCoefficientFactor;  // Factor used to adjust Curtius formula depending upon weather conditions
        public float SteamStaticWheelForce;
        public float SteamTangentialWheelForce;
        public float SteamDrvWheelWeightLbs;  // Weight on each drive axle
        public float PreviousThrottleSetting = 0.0f;  // Holds the value of the previous throttle setting for calculating the correct antislip speed

        // parameters for Track Sander based upon compressor air and abrasive table for 1/2" sand blasting nozzle @ 50psi
        public float MaxTrackSandBoxCapacityL = 0;  // Capacity of sandbox - assume 40.0 cu ft
        public float CurrentTrackSandBoxCapacityL = 0;   // This value needs to be initialised to the value above, as it reduces as sand is used.
        public float TrackSanderAirComsumptionLpS = Me3.FromFt3(195.0f) / 60.0f;  // Default value - cubic feet per min (CFM) 195 ft3/m
        public float TrackSanderAirPressurePSI = 50.0f;
        public float TrackSanderSandConsumptionLpS = Me3.FromFt3(11.6f) / 3600.0f; // Default value - 11.6 ft3/h

        // Vacuum Braking parameters
        readonly static float OneAtmospherePSI = Bar.ToPSI(1);
        public bool SmallSteamEjectorIsOn = false;
        public bool LargeSteamEjectorIsOn = false;
        public bool VacuumPumpOperating = false;
        public float SteamEjectorSmallPressurePSI = 0.0f;
        public float SteamEjectorLargePressurePSI = 0.0f;
        public bool VacuumPumpFitted;
        public bool SmallEjectorControllerFitted = false;
        public float VacuumPumpResistanceN;
        public float EjectorSmallSteamConsumptionLbpS;
        public float EjectorLargeSteamConsumptionLbpS;
        public float SteamEjectorSmallSetting = 0.0f;
        public float SteamEjectorLargeSetting = 0.0f;
        public float MaxVaccuumMaxPressurePSI = 110.0f;  // Value for the boiler pressure when maximum vacuum will be produced for the steam ejector 
        public float SmallEjectorFeedFraction = 0.35f;
        public float LargeEjectorFeedFraction = 1.0f;
        public bool LargeEjectorControllerFitted = false;
        public float VacuumPumpChargingRateInHgpS = 0.0f;
        public bool VacuumBrakeEQFitted = false;  // Flag to indicate that equalising resevoir fitted to vacuum brakes
        public float HUDNetBPLossGainPSI;
        public float SmallEjectorBrakePipeChargingRatePSIorInHgpS;
        public float LargeEjectorBrakePipeChargingRatePSIorInHgpS;
        public float ExhausterHighSBPChargingRatePSIorInHgpS;  // Rate for Exhauster in high speed mode
        public float ExhausterLowSBPChargingRatePSIorInHgpS;  // Rate for Exhauster in high speed mode
        public bool VacuumBrakeCutoffActivated = false;
        public bool BrakeFlagDecrease = false;
        public bool BrakeFlagIncrease = false;

        private bool _SmallEjectorSoundOn = false;
        public bool SmallEjectorSoundOn
        {
            get => _SmallEjectorSoundOn;
            set
            {
                if (value != _SmallEjectorSoundOn)
                {
                    SignalEvent(value ? Event.SmallEjectorOn : Event.SmallEjectorOff);
                    _SmallEjectorSoundOn = value;
                }
            }
        }

        private bool _LargeEjectorSoundOn = false;
        public bool LargeEjectorSoundOn
        {
            get => _LargeEjectorSoundOn;
            set
            {
                if (value != _LargeEjectorSoundOn)
                {
                    SignalEvent(value ? Event.LargeEjectorOn : Event.LargeEjectorOff);
                    _LargeEjectorSoundOn = value;
                }
            }
        }

        public bool SteamEngineBrakeFitted = false;
        public bool TrainBrakeFitted = false;
        public bool EngineBrakeFitted = false;
        public bool BrakemanBrakeFitted = false;
        public bool VacuumExhausterIsOn = false;
        public float VacuumBrakesMainResVolumeM3 = Me3.FromFt3(200.0f); // Main vacuum reservoir volume
        public float VacuumBrakesMainResMaxVacuumPSIAorInHg = Vac.ToPress(23);
        public float VacuumBrakesExhausterRestartVacuumPSIAorInHg = Vac.ToPress(21);
        public float VacuumBrakesMainResChargingRatePSIAorInHgpS = Bar.ToPSI(Bar.FromInHg(0.2f));
        public float VacuumMainResVacuumPSIAorInHg = Vac.ToPress(23); // Vacuum currently in Main Reservoir

        // Set values for display in HUD
        public float WagonCoefficientFrictionHUD;
        public float LocomotiveCoefficientFrictionHUD;

        public PressureUnit MainPressureUnit = PressureUnit.None;
        public Dictionary<BrakeSystemComponent, PressureUnit> BrakeSystemPressureUnits = new Dictionary<BrakeSystemComponent, PressureUnit>
        {
            { BrakeSystemComponent.MainReservoir, PressureUnit.None },
            { BrakeSystemComponent.EqualizingReservoir, PressureUnit.None },
            { BrakeSystemComponent.AuxiliaryReservoir, PressureUnit.None },
            { BrakeSystemComponent.EmergencyReservoir, PressureUnit.None },
            { BrakeSystemComponent.MainPipe, PressureUnit.None },
            { BrakeSystemComponent.BrakePipe, PressureUnit.None },
            { BrakeSystemComponent.BrakeCylinder, PressureUnit.None }
        };

        protected float OdometerResetPositionM = 0;
        protected bool OdometerCountingUp = true;
        protected bool OdometerCountingForwards = true;

        public bool OdometerVisible { get; private set; }
        public float OdometerM
        {
            get
            {
                if (Train == null)
                    return 0;

                return OdometerCountingForwards ? Train.DistanceTravelledM - OdometerResetPositionM : OdometerResetPositionM - Train.DistanceTravelledM;
            }
        }

        // ENG file data
        public string CabSoundFileName;
        public string CVFFileName;
        public float MaxMainResPressurePSI = 130;
        public float MainResVolumeM3 = 0.3f;
        public float TrainBrakePipeLeakPSIorInHgpS = 0.0f;    // Air leakage from train brake pipe - should normally be no more then 5psi/min - default off
        public float CompressorRestartPressurePSI = 110;
        public float CompressorChargingRateM3pS = 0.075f;
        public float MainResChargingRatePSIpS = 0.4f;
        public float EngineBrakeReleaseRatePSIpS = 12.5f;
        public float EngineBrakeApplyRatePSIpS = 12.5f;
        public float BrakePipeTimeFactorS = 0.0015f;
        public float BrakePipeDischargeTimeFactor;
        public float BrakeServiceTimeFactorS;
        public float BrakeEmergencyTimeFactorS;
        public float BrakePipeChargingRatePSIorInHgpS;
        public float BrakePipeQuickChargingRatePSIpS;
        public InterpolatorDiesel2D TractiveForceCurves;
        public InterpolatorDiesel2D DynamicBrakeForceCurves;
        public InterpolatorDiesel2D ExtendedExcitationCurrent;
        public InterpolatorDiesel2D ExtendedArmCurrent;
        public InterpolatorDiesel2D ExtendedExcitationEDBCurrent; // buzení
        public InterpolatorDiesel2D ExtendedArmEDBCurrent; // kotvy
        public float DynamicBrakeSpeed1MpS = MpS.FromKpH(5);
        public float DynamicBrakeSpeed2MpS = MpS.FromKpH(30);
        public float DynamicBrakeSpeed3MpS = MpS.FromKpH(999);
        public float DynamicBrakeSpeed4MpS = MpS.FromKpH(999);
        public float DynamicBrakeRatioAtSpeed4 = 0;
        public float MaxDynamicBrakeForceN;
        public float DynamicBrakeMaxCurrentA;
        public float DynamicBrakeDelayS;
        public bool DynamicBrakeAutoBailOff;
        public bool UsingRearCab;

        protected bool DynamicBrakeBlended; // dynamic brake blending is currently active
        protected bool DynamicBrakeBlendingEnabled; // dynamic brake blending is configured
        public bool DynamicBrakeAvailable; // dynamic brake is available
        AirSinglePipe airPipeSystem;
        public double DynamicBrakeCommandStartTime;
        protected bool DynamicBrakeBlendingOverride; // true when DB lever >0% should always override the blending. When false, the bigger command is applied.
        protected bool DynamicBrakeBlendingForceMatch = true; // if true, dynamic brake blending tries to achieve the same braking force as the airbrake would have.

        public CombinedControl CombinedControlType;
        public float CombinedControlSplitPosition;
        public bool HasSmoothStruc;

        public float MaxContinuousForceN;
        public float SpeedOfMaxContinuousForceMpS;  // Speed where maximum tractive effort occurs
        public float MSTSSpeedOfMaxContinuousForceMpS;  // Speed where maximum tractive effort occurs - MSTS parameter if used
        public float ContinuousForceTimeFactor = 1800;
        public bool AntiSlip;
        public bool AdvancedAdhesionModel = false; // flag set depending upon adhesion model used.
        public float SanderSpeedEffectUpToMpS;
        public float SanderSpeedOfMpS = 30.0f;
        public string EngineOperatingProcedures;

        public bool EmergencyButtonPressed { get; set; }
        public bool EmergencyCausesPowerDown { get; private set; }
        public bool EmergencyCausesThrottleDown { get; private set; }
        public bool EmergencyEngagesHorn { get; private set; }
        public bool WheelslipCausesThrottleDown { get; private set; }

        public float BrakeRestoresPowerAtBrakePipePressurePSI { get; private set; }
        public float BrakeCutsPowerAtBrakePipePressurePSI { get; private set; }
        public bool DoesVacuumBrakeCutPower { get; private set; }
        public bool DoesBrakeCutPower { get; private set; }
        public float BrakeCutsPowerAtBrakeCylinderPressurePSI { get; private set; }
        public bool DoesHornTriggerBell { get; private set; }

        protected const float DefaultCompressorRestartToMaxSysPressureDiff = 35;    // Used to check if difference between these two .eng parameters is correct, and to correct it
        protected const float DefaultMaxMainResToCompressorRestartPressureDiff = 10; // Used to check if difference between these two .eng parameters is correct, and to correct it
        protected const float DefaultMaxCompressorRestartPressure = 135; // Max value to be inserted if .eng parameters are corrected
        protected const float DefaultMainResVolume = 0.78f; // Value to be inserted if .eng parameters are corrected
        protected const float DefaultMaxMainResPressure = 140; // Max value to be inserted if .eng parameters are corrected

        public List<CabView> CabViewList = new List<CabView>();
        public CabView3D CabView3D;

        public MSTSNotchController SteamHeatController = new MSTSNotchController(0, 1, 0.1f);

        public MSTSNotchController ThrottleController;
        public ScriptedBrakeController TrainBrakeController;
        public ScriptedBrakeController EngineBrakeController;
        public ScriptedBrakeController BrakemanBrakeController;
        public AirSinglePipe.ValveState EngineBrakeState = AirSinglePipe.ValveState.Lap;
        public MSTSNotchController DynamicBrakeController;
        public MSTSNotchController GearBoxController;

        private int PreviousGearBoxNotch;

        public float EngineBrakeIntervention = -1;
        public float TrainBrakeIntervention = -1;
        public float ThrottleIntervention = -1;
        public float DynamicBrakeIntervention = -1;
        protected float PreviousDynamicBrakeIntervention = -1;

        public ScriptedTrainControlSystem TrainControlSystem;

        public Axle LocomotiveAxle;
        public IIRFilter CurrentFilter;
        public IIRFilter AdhesionFilter;

        public float FilteredMotiveForceN;

        public double CommandStartTime;

        public double LastBrakeSoundTime = 0;

        public float PowerReduction = 0;

        // Icik        
        public ScriptedCircuitBreaker CircuitBreaker;
        public float AdhesionEfficiencyKoef;
        public bool OverCurrent = false;
        public bool OverVoltage = false;
        public bool MultiSystemEngine = false;
        public bool MultiSystemEnginePlayer = false;
        public float MaxCurrentPower;
        public float MaxCurrentBrake;
        public float SlipSpeedCritical;
        public bool EDBIndependent;
        public float PowerOnFilter;
        public float PowerOnFilterCapacity;
        public float PowerOnFilterCapacityLimit;
        public bool HVOffStatusBrakeCyl = false;
        public bool HVOffStatusBrakePipe = false;
        public bool DoesPowerLossResetControls = false;
        public bool DoesPowerLossResetControls2 = false;
        public bool ThrottleZero = false;
        public bool AuxCompressorMode_OffOn;        
        public bool EngineBrakeEngageEDB = false;        
        public bool HeatingEnable = false;
        public bool CabHeatingEnable = false;
        public bool SwitchingVoltageMode_OffAC;
        public bool SwitchingVoltageMode_OffDC;
        public int SwitchingVoltageMode = 1;
        public float PowerReductionByHeatingEng;
        public float PowerReductionByHeatingWag;
        public float PowerReductionByAuxEquipmentEng;
        public float PowerReductionByAuxEquipmentWag;
        public float PowerReduction0;
        public float PowerReduction1;
        public float TElevatedConsumption = 0;
        public float MainResChargingRatePSIpS0;
        public bool AirBrakesIsCompressorElectricOrMechanical;
        public float AirBrakesAirCompressorWattage = 30000;
        float BaseFrictionCoefficientFactor0 = 1;
        public bool CentralHandlingDoors;
        public bool VoltageFilter;
        public float RouteVoltageV;
        public bool RouteVoltageChange;
        public float LocomotivePowerVoltage;
        public float MaxPowerWAC;
        public float MaxForceNAC;
        public float MaxPowerWDC;
        public float MaxForceNDC;
        public InterpolatorDiesel2D TractiveForceCurvesAC;
        public InterpolatorDiesel2D TractiveForceCurvesDC;
        public InterpolatorDiesel2D DynamicBrakeForceCurvesAC;
        public InterpolatorDiesel2D DynamicBrakeForceCurvesDC;
        public float UiPowerLose = 1;
        public bool QuickReleaseButton = false;
        bool QuickReleaseButtonPressed = false;
        public bool LowPressureReleaseButton = false;
        bool LowPressureReleaseButtonPressed = false;
        public bool QuickReleaseButtonEnable = false;
        public bool LowPressureReleaseButtonEnable = false;
        public bool AuxCompressor = false;
        public bool AuxCompressorNoActiveStation = false;
        public bool CompressorCombined = false;
        public bool CompressorCombined2 = false;
        public bool CompressorOffAutoOn = false;
        public bool CompressorOffAutoOn2 = false;
        public bool Compressor_I = false;
        public bool Compressor_II = false;
        public bool Compressor2IsOn;
        public float MainResChargingRatePSIpS_2;
        public float AuxResChargingRatePSIpS;
        public bool AuxCompressorIsOn;
        public float AuxResPressurePSI;
        public float MaxAuxResPressurePSI;
        public float AuxResVolumeM3;
        public float AuxCompressorRestartPressurePSI;
        public float MinAuxPressurePantoPSI;
        public float MinAuxPressureHVPSI;
        public bool AirForPantograph;
        public bool AirForHV;
        public float PantoConsumptionVolumeM3;
        public float HVConsumptionVolumeM3_On;
        public float HVConsumptionVolumeM3_Off;
        public bool HVElectric;
        public float AuxResPipeLeak;     
        public bool Pantograph4 = false;        
        public bool MainResOverPressure = false;
        public bool AuxResOverPressure = false;
        public float MaxMainResOverPressurePSI;
        public float MaxAuxResOverPressurePSI;
        public bool HV5Enable = false;                
        public bool HV2Enable = false;
        public bool HV2ButtonEnable = false;
        public float HV2Switch = 0;
        public float LastStateHV2 = 0;
        public bool HV3Enable = false;                
        public bool HV4Enable = false;                
        public bool HV4SwitchFullDown;
        public float HV4SwitchFullDownCycle;
        public bool HVPressedTestDC = false;
        public bool HVPressedTestAC = false;
        public bool HVPressedTest = false;
        public float HVPressedTime = 0;
        public float HVOnPressedTime = 0;
        public float HVOffPressedTime = 0;
        public bool HVOnPressedTest = false;
        public bool HVOffPressedTest = false;
        public bool HVCanOn = false;
        public bool HV3CanOn = false;
        public float HV3TimeToOn;
        public float CompressorBeep = 0;
        public float Compressor2Beep = 0;
        public bool LocoReadyToGo = false;
        public bool CircuitBreakerOn = false;
        public bool HVOff = false;
        public bool HVOn = false;
        public bool BreakPowerButtonEnable = false;
        public bool BreakPowerButton;
        bool BreakPowerButtonPressed = false;
        public bool BreakPowerButton_Activated;
        public bool LapButtonEnable = false;
        public bool LapButton;
        bool LapButtonPressed = false;
        public bool LapButton_Activated;
        public bool[] LapActive = new bool[3];
        public bool SetLapButtonStart;
        int PantoStatus = 1;        
        public float HeatingMaxCurrentA;
        public bool CheckPowerLoss;
        public bool DontRaisePanto;
        float PreDataAmmeter;
        float PreDataAmmeter2;
        float PreDataAmps;
        public bool AIPantoDown;
        public bool Pantograph4Enable = false;
        public bool Pantograph3Enable = false;        
        public float LastStatePantograph3;
        public bool Pantograph3SwitchFullDown;
        public float Pantograph3SwitchFullDownCycle;
        public bool PantographOnPressedTest;
        public bool PantographOffPressedTest;
        public bool Pantograph3CanOn = false;
        public float PantographOnPressedTime;
        public float PantographOffPressedTime;
        public bool TrainHasFirstPantoMarker;
        public int TrainPantoMarker;
        public bool AIPantoChange;
        public bool AIPanto2Raise = false;
        public float PowerCurrent1;
        public float PowerCurrent2;
        public float BrakeCurrent1;
        public float BrakeCurrent2;
        public bool BailOffPressed;
        public bool ARRTrainBrakeEngage;
        public float ARRAutoCylPressurePSI;
        public bool ARRTrainBrakeEngage_Apply;
        public bool ARRTrainBrakeEngage_Release;                
        public bool DieselDirectionController;
        public bool DieselDirectionController2;
        public bool DieselDirectionController3;
        public bool DieselDirectionController4;
        public bool DieselDirection_Start;
        public bool DieselDirection_Forward;
        public bool DieselDirection_0;
        public bool DieselDirection_Reverse;
        public bool DieselDirectionController_In = false;
        public bool DieselDirectionController_Out = true;
        public bool DieselDirectionControllerInOut = false;
        public float DieselStartDelay;
        public float DieselStartTime;
        public bool DieselStartDelayDone;
        public bool StartButtonPressed;
        public bool StopButtonPressed;
        public bool StopButtonReleased;
        public bool DieselCheckPowerMotorLamp;
        public bool DieselMotorDefected;
        public bool DieselMotorTempWarning;
        public bool DieselMotorPowerLost;
        public bool DieselLocoTempReady;
        public bool RDSTBreakerRDSTEnable;
        public bool RDSTBreakerVZEnable;
        public bool RDSTBreakerPowerEnable;
        public float CurrentTrackSandBoxCapacityKG;
        public bool MUCableCanBeUsed;
        public bool MUCableEquipment;
        public float MaxPowerWBase;
        public bool DoorSwitchEnable;        
        public float PrevDoorSwitch = 1;
        public bool LocoIsStatic;
        public float PantoCanHVOffSpeedKpH;
        public bool DirectionButton;
        public float DirectionButtonPosition = 2;
        public float MemDirectionButtonPosition = -1;
        public float DirectionButtonPositionOffset;
        public bool CarIsPlayerLocoSet;
        public bool BatterySetOn;
        public bool BreakEDBButtonEnable = false;
        public bool BreakEDBSwitchEnable = false;
        public bool BreakEDBButton;
        bool BreakEDBButtonPressed = false;
        public bool BreakEDBButton_Activated;
        public bool AripotControllerEnable;                
        public InterpolatorDiesel2D CurrentForceCurves;        
        public string CabFrontSoundFileName;
        public string CabRearSoundFileName;
        public int CabStationForBatterySwitchOn;                                
        public bool HelperLocoDontPush;
        public bool HelperLocoPush;
        public bool HelperLocoFollow;
        public int HelperSpeedPush;
        public bool HelperPushStart;
        public bool HelperOptionsOpened;
        public bool MirerControllerEnable;
        public int MirerControllerPosition;
        public int prevMirerControllerPosition;
        public float StepControllerValue;        
        public InterpolatorDiesel2D TractiveForceStepControllerCurves;
        public InterpolatorDiesel2D TractiveForceStepControllerCurvesAC;
        public InterpolatorDiesel2D TractiveForceStepControllerCurvesDC;
        public InterpolatorDiesel2D CurrentForceStep1Curves;
        public InterpolatorDiesel2D CurrentForceStep2Curves;
        public InterpolatorDiesel2D CurrentBrakeForce1Curves;
        public InterpolatorDiesel2D CurrentBrakeForce2Curves;
        public int LocoStation = 1;
        public bool LocoHasNoDynamicController = true;
        public bool[] StationIsActivated = new bool[3];        
        public int[] PrePantoStatus = new int[3];
        public int[] Pantograph4Switch = new int[3];
        public int[] Pantograph3Switch = new int[3];
        public int[] CompressorSwitch = new int[3];
        public int[] CompressorSwitch2 = new int[3];        
        public bool[] CompressorMode_OffAuto = new bool[3];
        public bool[] CompressorMode2_OffAuto = new bool[3];
        public bool[] Compressor_I_HandMode = new bool[3];
        public bool[] Compressor_II_HandMode = new bool[3];
        public int[] HV5Switch = new int[3];
        public int[] LastStateHV5 = new int[3];
        public int[] HV4Switch = new int[3];
        public int[] LastStateHV4 = new int[3];
        public int[] HV3Switch = new int[3];
        public int[] LastStateHV3 = new int[3];
        public bool[] Heating_OffOn = new bool[3];
        public int[] HeadLightPosition = new int[3];
        public int[] DirectionPosition = new int[3];
        public bool[] SeasonSwitchPosition = new bool[3];
        public int[] DoorSwitch = new int[3];
        public int[] DieselDirectionControllerPosition = new int[3];
        public int[] DieselDirectionController2Position = new int[3];
        public int[] DieselDirectionController4Position = new int[3];
        public int[] prevDieselDirectionControllerPosition = new int[3];
        public int[] prevDieselDirectionController2Position = new int[3];
        public float[] AripotControllerValue = new float[3];
        public bool[] LocoWiper = new bool[3];
        public float[] EngineBrakeValue = new float[3];
        public float[] AripotControllerPreValue = new float[3];
        public bool[] AripotControllerCanUseThrottle = new bool[3];
        public float[] TrainBrakeValue= new float[3];
        public float[] prevEngineBrakeValue = new float[3];
        public bool TramRailUnit;
        public int TwoPipesConnectionLocoCount;
        public float DriveForceN;
        public bool[] CabRadio = new bool[3];
        public bool CircularSwitchEnable;
        public int[] CircularSwitchWhitePosition = new int[3];
        public int[] CircularSwitchRedPosition = new int[3];
        public bool FirstCabLoaded = true;
        public InterpolatorDiesel2D CoefStepControllerCurves;
        public bool Loco15kV;

        // Jindrich
        public bool IsActive = false;
        public bool EnableControlVoltageChange = true;
        public CruiseControl CruiseControl;
        public MultiPositionController MultiPositionController;
        public List<MultiPositionController> MultiPositionControllers;
        public StringArray StringArray = new StringArray();
        public bool SelectingSpeedPressed = false;
        public bool EngineBrakePriority = false;
        public bool IsAPartOfPlayerTrain = false;
        public float ThrottleOverriden = 0;
        public int AccelerationBits = 0;
        public bool DisableRestrictedSpeedWhenManualDriving = false;
        public bool AutomaticParkingBrake = false;
        public float AutomaticParkingBrakeEngageSpeedKpH = 0;
        public float ParkingBrakeTargetPressurePSI = 0;
        public bool AutomaticParkingBrakeEngaged = false;
        public bool ManualParkingBrakeReleaseRequired = true;
        public List<CabViewControl> ActiveScreens = new List<CabViewControl>();
        public List<CabViewControl> EditableItems = new List<CabViewControl>();
        public ExtendedPhysics extendedPhysics = null;
        public float ControllerVolts;
        public float ThrottleFullRangeIncreaseTimeSeconds = 3;
        public float ThrottleFullRangeDecreaseTimeSeconds = 3;
        public float ThrottleFullRangeDecreaseTimeSecondsFast = 2;
        public float DynamicBrakeFullRangeIncreaseTimeSeconds = 3;
        public float DynamicBrakeFullRangeDecreaseTimeSeconds = 3;
        public float MaxControllerVolts = 10;
        public CurrentDirectionEnum CurrentDirection = CurrentDirectionEnum.Braking;
        public float AcceleratingToBrakingChangeTime = 0;
        public enum DriverStation { None, Station1, Station2 };
        public DriverStation ActiveStation = DriverStation.None;
        public enum KeyPosition { Pocket, Station1, Station2 };
        public KeyPosition CurrentKeyPosition = KeyPosition.Pocket;
        public Mirel Mirel;
        public bool AntiWheelSpinEquipped = false;
        public float AntiWheelSpinSpeedDiffThreshold = 0.5f;
        protected float skidSpeedDegratation = 0;
        public float DynamicBrakeMaxForceAtSelectorStep = 0;
        public float[] SelectedMaxAccelerationStep = new float[3];
        public bool RecuperationAvailable = false;
        public bool MoveThrottle = true;
        public bool UsingForceHandle = false;
        public float ForceHandleValue = 0;
        public bool SplashScreen = false;
        public float SplashScreenMinDuration = 0;
        public float SplashScreenMaxDuration = 0;
        public string TrainNumber = ""; // it's called number, still is a string (i.e. ICE530)
        public string BrakingPercent = "";
        public string ActiveSpeedPosts = "";
        public string UserTrainLength = "";
        public string UserTrainWeight = "";
        public string UserTime = "";
        public DateTime AlerterPressedAt = new DateTime();
        public DateTime SelectedSpeedChangedAt = new DateTime();
        public enum PantoModes { Auto, Forward, Aft, Both };
        public PantoModes PantoMode = PantoModes.Auto;
        public bool PantoCommandDown = false;
        public int InverterTest = 2;
        public bool GeneratoricModeActive = false;
        public bool GeneratoricModeForcedOff = false;
        public bool OdometerDisplayActive = false;
        public int OdometerDistancePassed = 0;

        public bool
      Speed0Pressed, Speed10Pressed, Speed20Pressed, Speed30Pressed, Speed40Pressed, Speed50Pressed
    , Speed60Pressed, Speed70Pressed, Speed80Pressed, Speed90Pressed, Speed100Pressed
    , Speed110Pressed, Speed120Pressed, Speed130Pressed, Speed140Pressed, Speed150Pressed
    , Speed160Pressed, Speed170Pressed, Speed180Pressed, Speed190Pressed, Speed200Pressed;

        public enum PowerSystem
        {
            DE15kV,
            AT15kV,
            AT25kV,
            CZ25kV,
            CZ3kV,
            SK25kV,
            SK3kV
        }

        public enum LocoTypes
        {
            Normal, Vectron, Traxx, Katr7507,
        }

        public LocoTypes LocoType = LocoTypes.Normal;
        public bool DisplaySelectedSpeed = false;
        public bool SelectingSystem = false;
        public PowerSystem SelectedPowerSystem = PowerSystem.CZ25kV;
        public PowerSystem SelectingPowerSystem = PowerSystem.CZ25kV;

        public int SystemAnnunciator = 0;

        public bool SelectedSpeedConfirmed = true;

        public MSTSLocomotive(Simulator simulator, string wagPath)
            : base(simulator, wagPath)
        {
            //  BrakePipeChargingRatePSIpS = Simulator.Settings.BrakePipeChargingRate;

            MilepostUnitsMetric = Simulator.TRK.Tr_RouteFile.MilepostUnitsMetric;
            //BrakeCutsPowerAtBrakeCylinderPressurePSI = 4.0f;

            LocomotiveAxle = new Axle();
            LocomotiveAxle.DriveType = AxleDriveType.ForceDriven;
            LocomotiveAxle.DampingNs = MassKG / 1000.0f;
            LocomotiveAxle.FrictionN = MassKG / 100.0f;
            LocomotiveAxle.StabilityCorrection = true;
            LocomotiveAxle.FilterMovingAverage.Size = Simulator.Settings.AdhesionMovingAverageFilterSize;
            CurrentFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(0.5f), 0.001f);
            AdhesionFilter = new IIRFilter(IIRFilter.FilterTypes.Butterworth, 1, IIRFilter.HzToRad(1f), 0.001f);

            TrainBrakeController = new ScriptedBrakeController(this);
            EngineBrakeController = new ScriptedBrakeController(this);
            BrakemanBrakeController = new ScriptedBrakeController(this);
            ThrottleController = new MSTSNotchController();
            DynamicBrakeController = new MSTSNotchController();
            TrainControlSystem = new ScriptedTrainControlSystem(this);
            Mirel = new Mirel(this);
        }

        /// <summary>
        /// This initializer is called when we haven't loaded this type of car before
        /// and must read it new from the wag file.
        /// </summary>
        public override void LoadFromWagFile(string wagFilePath)
        {
            base.LoadFromWagFile(wagFilePath);            

            // Assumes that CabViewList[0] is the front cab
            // and that CabViewList[1] is the rear cab, if present.
            // Could be extended to more than 2 cabs.
            if (CVFFileName != null)
            {
                var cabView = BuildCabView(WagFilePath, CVFFileName);
                if (cabView != null)
                {
                    CabViewList.Add(cabView);
                    var reverseCVFFileName = Path.Combine(
                        Path.GetDirectoryName(CVFFileName), // Some CVF paths begin with "..\..\", so Path.GetDirectoryName() is needed.
                        Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf"
                    );

                    {
                        cabView = BuildCabView(WagFilePath, reverseCVFFileName);
                        if (cabView != null)
                            CabViewList.Add(cabView);
                    }
                    // practically never happens, but never say never
                    if (CabViewList.Count == 2 && CabViewList[1].CabViewType == CabViewType.Front && CabViewList[0].CabViewType == CabViewType.Rear)
                    {
                        cabView = CabViewList[1];
                        CabViewList.Insert(0, cabView);
                        CabViewList.RemoveAt(2);
                    }
                    // only one cabview, and it looks rear; insert a void one at first place to maintain fast indexing
                    else if (CabViewList.Count == 1 && CabViewList[0].CabViewType == CabViewType.Rear)
                    {
                        UsingRearCab = true;
                        CabViewList.Add(CabViewList[0]);
                        CabViewList[0].CabViewType = CabViewType.Void;
                    }
                }
                CabView3D = BuildCab3DView();
                if (CabViewList.Count == 0 & CabView3D == null)
                    Trace.TraceWarning("{0} locomotive's CabView references non-existent {1}", wagFilePath, CVFFileName);
            }

            //CorrectBrakingParams();
            CheckCoherence();
            GetPressureUnit();
            IsDriveable = true;

            MoveParamsToAxle();
        }

        protected void CheckCoherence()
        {
            if (!TrainBrakeController.IsValid())
                TrainBrakeController = new ScriptedBrakeController(this); //create a blank one

            if (!EngineBrakeController.IsValid())
                EngineBrakeController = null;

            if (!BrakemanBrakeController.IsValid())
                BrakemanBrakeController = null;

            if (ThrottleController == null)
            {
                //If no controller so far, we create a default one
                ThrottleController = new MSTSNotchController();
                ThrottleController.StepSize = 0.1f;
            }

            // need to test for Dynamic brake problem on 3DTS and SLI
            if (DynamicBrakeController.IsValid())
            {
                if (DynamicBrakeController.NotchCount() <= 3)
                {
                    HasSmoothStruc = true;
                }
            }
            else
                DynamicBrakeController = null;

            if ((DynamicBrakeForceCurves == null && DynamicBrakeForceCurvesAC == null && DynamicBrakeForceCurvesDC == null) && MaxDynamicBrakeForceN > 0)
            {
                DynamicBrakeForceCurves = new InterpolatorDiesel2D(2);
                Interpolator interp = new Interpolator(2);
                interp[0] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[0] = interp;
                interp = new Interpolator(7);
                interp[0] = 0;
                interp[DynamicBrakeSpeed1MpS] = 0;
                interp[DynamicBrakeSpeed2MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed3MpS] = MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS] = DynamicBrakeRatioAtSpeed4 * MaxDynamicBrakeForceN;
                interp[DynamicBrakeSpeed4MpS + 0.5f] = 0;
                interp[100] = 0;
                DynamicBrakeForceCurves[1] = interp;
            }
        }

        protected float checkAccBitsPreviousSpeed = 0;
        protected float checkAccBitsOffTime = 0;
        protected void CheckAccelerationBits(float elapsedSeconds, float speed)
        {
            float delta = MpS.ToKpH(speed) - checkAccBitsPreviousSpeed;
            if (delta > 0.5) // increased, blink the increasing speed sign
            {
                checkAccBitsPreviousSpeed = MpS.ToKpH(speed);
                AccelerationBits = 2;
                checkAccBitsOffTime = 0;
            }
            if (delta < -0.5) // decreased, blink the decreasing speed sign
            {
                checkAccBitsPreviousSpeed = MpS.ToKpH(speed);
                AccelerationBits = 1;
                checkAccBitsOffTime = 0;
            }
            checkAccBitsOffTime += elapsedSeconds;
            if (checkAccBitsOffTime > 0.25f)
            {
                AccelerationBits = 0;
                checkAccBitsOffTime = 0;
            }
        }

        protected void GetPressureUnit()
        {
            switch (Simulator.Settings.PressureUnit)
            {
                default:
                case "Automatic":
                    if (CabViewList.Count > 0)
                    {
                        Dictionary<CABViewControlTypes, BrakeSystemComponent> brakeSystemComponents = new Dictionary<CABViewControlTypes, BrakeSystemComponent>
                        {
                            { CABViewControlTypes.MAIN_RES, BrakeSystemComponent.MainReservoir },
                            { CABViewControlTypes.EQ_RES, BrakeSystemComponent.EqualizingReservoir },
                            { CABViewControlTypes.BRAKE_CYL, BrakeSystemComponent.BrakeCylinder },
                            { CABViewControlTypes.BRAKE_PIPE, BrakeSystemComponent.BrakePipe }
                        };

                        Dictionary<CABViewControlUnits, PressureUnit> pressureUnits = new Dictionary<CABViewControlUnits, PressureUnit>
                        {
                            { CABViewControlUnits.KILOPASCALS, PressureUnit.KPa },
                            { CABViewControlUnits.BAR, PressureUnit.Bar },
                            { CABViewControlUnits.PSI, PressureUnit.PSI },
                            { CABViewControlUnits.INCHES_OF_MERCURY, PressureUnit.InHg },
                            { CABViewControlUnits.KGS_PER_SQUARE_CM, PressureUnit.KgfpCm2 }
                       };

                        CabViewControls cvcList = CabViewList[0].CVFFile.CabViewControls;
                        foreach (CabViewControl cvc in cvcList)
                        {
                            if (brakeSystemComponents.ContainsKey(cvc.ControlType) && pressureUnits.ContainsKey(cvc.Units))
                            {
                                BrakeSystemComponent component = brakeSystemComponents[cvc.ControlType];
                                PressureUnit unit = pressureUnits[cvc.Units];

                                BrakeSystemPressureUnits[component] = unit;
                            }
                        }
                    }

                    // Manual rules :
                    BrakeSystemPressureUnits[BrakeSystemComponent.MainPipe] = BrakeSystemPressureUnits[BrakeSystemComponent.MainReservoir]; // Main Pipe is supplied by Main Reservoir
                    BrakeSystemPressureUnits[BrakeSystemComponent.AuxiliaryReservoir] = BrakeSystemPressureUnits[BrakeSystemComponent.BrakePipe]; // Auxiliary Reservoir is supplied by Brake Pipe (in single pipe brakes)
                    BrakeSystemPressureUnits[BrakeSystemComponent.EmergencyReservoir] = BrakeSystemPressureUnits[BrakeSystemComponent.BrakePipe]; // Emergency Reservoir is supplied by Brake Pipe

                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        if (BrakeSystemPressureUnits[component] == PressureUnit.None)
                        {
                            BrakeSystemPressureUnits[component] = (MilepostUnitsMetric ? PressureUnit.Bar : PressureUnit.PSI);
                        }
                    }
                    break;

                case "bar":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.Bar;
                    }
                    break;

                case "PSI":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.PSI;
                    }
                    break;

                case "inHg":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.InHg;
                    }
                    break;

                case "kgf/cm^2":
                    foreach (BrakeSystemComponent component in BrakeSystemPressureUnits.Keys.ToList())
                    {
                        BrakeSystemPressureUnits[component] = PressureUnit.KgfpCm2;
                    }
                    break;
            }

            // The main pressure unit is the one that is the most present in the brake system
            MainPressureUnit = BrakeSystemPressureUnits.Values.ToList()
                .GroupBy(x => x)
                .OrderByDescending(x => x.Count())
                .First().Key;
        }

        protected CabView BuildCabView(string wagFilePath, string cvfFileName)
        {
            var viewPointList = new List<ViewPoint>();
            var extendedCVF = new ExtendedCVF();
            bool noseAhead = false;

            var cvfBasePath = Path.Combine(Path.GetDirectoryName(wagFilePath), "CABVIEW");
            var cvfFilePath = Path.Combine(cvfBasePath, cvfFileName);
            if (!File.Exists(cvfFilePath))
                return null;

            var cvfFile = new CabViewFile(cvfFilePath, cvfBasePath);
            var viewPoint = new ViewPoint();
            if (cvfFile.Locations.Count <= 0) return null; //check for Protrain's dummy cab
            // Set up camera locations for the cab views
            for (int i = 0; i < cvfFile.Locations.Count; ++i)
            {
                if (i >= cvfFile.Locations.Count || i >= cvfFile.Directions.Count)
                {
                    Trace.TraceWarning("Skipped cab view camera {1} missing Position and Direction in {0}", cvfFilePath, i);
                    break;
                }
                viewPoint = new ViewPoint();
                viewPoint.Location = cvfFile.Locations[i];
                viewPoint.StartDirection = cvfFile.Directions[i];
                viewPoint.RotationLimit = new Vector3(0, 0, 0);  // cab views have a fixed head position
                viewPointList.Add(viewPoint);
            }
            var cabViewType = new CabViewType();
            cabViewType = ((viewPointList[0].StartDirection.Y >= 90 && viewPointList[0].StartDirection.Y <= 270)
                || (viewPointList[0].StartDirection.Y <= -90 && viewPointList[0].StartDirection.Y >= -270)) ? CabViewType.Rear : CabViewType.Front;
            var wag = this as MSTSWagon;
            var wagFolderSlash = Path.GetDirectoryName(wag.WagFilePath) + @"\";
            string shapeFilePath;
            bool boundingLimitsFound = false;
            ShapeDescriptorFile shapeFile = new ShapeDescriptorFile();
            if (wag.FreightShapeFileName != null)
            {
                shapeFilePath = wagFolderSlash + wag.FreightShapeFileName;
                if (shapeFilePath != null && File.Exists(shapeFilePath + "d"))
                {
                    shapeFile = new ShapeDescriptorFile(shapeFilePath + "d");
                    if (shapeFile.shape.ESD_Bounding_Box != null) boundingLimitsFound = true;
                }
            }
            if (!boundingLimitsFound)
            {
                shapeFilePath = wagFolderSlash + wag.MainShapeFileName;
                if (shapeFilePath != null && File.Exists(shapeFilePath + "d"))
                {
                    shapeFile = new ShapeDescriptorFile(shapeFilePath + "d");
                    if (shapeFile.shape.ESD_Bounding_Box != null) boundingLimitsFound = true;
                }
            }
            if (boundingLimitsFound)
            {
                if (cabViewType == CabViewType.Front)
                    noseAhead = (viewPointList[0].Location.Z + 0.5f < shapeFile.shape.ESD_Bounding_Box.Max.Z) ? true : false;
                else if (cabViewType == CabViewType.Rear)
                    noseAhead = (viewPointList[0].Location.Z - 0.5f > shapeFile.shape.ESD_Bounding_Box.Min.Z) ? true : false;
            }
            if (!(this is MSTSSteamLocomotive))
            {
                InitializeFromORTSSpecific(cvfFilePath, extendedCVF);
            }
            return new CabView(cvfFile, viewPointList, extendedCVF, cabViewType, noseAhead);
        }

        protected CabView3D BuildCab3DView()
        {
            if (Cab3DShapeFileName == null)
                return null;

            var extendedCVF = new ExtendedCVF();
            bool noseAhead = false;

            var cab3dBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW3D");
            var shapeFilePath = Path.Combine(cab3dBasePath, Cab3DShapeFileName);
            if (!File.Exists(shapeFilePath))
                return null;

            var cvfBasePath = cab3dBasePath;
            var cvfFilePath = Path.Combine(cvfBasePath, Path.ChangeExtension(Cab3DShapeFileName, "cvf"));
            if (!File.Exists(cvfFilePath))
            {
                cvfFilePath = Path.Combine(cvfBasePath, CVFFileName);
                if (!File.Exists(cvfFilePath))
                {
                    cvfBasePath = Path.Combine(Path.GetDirectoryName(WagFilePath), "CABVIEW");
                    cvfFilePath = Path.Combine(cvfBasePath, CVFFileName);
                    if (!File.Exists(cvfFilePath))
                        return null;
                }
            }
            var cvfFile = new CabViewFile(cvfFilePath, cvfBasePath);
            if (!(this is MSTSSteamLocomotive))
                InitializeFromORTSSpecific(cvfFilePath, extendedCVF);

            var cabViewAngle = CabViewpoints[0].StartDirection.Y;
            var cabViewType = (cabViewAngle >= 90 && cabViewAngle <= 270) || (cabViewAngle <= -90 && cabViewAngle >= -270) ? CabViewType.Rear : CabViewType.Front;

            // only one cabview, and it looks rear; insert a void one at first place to maintain fast indexing
            if (CabViewpoints.Count == 1 && cabViewType == CabViewType.Rear)
                CabViewpoints.Insert(0, new PassengerViewPoint());

            return new CabView3D(cvfFile, CabViewpoints, extendedCVF, cabViewType, noseAhead, shapeFilePath);
        }

        /// <summary>
        /// Parse the wag file parameters required for the simulator and viewer classes
        /// </summary>
        public override void Parse(string lowercasetoken, STFReader stf)
        {
            switch (lowercasetoken)
            {
                case "engine(sound": CabSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabview": CVFFileName = stf.ReadStringBlock(null); break;
                case "engine(maxpower": MaxPowerW = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforce": MaxForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxcurrent": MaxCurrentA = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(maxcontinuousforce": MaxContinuousForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(ortsspeedofmaxcontinuousforce": SpeedOfMaxContinuousForceMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(dieselenginespeedofmaxtractiveeffort": MSTSSpeedOfMaxContinuousForceMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(maxvelocity": MaxSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(ortsunloadingspeed": UnloadingSpeedMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(type":
                    stf.MustMatch("(");
                    var engineType = stf.ReadString();
                    try
                    {
                        EngineType = (EngineTypes)Enum.Parse(typeof(EngineTypes), engineType.First().ToString().ToUpper() + engineType.Substring(1));
                    }
                    catch
                    {
                        STFException.TraceWarning(stf, "Skipped unknown engine type " + engineType);
                    }
                    break;

                case "engine(enginecontrollers(throttle": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(regulator": ThrottleController = new MSTSNotchController(stf); break;
                case "engine(enginecontrollers(brake_dynamic": DynamicBrakeController.Parse(stf); LocoHasNoDynamicController = false; break;

                case "engine(trainbrakescontrollermaxsystempressure":
                case "engine(ortstrainbrakescontrollermaxoverchargepressure":
                case "engine(trainbrakescontrollermaxreleaserate":
                case "engine(trainbrakescontrollermaxquickreleaserate":
                case "engine(ortstrainbrakescontrolleroverchargeeliminationrate":
                case "engine(trainbrakescontrollermaxapplicationrate":
                case "engine(trainbrakescontrolleremergencyapplicationrate":
                case "engine(trainbrakescontrollerfullservicepressuredrop":
                case "engine(trainbrakescontrollerminpressurereduction":
                case "engine(ortstrainbrakescontrollerslowapplicationrate":
                case "engine(ortstrainbrakecontroller":
                case "engine(enginecontrollers(brake_train":
                    TrainBrakeController.Parse(lowercasetoken, stf);
                    TrainBrakeFitted = true;
                    break;
                case "engine(enginecontrollers(ortsfastvacuumexhauster": FastVacuumExhausterFitted = true; break;
                case "engine(enginebrakescontrollermaxsystempressure":
                case "engine(enginebrakescontrollermaxreleaserate":
                case "engine(enginebrakescontrollermaxquickreleaserate":
                case "engine(enginebrakescontrollermaxapplicationrate":
                case "engine(enginebrakescontrolleremergencyapplicationrate":
                case "engine(enginebrakescontrollerfullservicepressuredrop":
                case "engine(enginebrakescontrollerminpressurereduction":
                case "engine(ortsenginebrakescontrollerslowapplicationrate":
                case "engine(enginecontrollers(brake_engine":
                case "engine(ortsenginebrakecontroller":
                    EngineBrakeController.Parse(lowercasetoken, stf);
                    EngineBrakeFitted = true;
                    break;
                case "engine(enginecontrollers(brake_brakeman":
                    BrakemanBrakeController.Parse(lowercasetoken, stf);
                    BrakemanBrakeFitted = true;
                    break;
                case "engine(ortstraincontrolsystem":
                case "engine(ortstraincontrolsystemsound":
                case "engine(ortstraincontrolsystemparameters":
                case "engine(vigilancemonitor":
                case "engine(emergencystopmonitor":
                case "engine(awsmonitor":
                case "engine(overspeedmonitor": VigilanceMonitor = true; TrainControlSystem.Parse(lowercasetoken, stf); break;
                case "engine(enginecontrollers(combined_control": ParseCombData(lowercasetoken, stf); break;
                case "engine(airbrakesmainresvolume": MainResVolumeM3 = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(airbrakesmainmaxairpressure": MainResPressurePSI = MaxMainResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(airbrakescompressorrestartpressure": CompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(airbrakesaircompressorpowerrating": CompressorChargingRateM3pS = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(trainpipeleakrate": TrainBrakePipeLeakPSIorInHgpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(vacuumbrakesvacuumpumpresistance": VacuumPumpResistanceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;

                case "engine(ortsvacuumbrakesmainresvolume": VacuumBrakesMainResVolumeM3 = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(ortsvacuumbrakesmainresmaxvacuum": VacuumBrakesMainResMaxVacuumPSIAorInHg = OneAtmospherePSI - stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break; // convert to PSIA for vacuum brakes
                case "engine(ortsvacuumbrakesexhausterrestartvacuum": VacuumBrakesExhausterRestartVacuumPSIAorInHg = OneAtmospherePSI - stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break; // convert to PSIA for vacuum brakes
                case "engine(ortsvacuumbrakesmainreschargingrate": VacuumBrakesMainResChargingRatePSIAorInHgpS = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;

                case "engine(ortsmainreschargingrate": MainResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsenginebrakereleaserate": EngineBrakeReleaseRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsenginebrakeapplicationrate": EngineBrakeApplyRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsbrakepipetimefactor": BrakePipeTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakeservicetimefactor": BrakeServiceTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakeemergencytimefactor": BrakeEmergencyTimeFactorS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(ortsbrakepipechargingrate": BrakePipeChargingRatePSIorInHgpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsbrakepipequickchargingrate": BrakePipeQuickChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsbrakepipedischargetimemult": BrakePipeDischargeTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(ortsmaxtractiveforcecurves": TractiveForceCurves = new InterpolatorDiesel2D(stf, false); TractiveForceCurves.HasNegativeValue(); break;
                case "engine(ortstractioncharacteristics": TractiveForceCurves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsdynamicbrakeforcecurves": DynamicBrakeForceCurves = new InterpolatorDiesel2D(stf, false); break;
                case "engine(ortsextendedexcitationcurrent": ExtendedExcitationCurrent = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsextendedarmcurrent": ExtendedArmCurrent = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsextendededbextcurrent": ExtendedExcitationEDBCurrent = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsextendededbarmcurrent": ExtendedArmEDBCurrent = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortscontinuousforcetimefactor": ContinuousForceTimeFactor = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(orts(ortssanderspeedeffectupto": SanderSpeedEffectUpToMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(orts(ortsemergencycausespowerdown": EmergencyCausesPowerDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortsemergencycausesthrottledown": EmergencyCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortsemergencyengageshorn": EmergencyEngagesHorn = stf.ReadBoolBlock(false); break;
                case "engine(orts(ortswheelslipcausesthrottledown": WheelslipCausesThrottleDown = stf.ReadBoolBlock(false); break;
                case "engine(dynamicbrakesminusablespeed": DynamicBrakeSpeed1MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesfadingspeed": DynamicBrakeSpeed2MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumeffectivespeed": DynamicBrakeSpeed3MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakesmaximumspeedforfadeout": DynamicBrakeSpeed4MpS = stf.ReadFloatBlock(STFReader.UNITS.SpeedDefaultMPH, null); break;
                case "engine(dynamicbrakeseffectatmaximumfadeout": DynamicBrakeRatioAtSpeed4 = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(dynamicbrakesmaximumforce": MaxDynamicBrakeForceN = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(dynamicbrakehasautobailoff":
                case "engine(ortsdynamicbrakeshasautobailoff": DynamicBrakeAutoBailOff = stf.ReadBoolBlock(true); break;
                case "engine(dynamicbrakesdelaytimebeforeengaging": DynamicBrakeDelayS = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(dynamicbrakesresistorcurrentlimit": DynamicBrakeMaxCurrentA = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(numwheels": MSTSLocoNumDrvWheels = stf.ReadFloatBlock(STFReader.UNITS.None, 4.0f); if (MSTSLocoNumDrvWheels < 1) STFException.TraceWarning(stf, "Engine:NumWheels is less than 1, parts of the simulation may not function correctly"); break;
                case "engine(ortsnumberdriveaxles": LocoNumDrvAxles = stf.ReadIntBlock(null); if (LocoNumDrvAxles < 1) STFException.TraceWarning(stf, "Engine:ORTSNumberDriveAxles is less than 1, parts of the simulation may not function correctly"); break;
                case "engine(antislip": AntiSlip = stf.ReadBoolBlock(false); break;
                case "engine(ortsdrivewheelweight": InitialDrvWheelWeightKg = stf.ReadFloatBlock(STFReader.UNITS.Mass, null); break;
                case "engine(engineoperatingprocedures": EngineOperatingProcedures = stf.ReadStringBlock(""); break;
                case "engine(headout":
                    HeadOutViewpoints.Add(new ViewPoint(stf.ReadVector3Block(STFReader.UNITS.Distance, Vector3.Zero)));
                    HeadOutViewpoints.Add(new ViewPoint(HeadOutViewpoints[0], true));
                    break;
                case "engine(sanding": SanderSpeedOfMpS = stf.ReadFloatBlock(STFReader.UNITS.Speed, 30.0f); break;
                case "engine(ortsdoesvacuumbrakecutpower": DoesVacuumBrakeCutPower = stf.ReadBoolBlock(false); break;
                case "engine(doesbrakecutpower": DoesBrakeCutPower = stf.ReadBoolBlock(false); break;
                case "engine(brakecutspoweratbrakecylinderpressure": BrakeCutsPowerAtBrakeCylinderPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(ortsbrakecutspoweratbrakepipepressure": BrakeCutsPowerAtBrakePipePressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(ortsbrakerestorespoweratbrakepipepressure": BrakeRestoresPowerAtBrakePipePressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(doeshorntriggerbell": DoesHornTriggerBell = stf.ReadBoolBlock(false); break;
                case "engine(brakesenginecontrollers":
                    foreach (var brakesenginecontrollers in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        if (EngineType == EngineTypes.Electric || EngineType == EngineTypes.Diesel)
                        {
                            switch (brakesenginecontrollers)
                            {
                                case "blended":
                                    DynamicBrakeBlendingEnabled = true;
                                    break;
                                case "dynamic":
                                    DynamicBrakeAvailable = true;
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    break;

                case "engine(brakestrainbraketype":
                    foreach (var brakestrainbraketype in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        switch (brakestrainbraketype)
                        {
                            case "vacuum_single_pipe_eq":
                                VacuumBrakeEQFitted = true;
                                break;
                            default:
                                break;
                        }
                    }
                    break;

                case "engine(brakesenginebraketype":
                    foreach (var brakesenginebraketype in stf.ReadStringBlock("").ToLower().Replace(" ", "").Split(','))
                    {
                        switch (brakesenginebraketype)
                        {
                            case "steam_brake":
                                SteamEngineBrakeFitted = true;
                                break;
                            default:
                                break;
                        }
                    }
                    break;
                case "engine(ortsdynamicblendingoverride": DynamicBrakeBlendingOverride = stf.ReadBoolBlock(false); break;
                case "engine(ortsdynamicblendingforcematch": DynamicBrakeBlendingForceMatch = stf.ReadBoolBlock(false); break;
                case "engine(vacuumbrakeshasvacuumpump": VacuumPumpFitted = stf.ReadBoolBlock(false); break;
                case "engine(enginecontrollers(ortssteamheat": SteamHeatController.Parse(stf); break;
                case "engine(name": stf.MustMatch("("); LocomotiveName = stf.ReadString(); break;
                case "engine(maxsteamheatingpressure": MaxSteamHeatPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(ortsonlinecabradio": OnLineCabRadio = stf.ReadBoolBlock(false); break;
                case "engine(ortsonlinecabradiourl": OnLineCabRadioURL = stf.ReadString(); break;
                case "engine(vacuumbrakesminboilerpressuremaxvacuum": MaxVaccuumMaxPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(enginecontrollers(waterscoop": HasWaterScoop = true; break;
                case "engine(ortswaterscoopfillelevation": WaterScoopFillElevationM = stf.ReadFloatBlock(STFReader.UNITS.Distance, 0.0f); break;
                case "engine(ortswaterscoopdepth": WaterScoopDepthM = stf.ReadFloatBlock(STFReader.UNITS.Distance, 0.0f); break;
                case "engine(ortswaterscoopwidth": WaterScoopWidthM = stf.ReadFloatBlock(STFReader.UNITS.Distance, 0.0f); break;
                case "engine(ortsmaxtracksanderboxcapacity": MaxTrackSandBoxCapacityL = stf.ReadFloatBlock(STFReader.UNITS.Volume, null); break;
                case "engine(ortsmaxtracksandersandconsumption": TrackSanderSandConsumptionLpS = stf.ReadFloatBlock(STFReader.UNITS.Volume, null); break;
                case "engine(ortsmaxtracksanderairconsumption": TrackSanderAirComsumptionLpS = stf.ReadFloatBlock(STFReader.UNITS.Volume, null); break;
                // Icik
                case "engine(adhesionefficiencykoef": AdhesionEfficiencyKoef = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(multisystemengine": EnableControlVoltageChange = false; MultiSystemEngine = MultiSystemEnginePlayer = stf.ReadBoolBlock(false); break;
                case "engine(maxcurrentpower": MaxCurrentPower = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(maxcurrentbrake": MaxCurrentBrake = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(slipspeedcritical": SlipSpeedCritical = stf.ReadFloatBlock(STFReader.UNITS.Speed, null); break;
                case "engine(edbindependent": EDBIndependent = stf.ReadBoolBlock(false); break;
                case "engine(doespowerlossresetcontrols": DoesPowerLossResetControls = stf.ReadBoolBlock(false); break;
                case "engine(doespowerlossresetcontrols2": DoesPowerLossResetControls2 = stf.ReadBoolBlock(false); break;
                case "engine(airbrakesiscompressorelectricormechanical": AirBrakesIsCompressorElectricOrMechanical = stf.ReadBoolBlock(false); break;
                case "engine(airbrakesaircompressorwattage": AirBrakesAirCompressorWattage = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(centralhandlingdoors": CentralHandlingDoors = stf.ReadBoolBlock(false); break;
                case "engine(voltagefilter": VoltageFilter = stf.ReadBoolBlock(false); break;
                case "engine(locomotivepowervoltage": EnableControlVoltageChange = false; LocomotivePowerVoltage = stf.ReadFloatBlock(STFReader.UNITS.Voltage, null); break;
                case "engine(maxpowerac": MaxPowerWAC = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforceac": MaxForceNAC = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(maxpowerdc": MaxPowerWDC = stf.ReadFloatBlock(STFReader.UNITS.Power, null); break;
                case "engine(maxforcedc": MaxForceNDC = stf.ReadFloatBlock(STFReader.UNITS.Force, null); break;
                case "engine(ortstractioncharacteristicsac": TractiveForceCurvesAC = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortstractioncharacteristicsdc": TractiveForceCurvesDC = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsdynamicbrakeforcecurvesac": DynamicBrakeForceCurvesAC = new InterpolatorDiesel2D(stf, false); break;
                case "engine(ortsdynamicbrakeforcecurvesdc": DynamicBrakeForceCurvesDC = new InterpolatorDiesel2D(stf, false); break;
                case "engine(ortsmainreschargingrate2": MainResChargingRatePSIpS_2 = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(ortsauxreschargingrate": AuxResChargingRatePSIpS = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(maxauxrespressure": MaxAuxResPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(auxresvolume": AuxResVolumeM3 = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(auxcompressorrestartpressure": AuxCompressorRestartPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(minauxpressurepanto": MinAuxPressurePantoPSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(minauxpressurehv": MinAuxPressureHVPSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(pantoconsumptionvolume": PantoConsumptionVolumeM3 = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(hvconsumptionvolumeon": HVConsumptionVolumeM3_On = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(hvconsumptionvolumeoff": HVConsumptionVolumeM3_Off = Me3.FromFt3(stf.ReadFloatBlock(STFReader.UNITS.VolumeDefaultFT3, null)); break;
                case "engine(hvelectric": HVElectric = stf.ReadBoolBlock(false); break;
                case "engine(auxrespipeleak": AuxResPipeLeak = stf.ReadFloatBlock(STFReader.UNITS.PressureRateDefaultPSIpS, null); break;
                case "engine(maxmainresoverpressure": MaxMainResOverPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(maxauxresoverpressure": MaxAuxResOverPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(heatingmaxcurrent": HeatingMaxCurrentA = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(dieselstartdelay": DieselStartDelay = stf.ReadFloatBlock(STFReader.UNITS.Time, 10); break;
                case "engine(mucableequipment": MUCableEquipment = stf.ReadBoolBlock(false); break;
                case "engine(pantocanhvoff": PantoCanHVOffSpeedKpH = stf.ReadFloatBlock(STFReader.UNITS.Speed, 0); break;
                case "engine(maxtrainbrakepressure": BrakeSystem.MCP_TrainBrake = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, null); break;
                case "engine(ortscurrentcharacteristics": CurrentForceCurves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(soundfront": CabFrontSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(soundrear": CabRearSoundFileName = stf.ReadStringBlock(null); break;
                case "engine(cabstationforbatteryswitchon": CabStationForBatterySwitchOn = stf.ReadIntBlock(null); break;
                case "engine(ortstractioncharacteristicsstepcontroller": TractiveForceStepControllerCurves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortstractioncharacteristicsstepcontrollerac": TractiveForceStepControllerCurvesAC = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortstractioncharacteristicsstepcontrollerdc": TractiveForceStepControllerCurvesDC = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortscurrentforcestep1characteristics": CurrentForceStep1Curves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortscurrentforcestep2characteristics": CurrentForceStep2Curves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsbrakecurrent1characteristics": CurrentBrakeForce1Curves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(ortsbrakecurrent2characteristics": CurrentBrakeForce2Curves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(auxconsumptioncurrents(cabheating": Current_CabHeating = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(auxconsumptioncurrents(tmcoolings": Current_TMCoolings = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(auxconsumptioncurrents(otherscoolings": Current_OthersCoolings = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(auxconsumptioncurrents(compressor1": Current_Compressor1 = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(auxconsumptioncurrents(compressor2": Current_Compressor2 = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(auxconsumptioncurrents(auxcompressor": Current_AuxCompressor = stf.ReadFloatBlock(STFReader.UNITS.Current, null); break;
                case "engine(tmparameters(maxtmtemperature": MaxTMTemperatureDegC = stf.ReadFloatBlock(STFReader.UNITS.Temperature, null); break;
                case "engine(tmparameters(idletmtemperature": IdleTMTemperatureDegC = stf.ReadFloatBlock(STFReader.UNITS.Temperature, null); break;
                case "engine(tmparameters(airtmcoolingpower": AirTMCoolingPower = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(tmparameters(tmtemptimeconstantsec": TMTempTimeConstantSec = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(ortscoefcharacteristics": CoefStepControllerCurves = new InterpolatorDiesel2D(stf, true); break;
                case "engine(drparameters(maxdrtemperature": MaxDRTemperatureDegC = stf.ReadFloatBlock(STFReader.UNITS.Temperature, null); break;
                case "engine(drparameters(idledrtemperature": IdleDRTemperatureDegC = stf.ReadFloatBlock(STFReader.UNITS.Temperature, null); break;
                case "engine(drparameters(airdrcoolingpower": AirDRCoolingPower = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;
                case "engine(drparameters(drtemptimeconstantsec": DRTempTimeConstantSec = stf.ReadFloatBlock(STFReader.UNITS.None, null); break;                
                case "engine(stepcontrollersituation(relaydelay_1": RelayDelay[1] = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;                    
                case "engine(stepcontrollersituation(relaydelay_2": RelayDelay[2] = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(stepcontrollersituation(relaydelay_3": RelayDelay[3] = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(stepcontrollersituation(relaydelay_4": RelayDelay[4] = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;
                case "engine(stepcontrollersituation(relaydelay_5": RelayDelay[5] = stf.ReadFloatBlock(STFReader.UNITS.Time, null); break;                
                    

                // Jindrich
                case "engine(usingforcehandle": UsingForceHandle = stf.ReadBoolBlock(false); break;
                case "engine(batterydefaultoff": Battery = !stf.ReadBoolBlock(false); break;
                case "engine(throttlefullrangeincreasetimeseconds": ThrottleFullRangeIncreaseTimeSeconds = stf.ReadFloatBlock(STFReader.UNITS.Any, 5); break;
                case "engine(throttlefullrangedecreasetimeseconds": ThrottleFullRangeDecreaseTimeSeconds = stf.ReadFloatBlock(STFReader.UNITS.Any, 5); break;
                case "engine(throttlefullrangedecreasetimesecondsfast": ThrottleFullRangeDecreaseTimeSecondsFast = stf.ReadFloatBlock(STFReader.UNITS.Any, 2); break;
                case "engine(dynamicbrakefullrangeincreasetimeseconds": DynamicBrakeFullRangeIncreaseTimeSeconds = stf.ReadFloatBlock(STFReader.UNITS.Any, 5); break;
                case "engine(dynamicbrakefullrangedecreasetimeseconds": DynamicBrakeFullRangeDecreaseTimeSeconds = stf.ReadFloatBlock(STFReader.UNITS.Any, 5); break;
                case "engine(acceleratingtobrakingchangetime": AcceleratingToBrakingChangeTime = stf.ReadFloatBlock(STFReader.UNITS.Any, 2); break;
                case "engine(maxcontrollervolts": MaxControllerVolts = stf.ReadFloatBlock(STFReader.UNITS.Any, 5); break;
                case "engine(ortscruisecontrol": SetUpCruiseControl(); break;
                case "engine(ortsmirel": SetUpMirel(); break;
                case "engine(ortsmirel(defaultmaxspeedkph": Mirel.MaxSelectedSpeed = stf.ReadFloatBlock(STFReader.UNITS.Speed, 80); break;
                case "engine(ortsmirel(pressurefortestpassbar": Mirel.PressureForTestPassBar = stf.ReadFloatBlock(STFReader.UNITS.Speed, 4.9f); break;
                case "engine(ortsmirel(lvztype":
                    {
                        String type = stf.ReadStringBlock(String.Empty).ToLower();
                        switch (type)
                        {
                            case "full":
                                {
                                    Mirel.MirelType = Mirel.Type.Full;
                                    break;
                                }
                            case "ls90":
                                {
                                    Mirel.MirelType = Mirel.Type.LS90;
                                    break;
                                }
                            default:
                                {
                                    Mirel.MirelType = Mirel.Type.Full;
                                    break;
                                }
                        }
                        break;
                    }
                case "engine(ortsmirel(noalertonrestrictedsignal": Mirel.NoAlertOnRestrictedSignal = stf.ReadBoolBlock(false); break;
                case "engine(ortsmultipositioncontroller": SetUpMPC(); break;
                case "engine(disablerestrictedspeedwhenmanualdriving": DisableRestrictedSpeedWhenManualDriving = stf.ReadBoolBlock(false); break;
                case "engine(ortsautomaticparkingbrake": AutomaticParkingBrake = true; break;
                case "engine(ortsautomaticparkingbrake(engagespeed": AutomaticParkingBrakeEngageSpeedKpH = stf.ReadFloatBlock(STFReader.UNITS.Speed, 0); break;
                case "engine(ortsautomaticparkingbrake(targetpressurepsi": ParkingBrakeTargetPressurePSI = stf.ReadFloatBlock(STFReader.UNITS.PressureDefaultPSI, 30); break;
                case "engine(ortssplashscreen(minduration": SplashScreenWillBeDisplayed = true; SplashScreenMinDuration = stf.ReadFloatBlock(STFReader.UNITS.Time, 0); break;
                case "engine(ortssplashscreen(maxduration": SplashScreenWillBeDisplayed = true; SplashScreenMaxDuration = stf.ReadFloatBlock(STFReader.UNITS.Time, 0); break;
                case "engine(antiwheelspinequipped": AntiWheelSpinEquipped = stf.ReadBoolBlock(false); break;
                case "engine(antiwheelspinspeeddiffthreshold": AntiWheelSpinSpeedDiffThreshold = stf.ReadFloatBlock(STFReader.UNITS.None, 0.5f); break;
                case "engine(dynamicbrakemaxforceatselectorstep": DynamicBrakeMaxForceAtSelectorStep = stf.ReadFloatBlock(STFReader.UNITS.Any, 1.0f); break;
                case "engine(defaultforcestep": SelectedMaxAccelerationStep[1] = stf.ReadFloatBlock(STFReader.UNITS.Any, 1.0f); SelectedMaxAccelerationStep[2] = SelectedMaxAccelerationStep[1]; break;
                case "engine(stringarrays":
                    stf.MustMatch("(");
                    while (!stf.EndOfBlock())
                    {
                        stf.ParseBlock(new STFReader.TokenProcessor[] {
                        new STFReader.TokenProcessor("stringarray", ()=>{
                            stf.MustMatch("(");
                            int index = (int)stf.ReadFloatBlock(STFReader.UNITS.None, 0);
                            StrArray strArray = new StrArray();
                            foreach (var array in stf.ReadStringBlock("").Split(','))
                            {
                                int displayID = -1;
                                string updatedArray = "";
                                if (array.Contains("{") && array.Contains("}"))
                                {
                                    string[] behaviors = array.Split('{');
                                    updatedArray = behaviors[0];
                                    displayID = int.Parse(behaviors[1].Replace("}", ""));
                                }
                                else
                                {
                                    updatedArray = array;
                                }
                                if (strArray.Strings == null)
                                {
                                    strArray.Strings = new Dictionary<string, int>();
                                    strArray.Index = index;
                                }
                                else
                                {
                                    strArray.Index = index;
                                }
                                strArray.Strings.Add(updatedArray, displayID);
                            }
                            if (StringArray.StArray == null) StringArray.StArray = new List<StrArray>();
                            StringArray.StArray.Add(strArray);
                        }),
                        });
                    }
                    break;
                default:
                    base.Parse(lowercasetoken, stf);
                    // Jindrich
                    if (CruiseControl != null)
                        CruiseControl.Parse(lowercasetoken, stf);
                    if (MultiPositionController != null)
                        MultiPositionController.Parse(lowercasetoken, stf);
                    break;
            }
        }

        /// <summary>
        /// This initializer is called when we are making a new copy of a car already
        /// loaded in memory.  We use this one to speed up loading by eliminating the
        /// need to parse the wag file multiple times.
        /// </summary>
        public override void Copy(MSTSWagon copy)
        {
            base.Copy(copy);  // each derived level initializes its own variables

            MSTSLocomotive locoCopy = (MSTSLocomotive)copy;
            CabSoundFileName = locoCopy.CabSoundFileName;
            CVFFileName = locoCopy.CVFFileName;
            CabViewList = locoCopy.CabViewList;
            CabView3D = locoCopy.CabView3D;
            MaxPowerW = locoCopy.MaxPowerW;
            MaxForceN = locoCopy.MaxForceN;
            MaxCurrentA = locoCopy.MaxCurrentA;
            MaxSpeedMpS = locoCopy.MaxSpeedMpS;
            UnloadingSpeedMpS = locoCopy.UnloadingSpeedMpS;
            EngineType = locoCopy.EngineType;
            TractiveForceCurves = locoCopy.TractiveForceCurves;
            MaxContinuousForceN = locoCopy.MaxContinuousForceN;
            ExtendedExcitationCurrent = locoCopy.ExtendedExcitationCurrent;
            SpeedOfMaxContinuousForceMpS = locoCopy.SpeedOfMaxContinuousForceMpS;
            MSTSSpeedOfMaxContinuousForceMpS = locoCopy.MSTSSpeedOfMaxContinuousForceMpS;
            ContinuousForceTimeFactor = locoCopy.ContinuousForceTimeFactor;
            DynamicBrakeForceCurves = locoCopy.DynamicBrakeForceCurves;
            DynamicBrakeAutoBailOff = locoCopy.DynamicBrakeAutoBailOff;
            CombinedControlType = locoCopy.CombinedControlType;
            CombinedControlSplitPosition = locoCopy.CombinedControlSplitPosition;
            DynamicBrakeDelayS = locoCopy.DynamicBrakeDelayS;
            MaxDynamicBrakeForceN = locoCopy.MaxDynamicBrakeForceN;
            HasSmoothStruc = locoCopy.HasSmoothStruc;
            LocoNumDrvAxles = locoCopy.LocoNumDrvAxles;
            MSTSLocoNumDrvWheels = locoCopy.MSTSLocoNumDrvWheels;
            AntiSlip = locoCopy.AntiSlip;
            VacuumPumpFitted = locoCopy.VacuumPumpFitted;
            FastVacuumExhausterFitted = locoCopy.FastVacuumExhausterFitted;
            DrvWheelWeightKg = locoCopy.DrvWheelWeightKg;
            InitialDrvWheelWeightKg = locoCopy.InitialDrvWheelWeightKg;
            SanderSpeedEffectUpToMpS = locoCopy.SanderSpeedEffectUpToMpS;
            SanderSpeedOfMpS = locoCopy.SanderSpeedOfMpS;
            MaxTrackSandBoxCapacityL = locoCopy.MaxTrackSandBoxCapacityL;
            TrackSanderSandConsumptionLpS = locoCopy.TrackSanderSandConsumptionLpS;
            TrackSanderAirComsumptionLpS = locoCopy.TrackSanderAirComsumptionLpS;
            PowerOnDelayS = locoCopy.PowerOnDelayS;
            DoesHornTriggerBell = locoCopy.DoesHornTriggerBell;
            MaxSteamHeatPressurePSI = locoCopy.MaxSteamHeatPressurePSI;
            VacuumPumpResistanceN = locoCopy.VacuumPumpResistanceN;
            VacuumBrakesMainResVolumeM3 = locoCopy.VacuumBrakesMainResVolumeM3;
            VacuumBrakesMainResMaxVacuumPSIAorInHg = locoCopy.VacuumBrakesMainResMaxVacuumPSIAorInHg;
            VacuumBrakesExhausterRestartVacuumPSIAorInHg = locoCopy.VacuumBrakesExhausterRestartVacuumPSIAorInHg;
            VacuumBrakesMainResChargingRatePSIAorInHgpS = locoCopy.VacuumBrakesMainResChargingRatePSIAorInHgpS;

            EmergencyCausesPowerDown = locoCopy.EmergencyCausesPowerDown;
            EmergencyCausesThrottleDown = locoCopy.EmergencyCausesThrottleDown;
            EmergencyEngagesHorn = locoCopy.EmergencyEngagesHorn;

            WheelslipCausesThrottleDown = locoCopy.WheelslipCausesThrottleDown;

            CompressorRestartPressurePSI = locoCopy.CompressorRestartPressurePSI;
            TrainBrakePipeLeakPSIorInHgpS = locoCopy.TrainBrakePipeLeakPSIorInHgpS;
            MaxMainResPressurePSI = locoCopy.MaxMainResPressurePSI;
            MainResPressurePSI = MaxMainResPressurePSI;
            MainResVolumeM3 = locoCopy.MainResVolumeM3;
            MainResChargingRatePSIpS = locoCopy.MainResChargingRatePSIpS;
            BrakePipeDischargeTimeFactor = locoCopy.BrakePipeDischargeTimeFactor;

            DynamicBrakeBlended = locoCopy.DynamicBrakeBlended;
            DynamicBrakeBlendingEnabled = locoCopy.DynamicBrakeBlendingEnabled;
            airPipeSystem = locoCopy.airPipeSystem;
            DynamicBrakeCommandStartTime = locoCopy.DynamicBrakeCommandStartTime;
            DynamicBrakeBlendingOverride = locoCopy.DynamicBrakeBlendingOverride;
            DynamicBrakeBlendingForceMatch = locoCopy.DynamicBrakeBlendingForceMatch;

            MainPressureUnit = locoCopy.MainPressureUnit;
            BrakeSystemPressureUnits = locoCopy.BrakeSystemPressureUnits;
            IsDriveable = copy.IsDriveable;
            //ThrottleController = MSTSEngineController.Copy(locoCopy.ThrottleController);
            ThrottleController = (MSTSNotchController)locoCopy.ThrottleController.Clone();
            SteamHeatController = (MSTSNotchController)locoCopy.SteamHeatController.Clone();
            TrainBrakeController = locoCopy.TrainBrakeController.Clone(this);
            EngineBrakeController = locoCopy.EngineBrakeController != null ? locoCopy.EngineBrakeController.Clone(this) : null;
            BrakemanBrakeController = locoCopy.BrakemanBrakeController != null ? locoCopy.BrakemanBrakeController.Clone(this) : null;
            DynamicBrakeController = locoCopy.DynamicBrakeController != null ? (MSTSNotchController)locoCopy.DynamicBrakeController.Clone() : null;
            TrainControlSystem.Copy(locoCopy.TrainControlSystem);
            LocomotiveName = locoCopy.LocomotiveName;
            MaxVaccuumMaxPressurePSI = locoCopy.MaxVaccuumMaxPressurePSI;
            VacuumBrakeEQFitted = locoCopy.VacuumBrakeEQFitted;
            TrainBrakeFitted = locoCopy.TrainBrakeFitted;
            EngineBrakeFitted = locoCopy.EngineBrakeFitted;
            BrakemanBrakeFitted = locoCopy.BrakemanBrakeFitted;
            SteamEngineBrakeFitted = locoCopy.SteamEngineBrakeFitted;
            HasWaterScoop = locoCopy.HasWaterScoop;
            WaterScoopFillElevationM = locoCopy.WaterScoopFillElevationM;
            WaterScoopDepthM = locoCopy.WaterScoopDepthM;
            WaterScoopWidthM = locoCopy.WaterScoopWidthM;
            MoveParamsToAxle();

            // Icik
            AdhesionEfficiencyKoef = locoCopy.AdhesionEfficiencyKoef;
            MultiSystemEngine = locoCopy.MultiSystemEngine;
            MultiSystemEnginePlayer = locoCopy.MultiSystemEnginePlayer;
            MaxPowerWAC = locoCopy.MaxPowerWAC;
            MaxPowerWDC = locoCopy.MaxPowerWDC;
            MaxCurrentPower = locoCopy.MaxCurrentPower;
            MaxCurrentBrake = locoCopy.MaxCurrentBrake;
            SlipSpeedCritical = locoCopy.SlipSpeedCritical;
            EDBIndependent = locoCopy.EDBIndependent;
            DoesPowerLossResetControls = locoCopy.DoesPowerLossResetControls;
            DoesPowerLossResetControls2 = locoCopy.DoesPowerLossResetControls2;
            EngineBrakeEngageEDB = locoCopy.EngineBrakeEngageEDB;
            SwitchingVoltageMode = locoCopy.SwitchingVoltageMode;
            PowerReductionByAuxEquipment = locoCopy.PowerReductionByAuxEquipment;
            AirBrakesIsCompressorElectricOrMechanical = locoCopy.AirBrakesIsCompressorElectricOrMechanical;
            AirBrakesAirCompressorWattage = locoCopy.AirBrakesAirCompressorWattage;
            CentralHandlingDoors = locoCopy.CentralHandlingDoors;
            VoltageFilter = locoCopy.VoltageFilter;
            LocomotivePowerVoltage = locoCopy.LocomotivePowerVoltage;
            TractiveForceCurvesAC = locoCopy.TractiveForceCurvesAC;
            TractiveForceCurvesDC = locoCopy.TractiveForceCurvesDC;
            DynamicBrakeForceCurvesAC = locoCopy.DynamicBrakeForceCurvesAC;
            DynamicBrakeForceCurvesDC = locoCopy.DynamicBrakeForceCurvesDC;
            MainResChargingRatePSIpS_2 = locoCopy.MainResChargingRatePSIpS_2;
            AuxResChargingRatePSIpS = locoCopy.AuxResChargingRatePSIpS;
            MaxAuxResPressurePSI = locoCopy.MaxAuxResPressurePSI;
            AuxResVolumeM3 = locoCopy.AuxResVolumeM3;
            AuxCompressorRestartPressurePSI = locoCopy.AuxCompressorRestartPressurePSI;
            MinAuxPressurePantoPSI = locoCopy.MinAuxPressurePantoPSI;
            MinAuxPressureHVPSI = locoCopy.MinAuxPressureHVPSI;
            PantoConsumptionVolumeM3 = locoCopy.PantoConsumptionVolumeM3;
            HVConsumptionVolumeM3_On = locoCopy.HVConsumptionVolumeM3_On;
            HVConsumptionVolumeM3_Off = locoCopy.HVConsumptionVolumeM3_Off;
            HVElectric = locoCopy.HVElectric;
            AuxResPipeLeak = locoCopy.AuxResPipeLeak;
            MaxMainResOverPressurePSI = locoCopy.MaxMainResOverPressurePSI;
            MaxAuxResOverPressurePSI = locoCopy.MaxAuxResOverPressurePSI;
            HeatingMaxCurrentA = locoCopy.HeatingMaxCurrentA;
            DieselStartDelay = locoCopy.DieselStartDelay;
            MUCableEquipment = locoCopy.MUCableEquipment;
            DoorSwitch = locoCopy.DoorSwitch;
            PrevDoorSwitch = locoCopy.PrevDoorSwitch;
            LapActive = locoCopy.LapActive;
            PantoCanHVOffSpeedKpH = locoCopy.PantoCanHVOffSpeedKpH;
            CarIsPlayerLocoSet = locoCopy.CarIsPlayerLocoSet;
            BreakPowerButton_Activated = locoCopy.BreakPowerButton_Activated;
            BreakEDBButton_Activated = locoCopy.BreakEDBButton_Activated;
            BrakeSystem.MCP_TrainBrake = locoCopy.BrakeSystem.MCP_TrainBrake;
            CurrentForceCurves = locoCopy.CurrentForceCurves;            
            CabFrontSoundFileName = locoCopy.CabFrontSoundFileName;
            CabRearSoundFileName = locoCopy.CabRearSoundFileName;
            CabStationForBatterySwitchOn = locoCopy.CabStationForBatterySwitchOn;
            TractiveForceStepControllerCurves = locoCopy.TractiveForceStepControllerCurves;
            TractiveForceStepControllerCurvesAC = locoCopy.TractiveForceStepControllerCurvesAC;
            TractiveForceStepControllerCurvesDC = locoCopy.TractiveForceStepControllerCurvesDC;
            CurrentForceStep1Curves = locoCopy.CurrentForceStep1Curves;
            CurrentForceStep2Curves = locoCopy.CurrentForceStep2Curves;
            CurrentBrakeForce1Curves = locoCopy.CurrentBrakeForce1Curves;
            CurrentBrakeForce2Curves = locoCopy.CurrentBrakeForce2Curves;
            Current_CabHeating = locoCopy.Current_CabHeating;
            Current_TMCoolings = locoCopy.Current_TMCoolings;
            Current_OthersCoolings = locoCopy.Current_OthersCoolings;
            Current_Compressor1 = locoCopy.Current_Compressor1;
            Current_Compressor2 = locoCopy.Current_Compressor2;
            Current_AuxCompressor = locoCopy.Current_AuxCompressor;
            MaxTMTemperatureDegC = locoCopy.MaxTMTemperatureDegC;
            IdleTMTemperatureDegC = locoCopy.IdleTMTemperatureDegC;
            AirTMCoolingPower = locoCopy.AirTMCoolingPower;
            TMTempTimeConstantSec = locoCopy.TMTempTimeConstantSec;
            MaxDRTemperatureDegC = locoCopy.MaxDRTemperatureDegC;
            IdleDRTemperatureDegC = locoCopy.IdleDRTemperatureDegC;
            AirDRCoolingPower = locoCopy.AirDRCoolingPower;
            DRTempTimeConstantSec = locoCopy.DRTempTimeConstantSec;
            CoefStepControllerCurves = locoCopy.CoefStepControllerCurves;
            for (int i = 0; i < 6; i++)            
                RelayDelay[i] = locoCopy.RelayDelay[i];                            

            // Jindrich
            UsingForceHandle = locoCopy.UsingForceHandle;
            Battery = locoCopy.Battery;
            ThrottleFullRangeIncreaseTimeSeconds = locoCopy.ThrottleFullRangeIncreaseTimeSeconds;
            ThrottleFullRangeDecreaseTimeSeconds = locoCopy.ThrottleFullRangeDecreaseTimeSeconds;
            ThrottleFullRangeDecreaseTimeSecondsFast = locoCopy.ThrottleFullRangeDecreaseTimeSecondsFast;
            DynamicBrakeFullRangeIncreaseTimeSeconds = locoCopy.DynamicBrakeFullRangeIncreaseTimeSeconds;
            DynamicBrakeFullRangeDecreaseTimeSeconds = locoCopy.DynamicBrakeFullRangeDecreaseTimeSeconds;
            AcceleratingToBrakingChangeTime = locoCopy.AcceleratingToBrakingChangeTime;
            MaxControllerVolts = locoCopy.MaxControllerVolts;
            DisableRestrictedSpeedWhenManualDriving = locoCopy.DisableRestrictedSpeedWhenManualDriving;
            AutomaticParkingBrake = locoCopy.AutomaticParkingBrake;
            AutomaticParkingBrakeEngageSpeedKpH = locoCopy.AutomaticParkingBrakeEngageSpeedKpH;
            ParkingBrakeTargetPressurePSI = locoCopy.ParkingBrakeTargetPressurePSI;
            SplashScreenWillBeDisplayed = locoCopy.SplashScreenWillBeDisplayed;
            SplashScreenMinDuration = locoCopy.SplashScreenMinDuration;
            SplashScreenMaxDuration = locoCopy.SplashScreenMaxDuration;
            AntiWheelSpinEquipped = locoCopy.AntiWheelSpinEquipped;
            AntiWheelSpinSpeedDiffThreshold = locoCopy.AntiWheelSpinSpeedDiffThreshold;
            DynamicBrakeMaxForceAtSelectorStep = locoCopy.DynamicBrakeMaxForceAtSelectorStep;
            SelectedMaxAccelerationStep[LocoStation] = locoCopy.SelectedMaxAccelerationStep[LocoStation];

            if (locoCopy.CruiseControl != null)
                CruiseControl = locoCopy.CruiseControl;
            if (locoCopy.Mirel != null)
                Mirel = locoCopy.Mirel;

            if (locoCopy.MultiPositionControllers != null)
                MultiPositionControllers = locoCopy.MultiPositionControllers;
            if (locoCopy.MultiPositionController != null)
                MultiPositionController = locoCopy.MultiPositionController;
        }

        public void ActiveStationIncrease()
        {
            if (!Mirel.Equipped) return;
            SignalEvent(Event.ActiveCabSelectorChange);
            if (ActiveStation == DriverStation.None && !UsingRearCab)
                ActiveStation = DriverStation.Station1;
            else if (ActiveStation == DriverStation.None && UsingRearCab)
                ActiveStation = DriverStation.Station2;

            switch (ActiveStation)
            {
                case DriverStation.None:
                    {
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("No active cab selected"));
                        PowerKey = false;
                        break;
                    }
                case DriverStation.Station1:
                    {
                        PowerKey = true;
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("Cab 1 selected"));
                        break;
                    }
                case DriverStation.Station2:
                    {
                        PowerKey = true;
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("Cab 2 selected"));
                        break;
                    }
            }
        }
        public void ActiveStationDecrease()
        {
            if (!Mirel.Equipped) return;
            SignalEvent(Event.ActiveCabSelectorChange);
            ActiveStation = DriverStation.None;

            switch (ActiveStation)
            {
                case DriverStation.None:
                    {
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("No active cab selected"));
                        PowerKey = false;
                        break;
                    }
                case DriverStation.Station1:
                    {
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("Cab 1 selected"));
                        PowerKey = true;
                        break;
                    }
                case DriverStation.Station2:
                    {
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("Cab 2 selected"));
                        PowerKey = true;
                        break;
                    }
            }
        }

        /// <summary>
        /// We are moving parameters from locomotive to axle. 
        /// </summary>
        public void MoveParamsToAxle()
        {
            if (LocomotiveAxle != null)
            {
                LocomotiveAxle.SlipWarningTresholdPercent = SlipWarningThresholdPercent;
                LocomotiveAxle.AdhesionK = AdhesionK;
                LocomotiveAxle.CurtiusKnifflerA = Curtius_KnifflerA;
                LocomotiveAxle.CurtiusKnifflerB = Curtius_KnifflerB;
                LocomotiveAxle.CurtiusKnifflerC = Curtius_KnifflerC;
            }
        }

        /// <summary>
        /// We are saving the game.  Save anything that we'll need to restore the 
        /// status later.
        /// </summary>
        public override void Save(BinaryWriter outf)
        {
            // we won't save the horn state
            outf.Write(Bell);
            outf.Write(Sander);
            outf.Write(VacuumExhausterPressed);
            outf.Write(Wiper);            
            outf.Write(OdometerResetPositionM);
            outf.Write(OdometerCountingUp);
            outf.Write(OdometerCountingForwards);
            outf.Write(OdometerVisible);
            outf.Write(MainResPressurePSI);
            outf.Write(CompressorIsOn);
            outf.Write(VacuumMainResVacuumPSIAorInHg);
            outf.Write(VacuumExhausterIsOn);
            outf.Write(TrainBrakePipeLeakPSIorInHgpS);
            outf.Write(AverageForceN);
            outf.Write(LocomotiveAxle.AxleSpeedMpS);
            outf.Write(CabLightOn[1]);
            outf.Write(CabLightOn[2]);
            outf.Write(CabFloodLightOn[1]);
            outf.Write(CabFloodLightOn[2]);
            outf.Write(wasCabLightSetOn[1]);
            outf.Write(wasCabLightSetOn[2]);
            outf.Write(UsingRearCab);
            outf.Write(CalculatedCarHeaterSteamUsageLBpS);
            ControllerFactory.Save(ThrottleController, outf);
            ControllerFactory.Save(TrainBrakeController, outf);
            ControllerFactory.Save(EngineBrakeController, outf);
            ControllerFactory.Save(BrakemanBrakeController, outf);
            ControllerFactory.Save(DynamicBrakeController, outf);
            ControllerFactory.Save(SteamHeatController, outf);
            outf.Write(AcceptMUSignals);
            outf.Write(PowerReduction);
            outf.Write(Battery);
            outf.Write(PowerKey);
            outf.Write(ScoopIsBroken);
            outf.Write(IsWaterScoopDown);
            outf.Write(CurrentTrackSandBoxCapacityL);
            outf.Write(SpeedMpS);
            outf.Write(_SpeedMpS);
            outf.Write(WheelSpeedMpS);
            outf.Write(AbsSpeedMpS);
            outf.Write(AbsTractionSpeedMpS);
            outf.Write(AbsWheelSpeedMpS);            
            outf.Write((int)SelectedPowerSystem);
            outf.Write((int)SelectingPowerSystem);
            
            // Icik
            #region Icik            
            outf.Write(HVOffStatusBrakeCyl);
            outf.Write(HVOffStatusBrakePipe);
            outf.Write(AuxCompressorMode_OffOn);            
            outf.Write(EngineBrakeEngageEDB);            
            outf.Write(SwitchingVoltageMode_OffAC);
            outf.Write(SwitchingVoltageMode_OffDC);
            outf.Write(SwitchingVoltageMode);
            outf.Write(TElevatedConsumption);
            outf.Write(Compressor2IsOn);
            outf.Write(AuxCompressorIsOn);
            outf.Write(AuxResPressurePSI);                        
            outf.Write(MainResOverPressure);
            outf.Write(AuxResOverPressure);            
            outf.Write(BreakPowerButton_Activated);
            outf.Write(MultiSystemEngine);
            outf.Write(LocomotivePowerVoltage);            
            outf.Write(DieselDirectionController_In);
            outf.Write(DieselDirectionController_Out);
            outf.Write(DieselDirectionControllerInOut);
            outf.Write(DieselMotorDefected);
            outf.Write(DieselMotorPowerLost);
            outf.Write(DieselLocoTempReady);            
            outf.Write(PrevDoorSwitch);
            outf.Write(LapActive[1]);
            outf.Write(LapActive[2]);
            outf.Write(DirectionButtonPosition);
            outf.Write(CarIsPlayerLocoSet);
            outf.Write(BreakEDBButton_Activated);                                    
            outf.Write(RainWindowPosition);
            outf.Write(WipersWindowPosition);
            outf.Write(WiperStatusChange);            
            outf.Write(HelperLocoDontPush);
            outf.Write(HelperLocoPush);
            outf.Write(HelperLocoFollow);
            outf.Write(HelperSpeedPush);
            outf.Write(HelperPushStart);
            outf.Write(HelperOptionsOpened);
            outf.Write(MirerControllerPosition);
            outf.Write(MirerControllerValue);
            outf.Write(EngineBrakeValue[1]);
            outf.Write(EngineBrakeValue[2]);
            outf.Write(CompressorMode_OffAuto[1]);
            outf.Write(CompressorMode_OffAuto[2]);
            outf.Write(CompressorMode2_OffAuto[1]);
            outf.Write(CompressorMode2_OffAuto[2]);
            outf.Write(Compressor_I_HandMode[1]);
            outf.Write(Compressor_I_HandMode[2]);
            outf.Write(Compressor_II_HandMode[1]);
            outf.Write(Compressor_II_HandMode[2]);
            outf.Write(Heating_OffOn[1]);
            outf.Write(Heating_OffOn[2]);
            outf.Write(CompressorSwitch[1]);
            outf.Write(CompressorSwitch[2]);
            outf.Write(CompressorSwitch2[1]);
            outf.Write(CompressorSwitch2[2]);
            outf.Write(Pantograph3Switch[1]);
            outf.Write(Pantograph3Switch[2]);
            outf.Write(Pantograph4Switch[1]);
            outf.Write(Pantograph4Switch[2]);
            outf.Write(HV3Switch[1]);
            outf.Write(HV3Switch[2]);
            outf.Write(HV4Switch[1]);
            outf.Write(HV4Switch[2]);
            outf.Write(HV5Switch[1]);
            outf.Write(HV5Switch[2]);
            outf.Write(DieselDirectionControllerPosition[1]);
            outf.Write(DieselDirectionControllerPosition[2]);
            outf.Write(DieselDirectionController2Position[1]);
            outf.Write(DieselDirectionController2Position[2]);
            outf.Write(prevDieselDirectionControllerPosition[1]);
            outf.Write(prevDieselDirectionControllerPosition[2]);
            outf.Write(prevDieselDirectionController2Position[1]);
            outf.Write(prevDieselDirectionController2Position[2]);
            outf.Write(DoorSwitch[1]);
            outf.Write(DoorSwitch[2]);
            outf.Write(AripotControllerValue[1]);
            outf.Write(AripotControllerValue[2]);
            outf.Write(AripotControllerPreValue[1]);
            outf.Write(AripotControllerPreValue[2]);
            outf.Write(AripotControllerCanUseThrottle[1]);
            outf.Write(AripotControllerCanUseThrottle[2]);
            outf.Write(SeasonSwitchPosition[1]);
            outf.Write(SeasonSwitchPosition[2]);
            outf.Write(DirectionPosition[1]);
            outf.Write(DirectionPosition[2]);
            outf.Write(HeadLightPosition[1]);
            outf.Write(HeadLightPosition[2]);
            outf.Write(LocoWiper[1]);
            outf.Write(LocoWiper[2]);
            outf.Write(LastStateHV3[1]);
            outf.Write(LastStateHV3[2]);
            outf.Write(LastStateHV4[1]);
            outf.Write(LastStateHV4[2]);
            outf.Write(LastStateHV5[1]);
            outf.Write(LastStateHV5[2]);
            outf.Write(PrePantoStatus[1]);
            outf.Write(PrePantoStatus[2]);
            outf.Write(StationIsActivated[1]);
            outf.Write(StationIsActivated[2]);
            outf.Write(LocoStation);
            outf.Write(TrainBrakeValue[1]);
            outf.Write(TrainBrakeValue[2]);
            outf.Write(TrainBrakeValueFQR);
            outf.Write(TrainBrakeValueO);
            outf.Write(TrainBrakeValueL);
            outf.Write(TrainBrakeValueR);
            outf.Write(TrainBrakeValueN);
            outf.Write(TrainBrakeValueA);
            outf.Write(TrainBrakeValueE);
            outf.Write(TrainBrakeValueEPA);
            outf.Write(TrainBrakeValueAGA);
            outf.Write(TrainBrakeValueSA);
            outf.Write(TrainBrakeValueRUN);
            outf.Write(TogglePowerKeyCycle);
            outf.Write(prevEngineBrakeValue[1]);
            outf.Write(prevEngineBrakeValue[2]);
            outf.Write(LightsFrameUpdate);
            outf.Write(BrakeSystem.PowerForWagon);
            outf.Write(TMTemperature);
            outf.Write(CabRadio[1]);
            outf.Write(CabRadio[2]);
            outf.Write(CabRadioTriggerOn);
            outf.Write(LapButtonEnable);
            outf.Write(CommandCylinderPosition[1]);
            outf.Write(CommandCylinderPosition[2]);
            outf.Write(preCommandCylinderPosition[1]);
            outf.Write(preCommandCylinderPosition[2]);
            outf.Write(CommandCylinderThrottlePosition[1]);
            outf.Write(CommandCylinderThrottlePosition[2]);
            outf.Write(CircularSwitchWhitePosition[1]);
            outf.Write(CircularSwitchWhitePosition[2]);
            outf.Write(CircularSwitchRedPosition[1]);
            outf.Write(CircularSwitchRedPosition[2]);
            outf.Write(FirstCabLoaded);
            outf.Write(DRTemperature);
            outf.Write(MirelRSControllerPosition[1]);
            outf.Write(MirelRSControllerPosition[2]);
            outf.Write(MirelRSControllerThrottleValue);
            outf.Write(preMirelRSControllerThrottleValue);
            outf.Write(MirelRSControllerEDBValue);
            outf.Write(DirectionControllerMirelRSPositionSh);
            outf.Write(MirelRSDirectionControllerPosition[1]);
            outf.Write(MirelRSDirectionControllerPosition[2]);
            #endregion

            base.Save(outf);

            TrainControlSystem.Save(outf);
            LocomotiveAxle.Save(outf);
            if (CruiseControl != null)
                CruiseControl.Save(outf);
            if (Mirel != null)
                Mirel.Save(outf);
            outf.Write((int)ActiveStation);
            if (extendedPhysics != null)
                extendedPhysics.Save(outf);
            Mirel.Save(outf);
            outf.Write(ControllerVolts);
        }

        /// <summary>
        /// We are restoring a saved game.  The TrainCar class has already
        /// been initialized.   Restore the game state.
        /// </summary>
        protected bool wasRestored = false;
        public override void Restore(BinaryReader inf)
        {
            wasRestored = true;
            if (inf.ReadBoolean()) SignalEvent(Event.BellOn);
            if (inf.ReadBoolean()) SignalEvent(Event.SanderOn);
            if (inf.ReadBoolean()) SignalEvent(Event.VacuumExhausterOn);
            if (inf.ReadBoolean()) SignalEvent(Event.WiperOn);
            OdometerResetPositionM = inf.ReadSingle();
            OdometerCountingUp = inf.ReadBoolean();
            OdometerCountingForwards = inf.ReadBoolean();
            OdometerVisible = inf.ReadBoolean();
            MainResPressurePSI = inf.ReadSingle();
            CompressorIsOn = inf.ReadBoolean();
            VacuumMainResVacuumPSIAorInHg = inf.ReadSingle();
            VacuumExhausterIsOn = inf.ReadBoolean();
            TrainBrakePipeLeakPSIorInHgpS = inf.ReadSingle();
            AverageForceN = inf.ReadSingle();
            LocomotiveAxle.Reset(Simulator.GameTime, inf.ReadSingle());
            CabLightOn[1] = inf.ReadBoolean();
            CabLightOn[2] = inf.ReadBoolean();
            CabFloodLightOn[1] = inf.ReadBoolean();
            CabFloodLightOn[2] = inf.ReadBoolean();
            wasCabLightSetOn[1] = inf.ReadBoolean();
            wasCabLightSetOn[2] = inf.ReadBoolean();
            UsingRearCab = inf.ReadBoolean();
            CalculatedCarHeaterSteamUsageLBpS = inf.ReadSingle();
            ControllerFactory.Restore(ThrottleController, inf);
            ControllerFactory.Restore(TrainBrakeController, inf);
            ControllerFactory.Restore(EngineBrakeController, inf);
            ControllerFactory.Restore(BrakemanBrakeController, inf);
            ControllerFactory.Restore(DynamicBrakeController, inf);
            ControllerFactory.Restore(SteamHeatController, inf);
            AcceptMUSignals = inf.ReadBoolean();
            PowerReduction = inf.ReadSingle();
            Battery = inf.ReadBoolean();
            PowerKey = inf.ReadBoolean();
            ScoopIsBroken = inf.ReadBoolean();
            IsWaterScoopDown = inf.ReadBoolean();
            CurrentTrackSandBoxCapacityL = inf.ReadSingle();
            AdhesionFilter.Reset(0.5f);
            SpeedMpS = inf.ReadSingle();
            _SpeedMpS = inf.ReadSingle();
            WheelSpeedMpS = inf.ReadSingle();
            AbsSpeedMpS = inf.ReadSingle();
            AbsTractionSpeedMpS = inf.ReadSingle();
            AbsWheelSpeedMpS = inf.ReadSingle();            
            int fSelectedPowerSystem = inf.ReadInt32();
            SelectedPowerSystem = (PowerSystem)fSelectedPowerSystem;
            int fSelectingPowerSystem = inf.ReadInt32();
            SelectingPowerSystem = (PowerSystem)fSelectingPowerSystem;

            // Icik
            #region Icik            
            HVOffStatusBrakeCyl = inf.ReadBoolean();
            HVOffStatusBrakePipe = inf.ReadBoolean();
            AuxCompressorMode_OffOn = inf.ReadBoolean();            
            EngineBrakeEngageEDB = inf.ReadBoolean();            
            SwitchingVoltageMode_OffAC = inf.ReadBoolean();
            SwitchingVoltageMode_OffDC = inf.ReadBoolean();
            SwitchingVoltageMode = inf.ReadInt32();
            TElevatedConsumption = inf.ReadSingle();
            Compressor2IsOn = inf.ReadBoolean();
            AuxCompressorIsOn = inf.ReadBoolean();
            AuxResPressurePSI = inf.ReadSingle();                        
            MainResOverPressure = inf.ReadBoolean();
            AuxResOverPressure = inf.ReadBoolean();                        
            BreakPowerButton_Activated = inf.ReadBoolean();
            MultiSystemEngine = inf.ReadBoolean();
            LocomotivePowerVoltage = inf.ReadSingle();            
            DieselDirectionController_In = inf.ReadBoolean();
            DieselDirectionController_Out = inf.ReadBoolean();
            DieselDirectionControllerInOut = inf.ReadBoolean();
            DieselMotorDefected = inf.ReadBoolean();
            DieselMotorPowerLost = inf.ReadBoolean();
            DieselLocoTempReady = inf.ReadBoolean();            
            PrevDoorSwitch = inf.ReadSingle();
            LapActive[1] = inf.ReadBoolean();
            LapActive[2] = inf.ReadBoolean();
            DirectionButtonPosition = inf.ReadInt32();
            CarIsPlayerLocoSet = inf.ReadBoolean();
            BreakEDBButton_Activated = inf.ReadBoolean();                                    
            RainWindowPosition = inf.ReadInt32();
            WipersWindowPosition = inf.ReadInt32();
            WiperStatusChange = inf.ReadBoolean();            
            HelperLocoDontPush = inf.ReadBoolean();
            HelperLocoPush = inf.ReadBoolean();
            HelperLocoFollow = inf.ReadBoolean();
            HelperSpeedPush = inf.ReadInt32();
            HelperPushStart = inf.ReadBoolean();
            HelperOptionsOpened = inf.ReadBoolean();
            MirerControllerPosition = inf.ReadInt32();
            MirerControllerValue = inf.ReadInt32();
            EngineBrakeValue[1] = inf.ReadSingle();
            EngineBrakeValue[2] = inf.ReadSingle();
            CompressorMode_OffAuto[1] = inf.ReadBoolean();
            CompressorMode_OffAuto[2] = inf.ReadBoolean();
            CompressorMode2_OffAuto[1] = inf.ReadBoolean();
            CompressorMode2_OffAuto[2] = inf.ReadBoolean();
            Compressor_I_HandMode[1] = inf.ReadBoolean();
            Compressor_I_HandMode[2] = inf.ReadBoolean();
            Compressor_II_HandMode[1] = inf.ReadBoolean();
            Compressor_II_HandMode[2] = inf.ReadBoolean();
            Heating_OffOn[1] = inf.ReadBoolean();
            Heating_OffOn[2] = inf.ReadBoolean();
            CompressorSwitch[1] = inf.ReadInt32();
            CompressorSwitch[2] = inf.ReadInt32();
            CompressorSwitch2[1] = inf.ReadInt32();
            CompressorSwitch2[2] = inf.ReadInt32();
            Pantograph3Switch[1] = inf.ReadInt32();
            Pantograph3Switch[2] = inf.ReadInt32();
            Pantograph4Switch[1] = inf.ReadInt32();
            Pantograph4Switch[2] = inf.ReadInt32();
            HV3Switch[1] = inf.ReadInt32();
            HV3Switch[2] = inf.ReadInt32();
            HV4Switch[1] = inf.ReadInt32();
            HV4Switch[2] = inf.ReadInt32();
            HV5Switch[1] = inf.ReadInt32();
            HV5Switch[2] = inf.ReadInt32();
            DieselDirectionControllerPosition[1] = inf.ReadInt32();
            DieselDirectionControllerPosition[2] = inf.ReadInt32();
            DieselDirectionController2Position[1] = inf.ReadInt32();
            DieselDirectionController2Position[2] = inf.ReadInt32();
            prevDieselDirectionControllerPosition[1] = inf.ReadInt32();
            prevDieselDirectionControllerPosition[2] = inf.ReadInt32();
            prevDieselDirectionController2Position[1] = inf.ReadInt32();
            prevDieselDirectionController2Position[2] = inf.ReadInt32();
            DoorSwitch[1] = inf.ReadInt32();
            DoorSwitch[2] = inf.ReadInt32();
            AripotControllerValue[1] = inf.ReadSingle();
            AripotControllerValue[2] = inf.ReadSingle();
            AripotControllerPreValue[1] = inf.ReadSingle();
            AripotControllerPreValue[2] = inf.ReadSingle();
            AripotControllerCanUseThrottle[1] = inf.ReadBoolean();
            AripotControllerCanUseThrottle[2] = inf.ReadBoolean();
            SeasonSwitchPosition[1] = inf.ReadBoolean();
            SeasonSwitchPosition[2] = inf.ReadBoolean();
            DirectionPosition[1] = inf.ReadInt32();
            DirectionPosition[2] = inf.ReadInt32();
            HeadLightPosition[1] = inf.ReadInt32();
            HeadLightPosition[2] = inf.ReadInt32();
            LocoWiper[1] = inf.ReadBoolean();
            LocoWiper[2] = inf.ReadBoolean();
            LastStateHV3[1] = inf.ReadInt32();
            LastStateHV3[2] = inf.ReadInt32();
            LastStateHV4[1] = inf.ReadInt32();
            LastStateHV4[2] = inf.ReadInt32();
            LastStateHV5[1] = inf.ReadInt32();
            LastStateHV5[2] = inf.ReadInt32();
            PrePantoStatus[1] = inf.ReadInt32();
            PrePantoStatus[2] = inf.ReadInt32();
            StationIsActivated[1] = inf.ReadBoolean();
            StationIsActivated[2] = inf.ReadBoolean();
            LocoStation = inf.ReadInt32();
            TrainBrakeValue[1] = inf.ReadSingle();
            TrainBrakeValue[2] = inf.ReadSingle();            
            TrainBrakeValueFQR = inf.ReadSingle(); 
            TrainBrakeValueO = inf.ReadSingle(); 
            TrainBrakeValueL = inf.ReadSingle();
            TrainBrakeValueR = inf.ReadSingle();
            TrainBrakeValueN = inf.ReadSingle();
            TrainBrakeValueA = inf.ReadSingle();
            TrainBrakeValueE = inf.ReadSingle();
            TrainBrakeValueEPA = inf.ReadSingle();
            TrainBrakeValueAGA = inf.ReadSingle();
            TrainBrakeValueSA = inf.ReadSingle();
            TrainBrakeValueRUN = inf.ReadSingle();
            TogglePowerKeyCycle = inf.ReadInt32();
            prevEngineBrakeValue[1] = inf.ReadSingle();
            prevEngineBrakeValue[2] = inf.ReadSingle();
            LightsFrameUpdate = inf.ReadInt32();
            BrakeSystem.PowerForWagon = inf.ReadBoolean();
            TMTemperature = inf.ReadSingle();
            CabRadio[1] = inf.ReadBoolean();
            CabRadio[2] = inf.ReadBoolean();
            CabRadioTriggerOn = inf.ReadBoolean();
            LapButtonEnable = inf.ReadBoolean();
            CommandCylinderPosition[1] = inf.ReadInt32();
            CommandCylinderPosition[2] = inf.ReadInt32();
            preCommandCylinderPosition[1] = inf.ReadInt32();
            preCommandCylinderPosition[2] = inf.ReadInt32();
            CommandCylinderThrottlePosition[1] = inf.ReadInt32();
            CommandCylinderThrottlePosition[2] = inf.ReadInt32();
            CircularSwitchWhitePosition[1] = inf.ReadInt32();
            CircularSwitchWhitePosition[2] = inf.ReadInt32();
            CircularSwitchRedPosition[1] = inf.ReadInt32();
            CircularSwitchRedPosition[2] = inf.ReadInt32();
            FirstCabLoaded = inf.ReadBoolean();
            DRTemperature = inf.ReadSingle();
            MirelRSControllerPosition[1] = inf.ReadInt32();
            MirelRSControllerPosition[2] = inf.ReadInt32();
            MirelRSControllerThrottleValue = inf.ReadSingle();
            preMirelRSControllerThrottleValue = inf.ReadSingle();
            MirelRSControllerEDBValue = inf.ReadSingle();
            DirectionControllerMirelRSPositionSh = inf.ReadBoolean();
            MirelRSDirectionControllerPosition[1] = inf.ReadInt32();
            MirelRSDirectionControllerPosition[2] = inf.ReadInt32();
            #endregion

            base.Restore(inf);

            TrainControlSystem.Restore(inf);
            LocomotiveAxle = new Axle(inf);

            // Jindrich
            if (CruiseControl != null)
                CruiseControl.Restore(inf);
            if (Mirel != null)
                Mirel.Restore(inf);
            int fActiveStation = inf.ReadInt32();
            ActiveStation = (DriverStation)fActiveStation;
            if (File.Exists(WagFilePath + ".ExtendedPhysics.xml"))
            {
                extendedPhysics = new ExtendedPhysics(this);
                extendedPhysics.Parse(WagFilePath + ".ExtendedPhysics.xml");
                extendedPhysics.Restore(inf);
            }
            Mirel.Restore(inf);
            ControllerVolts = inf.ReadSingle();
        }

        public bool IsLeadLocomotive()
        {
            return Train.LeadLocomotive == this;
        }

        protected void ParseCombData(string lowercasetoken, STFReader stf)
        {
            var throttle = false;
            var train = false;
            var dynamic = false;
            var independent = false;

            stf.MustMatch("(");
            var minValue = stf.ReadFloat(STFReader.UNITS.None, 0);
            var maxValue = stf.ReadFloat(STFReader.UNITS.None, 1);
            var split = stf.ReadFloat(STFReader.UNITS.None, 0.5f);
            var defaultValue = stf.ReadFloat(STFReader.UNITS.None, 0.5f);

            string s;
            while ((s = stf.ReadItem()) != ")")
            {
                throttle |= s == "throttle";
                train |= s == "train";
                dynamic |= s == "dynamic";
                independent |= s == "independent";
            }

            CombinedControlSplitPosition = (split - minValue) / (maxValue - minValue);

            if (throttle && dynamic && train)
                CombinedControlType = CombinedControl.ThrottleDynamicAir;
            else if (throttle && train)
                CombinedControlType = CombinedControl.ThrottleAir;
            else if (throttle && dynamic)
                CombinedControlType = CombinedControl.ThrottleDynamic;
            else if (dynamic && train)
                CombinedControlType = CombinedControl.DynamicAir;

            if (train && !TrainBrakeController.IsValid())
                TrainBrakeController = new ScriptedBrakeController(this);
            if (dynamic && !DynamicBrakeController.IsValid())
                DynamicBrakeController = new MSTSNotchController(0, 1, .05f);
            if (dynamic)
                DynamicBrake = true;
        }

        /// <summary>
        /// Sets controler settings from other engine for cab switch
        /// </summary>
        /// <param name="other"></param>
        public override void CopyControllerSettings(TrainCar other)
        {
            base.CopyControllerSettings(other);
            if (ThrottleController != null)
                ThrottleController.SetValue(other.ThrottlePercent / 100);
            if (DynamicBrakeController != null)
                DynamicBrakeController.SetValue(other.DynamicBrakePercent / 100);
            if (TrainBrakeController != null)
                TrainBrakeController.SetValue(((MSTSLocomotive)other).TrainBrakeController.CurrentValue);
            if (EngineBrakeController != null)
                EngineBrakeController.SetValue(0);
            if (BrakemanBrakeController != null)
                BrakemanBrakeController.SetValue(0);
        }

        public bool controlUpdated;
        public bool notificationReceived;        
        /// <summary>
        /// Called just after the InitializeFromWagFile
        /// </summary>
        public override void Initialize()
        {
            // Jindřich - napaječky a voltage markery
            Simulator.powerSupplyStations = new List<PowerSupplyStation>();
            SetUpPowerSupplyStations();
            Simulator.voltageChangeMarkers = new List<VoltageChangeMarker>();
            SetUpVoltageChangeMarkers();            

            if (MaxPowerWAC != 0)
                MaxPowerWBase = MaxPowerWAC;
            else
            if (MaxPowerWDC != 0)
                MaxPowerWBase = MaxPowerWDC;
            else
            if (MaxPowerW != 0)
                MaxPowerWBase = MaxPowerW;


            if (MaxTrackSandBoxCapacityL == 0) MaxTrackSandBoxCapacityL = 25; // Default 25l
            if (CurrentTrackSandBoxCapacityL == 0) CurrentTrackSandBoxCapacityL = MaxTrackSandBoxCapacityL;
            CurrentTrackSandBoxCapacityKG = (float)Math.Round(CurrentTrackSandBoxCapacityL * 1.4f, 2); // 1l = 1.4kg písku
            MassKG += CurrentTrackSandBoxCapacityKG;

            SetDefault_AuxCompressor();
            MainResChargingRatePSIpS0 = MainResChargingRatePSIpS;
            if (!Compressor_I && !Compressor_II)
                Compressor_I = true;
            if (Compressor_I && Compressor_II && MainResChargingRatePSIpS_2 == 0)
            {
                MainResChargingRatePSIpS0 = MainResChargingRatePSIpS / 2;
                MainResChargingRatePSIpS = MainResChargingRatePSIpS0;
            }
            if (MainResChargingRatePSIpS_2 == 0)
                MainResChargingRatePSIpS_2 = MainResChargingRatePSIpS;



            if (File.Exists(WagFilePath + ".ExtendedPhysics.xml") && extendedPhysics == null)
            {
                extendedPhysics = new ExtendedPhysics(this);
                extendedPhysics.Parse(WagFilePath + ".ExtendedPhysics.xml");
            }
            TrainBrakeController.Initialize();
            EngineBrakeController.Initialize();
            BrakemanBrakeController.Initialize();
            TrainControlSystem.Initialize();

            DynamicBrakeChangeActiveState(false);

            if (MaxSteamHeatPressurePSI == 0)       // Check to see if steam heating is fitted to locomotive
            {
                IsSteamHeatFitted = false;
            }
            else
            {
                IsSteamHeatFitted = true;
            }

            SteamHeatPressureToTemperaturePSItoF = SteamTable.SteamHeatPressureToTemperatureInterpolatorPSItoF();
            SteamDensityPSItoLBpFT3 = SteamTable.SteamDensityInterpolatorPSItoLBpFT3();
            SteamHeatPSItoBTUpLB = SteamTable.SteamHeatInterpolatorPSItoBTUpLB();

            // Check to see if water scoop elements have been configured
            if (WaterScoopFillElevationM == 0)
            {
                WaterScoopFillElevationM = 2.7432f; // Set to default of 9 ft
            }

            if (WaterScoopDepthM == 0)
            {
                WaterScoopDepthM = 0.0889f; // Set to default of 3.5 ins
            }

            if (WaterScoopWidthM == 0)
            {
                WaterScoopWidthM = 0.3048f; // Set to default of 1 ft
            }

            // Check if current sander has been set
            if (CurrentTrackSandBoxCapacityL == 0)
            {
                CurrentTrackSandBoxCapacityL = MaxTrackSandBoxCapacityL;
            }

            // Ensure Drive Axles is set with a default value if user doesn't supply an OR value in ENG file
            if (LocoNumDrvAxles == 0)
            {
                if (MSTSLocoNumDrvWheels != 0 && MSTSLocoNumDrvWheels <= 6)
                {
                    LocoNumDrvAxles = (int)MSTSLocoNumDrvWheels;
                }
                else
                {
                    LocoNumDrvAxles = 4; // Set 4 axles as default
                }

                if (Simulator.Settings.VerboseConfigurationMessages)
                {
                    Trace.TraceInformation("Number of Locomotive Drive Axles set to default value of {0}", LocoNumDrvAxles);
                }
            }


            // Calculate minimum speed to pickup water
            const float Aconst = 2;
            WaterScoopMinSpeedMpS = Me.FromFt((float)Math.Sqrt(Aconst * GravitationalAccelerationFtpSpS * Me.ToFt(WaterScoopFillElevationM)));

            // Initialise Brake Pipe Charging Rate
            if (BrakePipeChargingRatePSIorInHgpS == 0) // Check to see if BrakePipeChargingRate has been set in the ENG file.
            {
                // Set Default BrakePipe Charging Rate depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeChargingRatePSIorInHgpS = 0.32f; // Vacuum brakes
                }
                else
                {
                    BrakePipeChargingRatePSIorInHgpS = Simulator.Settings.BrakePipeChargingRate; // Air brakes
                }
            }
            // Initialise Brake Pipe Quick Charging Rate
            if (BrakePipeQuickChargingRatePSIpS == 0) BrakePipeQuickChargingRatePSIpS = BrakePipeChargingRatePSIorInHgpS;

            // Initialise Exhauster Charging rate in diesel and electric locomotives. The equivalent ejector charging rates are set in the steam locomotive.
            if (this is MSTSDieselLocomotive || this is MSTSElectricLocomotive)
            {
                ExhausterHighSBPChargingRatePSIorInHgpS = BrakePipeChargingRatePSIorInHgpS;
                ExhausterLowSBPChargingRatePSIorInHgpS = BrakePipeChargingRatePSIorInHgpS / 5.0f; // Low speed exhauster setting is 1/5 of high speed
            }
            else
            {
                // Default to zero if not used.
                ExhausterHighSBPChargingRatePSIorInHgpS = 0.0f;
                ExhausterLowSBPChargingRatePSIorInHgpS = 0.0f;
            }

            // Initialise BrakePipeDischargeTimeFactor
            if (BrakePipeDischargeTimeFactor == 0)
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeDischargeTimeFactor = 1.5f; // Vacuum brakes
                }
                else
                {
                    BrakePipeDischargeTimeFactor = 1.5f; // Air brakes
                }
            }

            // Initialise the resistance of the vacuum pump
            if (VacuumPumpResistanceN == 0)
            {
                VacuumPumpResistanceN = 120.0f;
            }

            // Initialise Brake Emergency Time Factor
            if (BrakeEmergencyTimeFactorS == 0) // Check to see if BrakeEmergencyTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Emergency Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakeEmergencyTimeFactorS = 1.0f; // Vacuum brakes
                }
                else
                {
                    BrakeEmergencyTimeFactorS = 0.1f; // Air brakes
                }
            }

            // Initialise Brake Service Time Factor
            if (BrakeServiceTimeFactorS == 0) // Check to see if BrakeServiceTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Service Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakeServiceTimeFactorS = 10.0f; // Vacuum brakes
                }
                else
                {
                    BrakeServiceTimeFactorS = 1.009f; // Air brakes
                }
            }

            // Check TrainBrakesControllerMaxSystemPressure parameter for "correct" value 
            // This is only done for vacuum brakes as the UoM can be confusing - it defaults to psi due to way parameter is read, and if units are entered then a InHG value can be incorrectly converted.
            if ((BrakeSystem is VacuumSinglePipe))
            {
                if (TrainBrakeController.MaxPressurePSI == 21 || TrainBrakeController.MaxPressurePSI == 25) // If 21 or 25 has been entered assume that it is 21InHg or 25InHg, and convert it to the correct psi equivalent
                {
                    float TempMaxPressure = TrainBrakeController.MaxPressurePSI;

                    // Convert assumed inHg value to psi
                    TrainBrakeController.MaxPressurePSI = Bar.ToPSI(Bar.FromInHg(TrainBrakeController.MaxPressurePSI));

                    if (Simulator.Settings.VerboseConfigurationMessages)
                    {
                        Trace.TraceInformation("TrainBrakeController.MaxPressurePSI is assumed to be {0} Inhg, - confirmed as a value of {1} InHg", TempMaxPressure, Bar.ToInHg(Bar.FromPSI(TrainBrakeController.MaxPressurePSI)));
                    }

                }
                else if (TrainBrakeController.MaxPressurePSI < 7 || TrainBrakeController.MaxPressurePSI > 13) // Outside an acceptable range (Eqiv = 15InHg to 25InHg), then convert to a fixed default
                {
                    if (Simulator.Settings.VerboseConfigurationMessages)
                    {
                        Trace.TraceInformation("TrainBrakeController.MaxPressurePSI being incorrectly read as {0} Inhg, - set to a default value of {1} InHg", TrainBrakeController.MaxPressurePSI, Bar.ToInHg(Bar.FromPSI(Bar.ToPSI(Bar.FromInHg(21.0f)))));
                    }
                    TrainBrakeController.MaxPressurePSI = Bar.ToPSI(Bar.FromInHg(21.0f));
                }

            }

            //if (DoesBrakeCutPower && BrakeCutsPowerAtBrakePipePressurePSI > BrakeRestoresPowerAtBrakePipePressurePSI)
            //{
            //    BrakeCutsPowerAtBrakePipePressurePSI = BrakeRestoresPowerAtBrakePipePressurePSI - 1.0f;

            //    if (Simulator.Settings.VerboseConfigurationMessages)
            //    {
            //        Trace.TraceInformation("BrakeCutsPowerAtBrakePipePressure is greater then BrakeRestoresPowerAtBrakePipePressurePSI, and has been set to value of {0} InHg", Bar.ToInHg(Bar.FromPSI(BrakeCutsPowerAtBrakePipePressurePSI)));
            //    }
            //}

            if (DoesBrakeCutPower && (BrakeSystem is VacuumSinglePipe) && (BrakeRestoresPowerAtBrakePipePressurePSI == 0 || BrakeRestoresPowerAtBrakePipePressurePSI > OneAtmospherePSI))
            {
                BrakeRestoresPowerAtBrakePipePressurePSI = Bar.ToPSI(Bar.FromInHg(15.0f)); // Power can be restored once brake pipe rises above 15 InHg

                if (Simulator.Settings.VerboseConfigurationMessages)
                {
                    Trace.TraceInformation("BrakeRestoresPowerAtBrakePipePressure appears out of limits, and has been set to value of {0} InHg", Bar.ToInHg(Bar.FromPSI(BrakeRestoresPowerAtBrakePipePressurePSI)));
                }
            }

            // Initialise Brake Time Factor
            if (BrakePipeTimeFactorS == 0) // Check to see if BrakePipeTimeFactorS has been set in the ENG file.
            {
                // Set Default Brake Pipe Time Factor depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    BrakePipeTimeFactorS = 0.02f; // Vacuum brakes
                }
                else
                {
                    BrakePipeTimeFactorS = 0.0015f; // Air brakes
                }
            }

            // Initialise Train Pipe Leak Rate
            if (TrainBrakePipeLeakPSIorInHgpS == 0) // Check to see if TrainBrakePipeLeakPSIorInHgpS has been set in the ENG file.
            {
                // Set Default Train Brake Pipe Leak depending upon whether locomotive has Vacuum or air brakes - overwritten by ENG file setting.
                // Default currently set to zero - means that by default function is off, and a value must be entered into the ENG file to get it to work
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    TrainBrakePipeLeakPSIorInHgpS = 0.0f; // Vacuum brakes
                }
                else
                {
                    TrainBrakePipeLeakPSIorInHgpS = 0.0f; // Air brakes
                }
            }

            base.Initialize();
            if (DynamicBrakeBlendingEnabled) airPipeSystem = BrakeSystem as AirSinglePipe;

            DrvWheelWeightKg = InitialDrvWheelWeightKg;
        }

        public float DistanceToPowerSupplyStationM(int PowerSystem, out PowerSupplyStation myStation)
        {
            double distance = 100000;
            double currentLat = 0;
            double currentLon = 0;
            myStation = null;
            new WorldLatLon().ConvertWTC(WorldPosition.TileX, WorldPosition.TileZ, WorldPosition.WorldLocation.Location, ref currentLat, ref currentLon);
            currentLat = MathHelper.ToDegrees((float)currentLat);
            currentLon = MathHelper.ToDegrees((float)currentLon);
            foreach (PowerSupplyStation pss in Simulator.powerSupplyStations)
            {
                if (pss.PowerSystem == PowerSystem)
                {
                    if (myStation == null)
                        myStation = pss;
                    PowerSystem = myStation.PowerSystem;
                    double psiLat = MathHelper.ToDegrees((float)pss.Longitude);
                    double psiLon = MathHelper.ToDegrees((float)pss.Latitude);
                    double currdistance = getDistance(currentLat, currentLon, psiLat, psiLon) * 1138.8261851015801354401805869074;
                    if (currdistance < distance)
                    {
                        distance = currdistance;
                        myStation = pss;
                        RouteVoltageV = myStation.PowerSystem == 0 ? 3000 : 25000;
                    }
                }
            }
            if (RouteVoltageV == 3000)
                if (distance > 14000)
                    distance = 14000;
            if (RouteVoltageV > 3000)
                if (distance > 28000)
                    distance = 28000;
            return (float)distance;
        }

        public float DistanceToVoltageMarkerM(out int Voltage, out VoltageChangeMarker myMarker)
        {
            double distance = 100000;
            double currentLat = 0;
            double currentLon = 0;
            myMarker = new VoltageChangeMarker();
            Voltage = 0;
            new WorldLatLon().ConvertWTC(WorldPosition.TileX, WorldPosition.TileZ, WorldPosition.WorldLocation.Location, ref currentLat, ref currentLon);
            currentLat = MathHelper.ToDegrees((float)currentLat);
            currentLon = MathHelper.ToDegrees((float)currentLon);
            foreach (VoltageChangeMarker vcm in Simulator.voltageChangeMarkers)
            {
                double psiLat = MathHelper.ToDegrees((float)vcm.Longitude);
                double psiLon = MathHelper.ToDegrees((float)vcm.Latitude);
                double currdistance = getDistance(currentLat, currentLon, psiLat, psiLon) * 1138.8261851015801354401805869074;
                if (currdistance < distance)
                {
                    distance = currdistance;
                    myMarker = vcm;
                    Voltage = vcm.Voltage;
                }
            }
            return (float)distance;
        }

        private double getDistance(double lat1, double lon1, double lat2, double lon2)
        {
            if ((lat1 == lat2) && (lon1 == lon2))
            {
                return 0;
            }
            else
            {
                double theta = lon1 - lon2;
                double dist = Math.Sin(deg2rad(lat1)) * Math.Sin(deg2rad(lat2)) + Math.Cos(deg2rad(lat1)) * Math.Cos(deg2rad(lat2)) * Math.Cos(deg2rad(theta));
                dist = Math.Acos(dist);
                dist = rad2deg(dist);
                dist = dist * 60 * 1.1515;
                dist = dist * 1.609344;
                return (dist);
            }
        }

        //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        //::  This function converts decimal degrees to radians             :::
        //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        private double deg2rad(double deg)
        {
            return (deg * Math.PI / 180.0);
        }

        //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        //::  This function converts radians to decimal degrees             :::
        //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        private double rad2deg(double rad)
        {
            return (rad / Math.PI * 180.0);
        }

        public void SetUpVoltageChangeMarkers()
        {
            try
            {
                Simulator.voltageChangeMarkers.Clear();
                if (!File.Exists(Simulator.RoutePath + "\\VoltageChangeMarkers.xml"))
                    return;
                XmlDocument doc = new XmlDocument();
                doc.Load(Simulator.RoutePath + "\\VoltageChangeMarkers.xml");
                foreach (XmlNode node in doc.ChildNodes)
                {
                    if (node.Name == "VoltageChangeMarkers")
                    {
                        foreach (XmlNode nodeSupply in node.ChildNodes)
                        {
                            double nextNodeLon = 0;
                            double nextNodeLat = 0;
                            int nextNodeVoltage = 0;
                            int id = 0;

                            foreach (XmlNode nodeId in nodeSupply.ChildNodes)
                            {
                                if (nodeId.Name == "Id")
                                    id = int.Parse(nodeId.InnerText);
                                if (nodeId.Name == "Longitude")
                                {
                                    try
                                    {
                                        nextNodeLon = double.Parse(nodeId.InnerText);
                                    }
                                    catch
                                    {
                                        nextNodeLon = double.Parse(nodeId.InnerText.Replace(".", ","));
                                    }

                                }
                                if (nodeId.Name == "Latitude")
                                {
                                    try
                                    {
                                        nextNodeLat = double.Parse(nodeId.InnerText);
                                    }
                                    catch
                                    {
                                        nextNodeLat = double.Parse(nodeId.InnerText.Replace(".", ","));
                                    }
                                }
                                if (nodeId.Name == "Voltage")
                                    nextNodeVoltage = int.Parse(nodeId.InnerText);
                            }
                            VoltageChangeMarker vcm = new VoltageChangeMarker();
                            vcm.Id = id;
                            vcm.Latitude = nextNodeLat;
                            vcm.Longitude = nextNodeLon;
                            vcm.Voltage = nextNodeVoltage;
                            Simulator.voltageChangeMarkers.Add(vcm);
                        }
                    }
                }
            }
            catch { }
        }

        public void SetUpPowerSupplyStations()
        {
            try
            {
                Simulator.powerSupplyStations.Clear();
                if (!File.Exists(Simulator.RoutePath + "\\PowerSupplyStations.xml"))
                    return;
                XmlDocument doc = new XmlDocument();
                doc.Load(Simulator.RoutePath + "\\PowerSupplyStations.xml");
                foreach (XmlNode node in doc.ChildNodes)
                {
                    if (node.Name == "PowerSupplyStations")
                    {
                        foreach (XmlNode nodeSupply in node.ChildNodes)
                        {
                            int nextNodeId = -1;
                            double nextNodeLon = 0;
                            double nextNodeLat = 0;
                            int nextNodePowerSystem = 0;

                            foreach (XmlNode nodeId in nodeSupply.ChildNodes)
                            {
                                if (nodeId.Name == "Longitude")
                                {
                                    try
                                    {
                                        nextNodeLon = double.Parse(nodeId.InnerText);
                                    }
                                    catch
                                    {
                                        nextNodeLon = double.Parse(nodeId.InnerText.Replace(".", ","));
                                    }

                                }
                                if (nodeId.Name == "Latitude")
                                {
                                    try
                                    {
                                        nextNodeLat = double.Parse(nodeId.InnerText);
                                    }
                                    catch
                                    {
                                        nextNodeLat = double.Parse(nodeId.InnerText.Replace(".", ","));
                                    }
                                }
                                if (nodeId.Name == "PowerSystem")
                                    nextNodePowerSystem = int.Parse(nodeId.InnerText);
                                if (nodeId.Name == "Id")
                                    nextNodeId = int.Parse(nodeId.InnerText);

                            }
                            PowerSupplyStation pss = new PowerSupplyStation();
                            pss.Id = nextNodeId;
                            pss.Latitude = nextNodeLat;
                            pss.Longitude = nextNodeLon;
                            pss.PowerSystem = nextNodePowerSystem;
                            Simulator.powerSupplyStations.Add(pss);
                        }
                    }
                }
            }
            catch { }
            if (Simulator.powerSupplyStations.Count == 0)
            {
                PowerSupplyStation pss = new PowerSupplyStation();
                pss.IsDefault = true;
                Simulator.powerSupplyStations.Add(pss);
                pss = new PowerSupplyStation();
                pss.PowerSystem = 1;
                Simulator.powerSupplyStations.Add(pss);
            }
        }

        /// <summary>
        /// Make instance of Cruise Control and Initialize it
        /// </summary>
        public void SetUpCruiseControl()
        {
            CruiseControl = new CruiseControl(this);
            CruiseControl.Initialize();
            CruiseControl.Equipped = true;
        }

        /// <summary>
        /// Make instance of multi position controller
        /// </summary>
        public void SetUpMPC()
        {
            MultiPositionController = new MultiPositionController(this);
            if (MultiPositionControllers == null)
            {
                MultiPositionControllers = new List<MultiPositionController>();
            }
            MultiPositionControllers.Add(MultiPositionController);
        }

        public void SetUpMirel()
        {
            Mirel.Initialize();
            Mirel.Equipped = true;
        }

        //================================================================================================//
        /// <summary>
        /// Set starting conditions  when initial speed > 0 
        /// </summary>
        /// 

        public override void InitializeMoving()
        {
            base.InitializeMoving();
            LocomotiveAxle.Reset(Simulator.GameTime, SpeedMpS);
            LocomotiveAxle.AxleSpeedMpS = SpeedMpS;
            LocomotiveAxle.AdhesionConditions = (float)(Simulator.Settings.AdhesionFactor) * 0.01f;
            AdhesionFilter.Reset(0.5f);
            AverageForceN = MaxForceN * Train.MUThrottlePercent / 100;
            float maxPowerW = MaxPowerW * Train.MUThrottlePercent * Train.MUThrottlePercent / 10000;
            if (AverageForceN * SpeedMpS > maxPowerW) AverageForceN = maxPowerW / SpeedMpS;
            LocomotiveAxle.FilterMovingAverage.Initialize(AverageForceN);
            if (Train.IsActualPlayerTrain)
            {
                TrainControlSystem.InitializeMoving();
                TrainBrakeController.InitializeMoving();
                BrakeSystem.LocoInitializeMoving();
            }
        }

        //================================================================================================//
        /// <summary>
        /// Dynamic brake blending 
        /// </summary>
        protected bool disableDynamicBrakeIntervention = false;
        public void DynamicBrakeBlending(float elapsedClockSeconds)
        {
            if (IsPlayerTrain)
            {
                if (EngineBrakeEngageEDB || BrakeSystem.OL3active || BreakEDBButton_Activated)
                    return;

                if (!PowerOn && !EDBIndependent)
                    disableDynamicBrakeIntervention = true;
                if (Bar.FromPSI(BrakeSystem.BrakeLine1PressurePSI) > 4.9)
                    disableDynamicBrakeIntervention = false;
                if (disableDynamicBrakeIntervention)
                {
                    DynamicBrakeIntervention = -1;
                    DynamicBrakeBlended = false;
                    return;
                }
            }

            // Povolí EDB pro AI vlaky
            if (!IsPlayerTrain && DynamicBrakeController != null)
            {
                airPipeSystem = BrakeSystem as AirSinglePipe;
                DynamicBrake = true;
            }

            if (airPipeSystem != null
                && ((airPipeSystem is EPBrakeSystem && Train.BrakeLine4 > 0f) || (MainResPressurePSI >= airPipeSystem.maxPressurePSI0 && airPipeSystem.BrakeLine1PressurePSI < TrainBrakeController.MaxPressurePSI - 1f && AbsSpeedMpS > 1)
                && ThrottleController.CurrentValue == 0f && !(DynamicBrakeController != null && DynamicBrakeBlendingOverride && DynamicBrakeController.CurrentValue > 0f))
                /* && (!DynamicBrakeBlendingLeverOverride && DynamicBrakeController != null && DynamicBrakeIntervention < DynamicBrakeController.CurrentValue)*/)
            {
                float threshold = DynamicBrakeBlendingForceMatch ? 100f : 0.01f;
                float maxCylPressurePSI = airPipeSystem.GetMaxCylPressurePSI();
                float targetDynamicBrakePercent = airPipeSystem is EPBrakeSystem ? Train.BrakeLine4 : Math.Min(((TrainBrakeController.MaxPressurePSI - airPipeSystem.BrakeLine1PressurePSI) * airPipeSystem.GetAuxCylVolumeRatio()) / maxCylPressurePSI, 1f);
                //DynamicBrakeIntervention = Math.Min(((TrainBrakeController.CurrentValue - DynamicBrakeBlendingStart) / (DynamicBrakeBlendingStop - DynamicBrakeBlendingStart)), 1f);

                if (!DynamicBrakeBlended)
                {
                    DynamicBrakeBlended = true;
                    if (DynamicBrakeController != null)
                        DynamicBrakeIntervention = DynamicBrakeController.CurrentValue;
                    else
                        DynamicBrakeIntervention = 0;
                    DynamicBrakeCommandStartTime = Simulator.ClockTime;
                }
                if (DynamicBrake)
                {
                    float diff = DynamicBrakeBlendingForceMatch ? targetDynamicBrakePercent * MaxBrakeForceN - DynamicBrakeForceN : targetDynamicBrakePercent - DynamicBrakeIntervention;
                    if (diff > threshold && DynamicBrakeIntervention <= 1)
                    {
                        DynamicBrakeIntervention = Math.Min(DynamicBrakeIntervention + elapsedClockSeconds * (airPipeSystem.GetMaxApplicationRatePSIpS() / maxCylPressurePSI), 1.0f);
                    }
                    else if (diff < -threshold)
                    {
                        DynamicBrakeIntervention = Math.Max(DynamicBrakeIntervention - elapsedClockSeconds * (airPipeSystem.GetMaxApplicationRatePSIpS() / maxCylPressurePSI), 0f);
                    }
                }
                if (DynamicBrakeController != null)
                    DynamicBrakeIntervention = Math.Max(DynamicBrakeIntervention, DynamicBrakeController.CurrentValue);
            }

            else if (DynamicBrakeBlended)
            {
                if (DynamicBrakeIntervention > 0 && (DynamicBrakeController != null && DynamicBrakeIntervention > DynamicBrakeController.CurrentValue))
                    DynamicBrakeIntervention -= 0.01f;
                else
                {
                    DynamicBrakeBlended = false;
                    DynamicBrakeIntervention = -1;
                }
            }
        }

        // Icik
        public void PlayerSwitchToRearCab()
        {
            Simulator.PlayerUsingRearCab = UsingRearCab;

            if (UsingRearCab)
            {
                SignalEvent(Event.ActiveRearCab);
            }
            else
            {
                SignalEvent(Event.ActiveFrontCab);
            }
        }

        // Icik
        public void PowerStepControllerCalculation()
        {
            if (TractiveForceStepControllerCurvesAC != null)
                TractiveForceN = TractiveForceStepControllerCurvesAC.Get(StepControllerValue, AbsWheelSpeedMpS);

            TractiveForceN = 0;
        }

        float prePowerCurrent1;
        float FakePowerCurrent1;
        float FakePowerCurrent1Timer;
        bool SetFakePowerCurrent1Timer;
        float prePowerCurrent2;
        float FakePowerCurrent2;
        float FakePowerCurrent2Timer;
        bool SetFakePowerCurrent2Timer;
        public void PowerCurrentCalculation(float elapsedClockSeconds)
        {
            if (CurrentForceStep2Curves != null)
                PowerCurrent2 = CurrentForceStep2Curves.Get(StepControllerValue, Math.Abs(DriveForceN));
            
            if (CurrentForceStep1Curves != null)
                PowerCurrent1 = CurrentForceStep1Curves.Get(StepControllerValue, Math.Abs(DriveForceN));
            else            
            if (CurrentForceCurves != null)
                PowerCurrent1 = CurrentForceCurves.Get(Math.Abs(DriveForceN), AbsWheelSpeedMpS);                                    
            else
            // Default
            PowerCurrent1 = Math.Abs(DriveForceN) / MaxForceN * MaxCurrentA;


            if (PowerCurrent1 > 1.02f * prePowerCurrent1)
            {
                FakePowerCurrent1 = PowerCurrent1 * 1.05f;
                SetFakePowerCurrent1Timer = true;
            }
            if (PowerCurrent1 < 0.98f * prePowerCurrent1)
            {
                FakePowerCurrent1 = PowerCurrent1 * 0.95f;
                SetFakePowerCurrent1Timer = true;
            }
            if (SetFakePowerCurrent1Timer)
            {
                FakePowerCurrent1Timer += elapsedClockSeconds;
                if (FakePowerCurrent1Timer > 0.25f)
                    SetFakePowerCurrent1Timer = false;
            }
            if (!SetFakePowerCurrent1Timer)
            {
                FakePowerCurrent1 = PowerCurrent1;
                FakePowerCurrent1Timer = 0;
            }

            if (PowerCurrent2 > 1.02f * prePowerCurrent2)
            {
                FakePowerCurrent2 = PowerCurrent2 * 1.05f;
                SetFakePowerCurrent2Timer = true;
            }
            if (PowerCurrent2 < 0.98f * prePowerCurrent2)
            {
                FakePowerCurrent2 = PowerCurrent2 * 0.95f;
                SetFakePowerCurrent2Timer = true;
            }
            if (SetFakePowerCurrent2Timer)
            {
                FakePowerCurrent2Timer += elapsedClockSeconds;
                if (FakePowerCurrent2Timer > 0.25f)
                    SetFakePowerCurrent2Timer = false;
            }
            if (!SetFakePowerCurrent2Timer)
            {
                FakePowerCurrent2 = PowerCurrent2;
                FakePowerCurrent2Timer = 0;
            }

            prePowerCurrent1 = PowerCurrent1;
            prePowerCurrent2 = PowerCurrent2;
        }

        //Icik
        public void BrakeCurrentCalculation()
        {
            if (CurrentBrakeForce2Curves != null)
                BrakeCurrent2 = CurrentBrakeForce2Curves.Get(Math.Abs(DynamicBrakeForceN), AbsWheelSpeedMpS);

            if (CurrentBrakeForce1Curves != null)
                BrakeCurrent1 = CurrentBrakeForce1Curves.Get(Math.Abs(DynamicBrakeForceN), AbsWheelSpeedMpS);
            else
            // Default
            BrakeCurrent1 = Math.Abs(DynamicBrakeForceN) / MaxForceN * MaxCurrentA;            
        }

        // Icik
        // Definice ochran lokomotiv        
        public void Overcurrent_Protection()
        {
            if (LocoType == LocoTypes.Vectron)
                return;

            if (MaxCurrentA > 0 && (this is MSTSElectricLocomotive || this is MSTSDieselLocomotive))  // Zohlední jen elektrické a dieselelektrické lokomotivy
            {
                // Nadproudová ochrana                        
                if (MaxCurrentPower == 0) MaxCurrentPower = MaxCurrentA / 1.2f;
                if (MaxCurrentBrake == 0) MaxCurrentBrake = MaxCurrentA / 1.2f;
                                
                if (float.IsInfinity(PowerCurrent1) || float.IsNaN(BrakeCurrent1))
                    return;

                if (this is MSTSElectricLocomotive && DynamicBrakeForceN == 0) // Stanovení kritického proudu pro elektrické lokomotivy při výkonu
                    if (PowerCurrent1 > MaxCurrentPower)
                        OverCurrent = true;
                if (this is MSTSElectricLocomotive && DynamicBrakeForceN > 0) // Stanovení kritického proudu pro elektrické lokomotivy při dynamickém brždění
                    if (BrakeCurrent1 > MaxCurrentBrake)
                        OverCurrent = true;

                if (this is MSTSDieselLocomotive && DynamicBrakeForceN == 0) // Stanovení kritického proudu pro dieselelektrické lokomotivy při výkonu
                    if (PowerCurrent1 > MaxCurrentPower)
                        OverCurrent = true;
                if (this is MSTSDieselLocomotive && DynamicBrakeForceN > 0) // Stanovení kritického proudu pro dieselelektrické lokomotivy při dynamickém brždění
                    if (BrakeCurrent1 > MaxCurrentBrake)
                        OverCurrent = true;

                //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("MaxCurrentPower: " + MaxCurrentPower + "   PowerCurrent1: " + PowerCurrent1 + "      MaxCurrentBrake: " + MaxCurrentBrake + "   BrakeCurrent1: " + BrakeCurrent1));

                if (OverCurrent)
                {                                        
                    if (DoesPowerLossResetControls || DoesPowerLossResetControls2)
                    {
                        SetThrottlePercent(0);
                        ControllerVolts = 0;
                        DynamicBrakeController.CurrentValue = 0;
                    }
                    if (this is MSTSElectricLocomotive) // Elektrické lokomotivy
                    {
                        switch (MultiSystemEngine)
                        {
                            case true: // Vícesystémová lokomotiva                            
                                HVOff = true; // Vypnutí HV    
                                break;
                            case false: // Jednosystémová lokomotiva
                                HVOff = true; // Vypnutí HV                                
                                break;
                        }
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Overcurrent protection!"));
                        SignalEvent(Event.Failure);
                    }
                    if (this is MSTSDieselLocomotive) // Dieselelektrické lokomotivy
                    {
                        PowerReductionResult4 = 0.9f; // Omezení trakčních motorů                                                  
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Overcurrent protection!"));
                    }
                }

                // Resetování nadproudové ochrany u elektrických lokomotiv
                if (this is MSTSElectricLocomotive && OverCurrent && LocalThrottlePercent < 1.0f && LocalDynamicBrakePercent < 1.0f)
                {
                    OverCurrent = false;
                }

                // Resetování nadproudové ochrany u dieselelektrických lokomotiv
                if (this is MSTSDieselLocomotive && OverCurrent && LocalThrottlePercent < 1.0f && LocalDynamicBrakePercent < 1.0f)
                {
                    OverCurrent = false;
                    PowerReductionResult4 = 0;
                }
            }
        }

        // Icik
        // Protiskluzová ochrana
        public void AntiSlip_Protection()
        {
            if (!IsLeadLocomotive())
                return;                      

            if (MaxCurrentA > 0)  // Zohlední jen elektrické a dieselelektrické lokomotivy 
            {
                if (SlipSpeedCritical == 0) SlipSpeedCritical = 40 / 3.6f; // Výchozí hodnota 40 km/h     
                float AbsSlipSpeedMpS = Math.Abs(WheelSpeedMpS_Cab) - AbsSpeedMpS;  // Zjistí absolutní rychlost prokluzu 
                //if (extendedPhysics != null)
                //{
                //    SlipSpeedCritical = 10 / 3.6f; // 10kmh pokud počítáme pátou osu
                //    AbsSlipSpeedMpS = extendedPhysics.FastestAxleSpeedMpS - extendedPhysics.AverageAxleSpeedMpS;
                //}
                //Trace.TraceInformation("WheelSlipTime {0},  Simulator.GameTime {1},  Time0 {2},   SlipSpeed {3}", WheelSlipTime, Simulator.GameTime, Time0, SlipSpeed);
                
                if (AbsSlipSpeedMpS > SlipSpeedCritical) // Přepěťová ochrana při skluzu 
                    OverVoltage = true;

                if (OverVoltage)
                {
                    if (extendedPhysics != null)
                    {
                        DriveForceN = 0;                        
                        extendedPhysics.FastestAxleSpeedMpS = extendedPhysics.AverageAxleSpeedMpS = WheelSpeedMpS = SpeedMpS;                         
                    }

                    if (DoesPowerLossResetControls || DoesPowerLossResetControls2)
                    {
                        SetThrottlePercent(0);
                        ControllerVolts = 0;
                    }
                    if (this is MSTSElectricLocomotive) // Elektrické lokomotivy
                    {
                        switch (MultiSystemEngine)
                        {
                            case true: // Vícesystémová lokomotiva                            
                                HVOff = true; // Vypnutí HV    
                                break;
                            case false: // Jednosystémová lokomotiva
                                HVOff = true; // Vypnutí HV                                
                                break;
                        }
                        LocalDynamicBrakePercent = 0;
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Slip protection!"));
                        SignalEvent(Event.Failure);
                    }
                    if (this is MSTSDieselLocomotive) // Dieselelektrické lokomotivy
                    {
                        LocalDynamicBrakePercent = 0;
                        PowerReductionResult4 = 0.9f; // Omezení trakčních motorů  
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Slip protection!"));
                    }
                }

                // Resetování nadproudové ochrany u elektrických lokomotiv
                if (this is MSTSElectricLocomotive && OverVoltage && LocalThrottlePercent == 0 && LocalDynamicBrakePercent == 0)
                {
                    OverVoltage = false;
                }

                // Resetování nadproudové ochrany u dieselelektrických lokomotiv
                if (this is MSTSDieselLocomotive && OverVoltage && LocalThrottlePercent == 0 && LocalDynamicBrakePercent == 0)
                {
                    OverVoltage = false;
                    PowerReductionResult4 = 0;                    
                }
            }
        }

        // Icik
        // Napěťový filtr pro umožnění použití EDB bez pantografu        
        public void PowerOn_Filter(float elapsedClockSeconds)
        {
            // Nabíjení a vybíjení napěťového filtru
            if (EDBIndependent)
            {
                // Kapacita napěťového filtru
                PowerOnFilterCapacity = 2400; // 5 min při brždění 80kN, plně nabito za 4 min
                                              // Mezní kapacita napěťového filtru, při které začne deaktivace EDB 
                PowerOnFilterCapacityLimit = 200;

                // Nabíjení
                if (PowerOn && PowerOnFilter < PowerOnFilterCapacity)
                    PowerOnFilter = PowerOnFilter + (10 * elapsedClockSeconds); // 10 jednotek za sekundu
                // Vybíjení
                if (Battery && PowerKey && !PowerOn && DynamicBrakePercent > 0 && PowerOnFilter > 0)
                    PowerOnFilter = PowerOnFilter - (DynamicBrakeForceN / 10000 * elapsedClockSeconds);
                // Pokles síly EDB při vybití filtru
                if (!Battery || !PowerKey)
                    PowerOnFilter = 0;
                if (Battery && PowerKey && !PowerOn && DynamicBrakePercent > 0 && PowerOnFilter < PowerOnFilterCapacityLimit)
                {
                    if (DynamicBrakeIntervention > -1)
                        DynamicBrakeIntervention -= 0.01f;
                    if (DynamicBrakeIntervention < 0)
                        DynamicBrakeIntervention = -1;
                    DynamicBrakePercent--;
                    if (DynamicBrakePercent < 0)
                        DynamicBrakePercent = 0;
                    SetDynamicBrakePercent(DynamicBrakePercent);
                }                
                //Trace.TraceWarning("Hodnota PowerOnFilter {0}, DynamicBrakePercent {1}, čas simulace {2}", PowerOnFilter, DynamicBrakePercent, Simulator.GameTime);
            }
        }

        // Icik
        // Při stisknutí vyřazení EDB zruší účinek EDB      
        public void EDBCancelByBreakEDBButton()
        {
            if (BreakEDBButton_Activated)
            {
                if (DynamicBrakeIntervention > -1)
                    DynamicBrakeIntervention -= 0.5f;
                if (DynamicBrakeIntervention < 0)
                    DynamicBrakeIntervention = -1;
                DynamicBrakePercent -= 1.0f;
                if (DynamicBrakePercent < 0)
                    DynamicBrakePercent = 0;
                SetDynamicBrakePercent(DynamicBrakePercent);
            }
        }

        // Icik
        // Při aktivní EDB a použití přímočinné brzdy zruší účinek EDB      
        public void EDBCancelByEngineBrake()
        {
            if (EngineBrakeEngageEDB)
            {
                if (DynamicBrakeIntervention > -1)
                    DynamicBrakeIntervention -= 0.5f;
                if (DynamicBrakeIntervention < 0)
                    DynamicBrakeIntervention = -1;
                DynamicBrakePercent -= 2.0f;
                if (DynamicBrakePercent < 0)
                    DynamicBrakePercent = 0;
                SetDynamicBrakePercent(DynamicBrakePercent);
                if (BrakeSystem.AutoCylPressurePSI1 < 1 && DynamicBrakePercent == 0)
                {
                    EngineBrakeEngageEDB = false;
                }
            }
        }

        // Icik
        // Při aktivní OL3 zruší účinek EDB      
        public void EDBCancelByOL3BailOff()
        {
            if (BrakeSystem.OL3active)
            {
                if (DynamicBrakeIntervention > -1)
                    DynamicBrakeIntervention -= 0.5f;
                if (DynamicBrakeIntervention < 0)
                    DynamicBrakeIntervention = -1;
                DynamicBrakePercent -= 1.0f;
                if (DynamicBrakePercent < 0)
                    DynamicBrakePercent = 0;
                SetDynamicBrakePercent(DynamicBrakePercent);
            }
        }

        // Icik
        public void HVOffbyAirPressureE()
        {
            if (DoesBrakeCutPower && this is MSTSElectricLocomotive)
            {
                // Pokud stoupne tlak nad hraniční hodnotu tlaku v brzdovém válci
                if (BrakeCutsPowerAtBrakeCylinderPressurePSI != 0)
                {
                    if (BrakeSystem.GetCylPressurePSI() >= BrakeCutsPowerAtBrakeCylinderPressurePSI && LocalThrottlePercent > 0
                      || HVOffStatusBrakeCyl)
                    {
                        HVOff = true; // Vypnutí HV                        
                        HVOffStatusBrakeCyl = true;
                    }
                    if (BrakeSystem.GetCylPressurePSI() < BrakeCutsPowerAtBrakeCylinderPressurePSI || !PowerOn)
                        HVOffStatusBrakeCyl = false;
                }

                if (PowerOn && BrakeSystem.BrakeCylApply && LocalThrottlePercent > 0
                || HVOffStatusBrakePipe)
                {
                    // Pokud klesne tlak pod hraniční hodnotu tlaku v brzdovém potrubí
                    if (BrakeCutsPowerAtBrakePipePressurePSI != 0)
                        if (BrakeSystem.BrakeLine1PressurePSI <= BrakeCutsPowerAtBrakePipePressurePSI)
                        {
                            HVOff = true; // Vypnutí HV                            
                            HVOffStatusBrakePipe = true;
                        }
                    //Trace.TraceWarning("Hodnota BrakeSystem.BrakeLine1PressurePSI {0}, BrakeCutsPowerAtBrakePipePressurePSI {1}", BrakeSystem.BrakeLine1PressurePSI, BrakeCutsPowerAtBrakePipePressurePSI);                    
                }

                if (!PowerOn && BrakeSystem.BrakeCylRelease && HVOffStatusBrakePipe)
                {
                    // Pokud vystoupí tlak nad hraniční hodnotu tlaku v brzdovém potrubí
                    if (BrakeRestoresPowerAtBrakePipePressurePSI != 0)
                        if (BrakeSystem.BrakeLine1PressurePSI >= BrakeRestoresPowerAtBrakePipePressurePSI)
                            HVOffStatusBrakePipe = false;
                }
            }
        }
        // Icik
        public void HVOffbyAirPressureD()
        {
            if (this is MSTSDieselLocomotive)
            {
                // Pokud stoupne tlak nad hraniční hodnotu tlaku v brzdovém válci
                if (DoesBrakeCutPower && BrakeCutsPowerAtBrakeCylinderPressurePSI != 0 && !HVOffStatusBrakePipe)
                {
                    if (BrakeSystem.GetCylPressurePSI() >= BrakeCutsPowerAtBrakeCylinderPressurePSI && LocalThrottlePercent > 0
                      || HVOffStatusBrakeCyl)
                    {
                        PowerReductionResult5 = 1;
                        HVOffStatusBrakeCyl = true;
                    }
                    if (BrakeSystem.GetCylPressurePSI() < BrakeCutsPowerAtBrakeCylinderPressurePSI)
                    {
                        PowerReductionResult5 = 0;
                        HVOffStatusBrakeCyl = false;
                    }
                }

                if (BrakeCutsPowerAtBrakePipePressurePSI == 0) BrakeCutsPowerAtBrakePipePressurePSI = 3.5f * 14.50377f; // default 3.5bar
                if (BrakeRestoresPowerAtBrakePipePressurePSI == 0) BrakeRestoresPowerAtBrakePipePressurePSI = 4.5f * 14.50377f; // default 4.5bar
                // Pokud klesne tlak pod hraniční hodnotu tlaku v brzdovém potrubí
                if (BrakeSystem.BrakeLine1PressurePSI <= BrakeCutsPowerAtBrakePipePressurePSI)
                    PowerReductionResult2 = 1;
                // Pokud vystoupí tlak nad hraniční hodnotu tlaku v brzdovém potrubí
                if (BrakeSystem.BrakeLine1PressurePSI >= BrakeRestoresPowerAtBrakePipePressurePSI)
                    PowerReductionResult2 = 0;
            }
        }

        // Icik 
        public void PowerReductionResult(float elapsedClockSeconds)
        {
            if (this is MSTSLocomotive)
            {
                if (PowerReduction <
                    PowerReductionResult1
                    + PowerReductionResult2
                    + PowerReductionResult3
                    + PowerReductionResult4
                    + PowerReductionResult5
                    + PowerReductionResult6
                    + PowerReductionResult7
                    + PowerReductionResult8
                    + PowerReductionResult9
                    + PowerReductionResult10
                    + PowerReductionResult11
                    + PowerReductionResult12)
                    PowerReduction += 1 * elapsedClockSeconds;

                if (PowerReduction >
                    PowerReductionResult1
                    + PowerReductionResult2
                    + PowerReductionResult3
                    + PowerReductionResult4
                    + PowerReductionResult5
                    + PowerReductionResult6
                    + PowerReductionResult7
                    + PowerReductionResult8
                    + PowerReductionResult9
                    + PowerReductionResult10
                    + PowerReductionResult11
                    + PowerReductionResult12)
                    PowerReduction -= 1 * elapsedClockSeconds;

                PowerReduction = MathHelper.Clamp(PowerReduction, 0, 0.999f);
                PowerReduction = (float)Math.Round(PowerReduction, 3);

                if (PowerReductionResult10 == 1) SetThrottlePercent(0);                
                
                if (!PowerKey && !Simulator.TrainPowerKey)
                    PowerReductionResult11 = 1;
                else
                if (PowerReductionResult11 == 1 && LocalThrottlePercent == 0)
                    PowerReductionResult11 = 0;
            }
            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("PowerReduction " + PowerReduction));
            //Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Celková ztráta výkonu "+ PowerReduction * MaxPowerW/1000 + " kW!"));            
        }

        // Icik
        bool TMFailureMSG;
        public void TMFailure(float elapsedClockSeconds)
        {
            return;
            if (Train.TMFailure)
            {
                if (!TMFailureMSG)
                {
                    Simulator.Confirmer.Message(ConfirmLevel.MSG, Simulator.Catalog.GetString("Traction engines destroyed!"));
                    SignalEvent(Event.TMFailure);
                }
                PowerReductionResult7 = 1;
                TMFailureMSG = true;
            }
        }

        // Icik
        // Vypnutí proudu
        public void AuxPowerStartOff()
        {
            if (!this.AuxPowerOff)
                Simulator.Confirmer.Message(ConfirmLevel.MSG, Simulator.Catalog.GetString("Power outage - auxiliary drives are not powered."));
            this.AuxPowerOff = true;
            PowerReductionResult10 = 1;
            if (AcceptMUSignals)
            {
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && car.AcceptMUSignals)
                    {
                        car.AuxPowerOff = true;
                        car.PowerReductionResult10 = 1;
                    }
                }
            }
            if (HV4Switch[LocoStation] != 0)
                AuxPowerCycleHV4 = 0;
        }
        // Icik
        // Zapnutí proudu
        public void AuxPowerStartOn()
        {
            if (IsLeadLocomotive() && Simulator.AuxPowerCanStart && this.AuxPowerOff)
                Simulator.Confirmer.Message(ConfirmLevel.MSG, Simulator.Catalog.GetString("Power on - auxiliary drives are powered up."));
            this.AuxPowerOff = false;
            PowerReductionResult10 = 0;
            if (AcceptMUSignals)
            {
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && car.AcceptMUSignals)
                    {
                        car.AuxPowerOff = false;
                        car.PowerReductionResult10 = 0;
                    }
                }
            }
            if (HV4Switch[LocoStation] != 0)
                AuxPowerCycleHV4 = 0;
        }

        // Icik
        // Nastavuje příznak napájení pomocných obvodů
        float AuxPowerCycleHV4 = 0;
        public void SetAuxPower()
        {
            if (!PowerOn) this.AuxPowerOff = true;
            // HV4
            if (IsLeadLocomotive() && AcceptMUSignals && PowerOn && HV4Enable && AuxPowerCycleHV4 == 0)
            {
                AuxPowerCycleHV4++;
                this.AuxPowerOff = false;
                if (AcceptMUSignals)
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive && car.AcceptMUSignals)
                        {
                            car.AuxPowerOff = false;
                        }
                    }
                }
                if (HV4Switch[LocoStation] != 0)
                    AuxPowerCycleHV4 = 0;
            }
            if (IsLeadLocomotive() && PowerOn && !HV4Enable)
            {
                this.AuxPowerOff = false;
                if (AcceptMUSignals)
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive && car.AcceptMUSignals)
                        {
                            car.AuxPowerOff = false;
                        }
                    }
                }
            }

            // Rozhoduje čas sepnutí obvodu pro pomocné pohony 
            if (IsLeadLocomotive() && !PowerOn) Simulator.AuxPowerCanStart = false;
            if (IsLeadLocomotive() && AuxPowerOn) Simulator.AuxPowerCanStart = true;

            if (this.AuxPowerOff) AuxPowerOn = false;
            if (!this.AuxPowerOff && (Simulator.AuxPowerCanStart || this.LocoHelperOn && PowerOn)) AuxPowerOn = true;
        }


        public float TMTemperature;
        public float TMTemperatureData;
        public float TMTemperatureData0;
        public float MaxTMTemperatureDegC;
        public float IdleTMTemperatureDegC;
        public float AirTMCoolingPower;
        public bool TMCoolingIsOn;
        public float TMTempTimeConstantSec;
        float RunCycle;
        public void TM_Temperature(float elapsedClockSeconds)
        {
            if (MaxTMTemperatureDegC == 0) return;

            // Výpočet teploty trakčních motorů
            float CurrentLoadPercent = MathHelper.Clamp(Math.Max(PowerCurrent1, PowerCurrent2) / MaxCurrentA * 100f, 0, 100);                        

            // Defaulty
            //if (MaxTMTemperatureDegC == 0) MaxTMTemperatureDegC = 200f;
            if (IdleTMTemperatureDegC == 0) IdleTMTemperatureDegC = 80f;
            if (AirTMCoolingPower == 0) AirTMCoolingPower = 80f;
            if (TMTempTimeConstantSec == 0) TMTempTimeConstantSec = 1500f;

            if (FirstCabLoaded || (RunCycle > 0 && TMTemperature == 0))
            {
                RunCycle++;
                if (Simulator.Settings.AirEmpty || BrakeSystem.IsAirEmpty)
                    TMTemperature = CarOutsideTempC0;
                else
                    TMTemperature = IdleTMTemperatureDegC;
                return;
            }
            RunCycle = 0;

            // Fáze zahřívání vlivem zátěže TM
            float TMTemperatureDelta = elapsedClockSeconds * (CurrentLoadPercent * 0.01f * (MaxTMTemperatureDegC - IdleTMTemperatureDegC) + IdleTMTemperatureDegC - TMTemperature) * (CurrentLoadPercent * 0.5f) / TMTempTimeConstantSec;            
            TMTemperature += MathHelper.Clamp(TMTemperatureDelta, 0, 1f);

            // Přirozené chladnutí vlivem okolního prostředí
            TMTemperature -= MathHelper.Clamp(elapsedClockSeconds * (TMTemperature - CarOutsideTempC0) / TMTempTimeConstantSec, 0, 1f);

            // Ochlazení během aktivního chlazení
            if (LocalThrottlePercent > 0 && PowerOn)
            {
                TMTemperature -= elapsedClockSeconds * (TMTemperature - (1.5f * CarOutsideTempCBase)) / TMTempTimeConstantSec * (AirTMCoolingPower / 500f);
                if (!TMCoolingIsOn)
                {
                    TMCoolingIsOn = true;
                    SignalEvent(Event.TMCoolingOn);
                }
            }
            else
            if (TMCoolingIsOn && (LocalThrottlePercent == 0 || !PowerOn))
            {
                TMCoolingIsOn = false;
                SignalEvent(Event.TMCoolingOff);
            }

            // Ochrana proti přehřátí TM
            if (TMTemperature > MaxTMTemperatureDegC && PowerOn)
            {
                Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Thermal protection of traction motors is in effect!"));
                HVOff = true;
            }

            if (TMTemperatureData > TMTemperature)
                TMTemperatureData -= 20 * elapsedClockSeconds; // 20°C/s               
            if (TMTemperatureData < TMTemperature)
                TMTemperatureData += 10 * elapsedClockSeconds; // 10°C/s                                
            TMTemperatureData = MathHelper.Clamp(TMTemperatureData, 0, 1000);
            TMTemperatureData0 = (float)Math.Round(TMTemperatureData);

            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Teplota TM: " + TMTemperatureData0 + " °C!"));
        }

        public float DRTemperature;
        public float DRTemperatureData;
        public float DRTemperatureData0;
        public float MaxDRTemperatureDegC;
        public float IdleDRTemperatureDegC;
        public float AirDRCoolingPower;
        public bool DRCoolingIsOn;
        public float DRTempTimeConstantSec;
        float DRRunCycle;
        public float DRTempCoef;        
        public void DriveResistance_Temperature(float elapsedClockSeconds)
        {
            if (MaxDRTemperatureDegC == 0) return;

            // Výpočet teploty jízdy na odporu
            float CurrentLoadPercent = MathHelper.Clamp(Math.Max(PowerCurrent1, PowerCurrent2) / MaxCurrentA * 100f, 0, 100);

            if (CoefStepControllerCurves != null)
                DRTempCoef = CoefStepControllerCurves.Get(StepControllerValue, 0);

            DRTempCoef = MathHelper.Clamp(DRTempCoef, 0.1f, 100f);

            // Defaulty
            //if (MaxDRTemperatureDegC == 0) MaxDRTemperatureDegC = 200f;
            if (IdleDRTemperatureDegC == 0) IdleDRTemperatureDegC = 80f;
            if (AirDRCoolingPower == 0) AirDRCoolingPower = 80f;
            if (DRTempTimeConstantSec == 0) DRTempTimeConstantSec = 1500f;

            if (FirstCabLoaded || (DRRunCycle > 0 && DRTemperature == 0))
            {
                DRRunCycle++;
                if (Simulator.Settings.AirEmpty || BrakeSystem.IsAirEmpty)
                    DRTemperature = CarOutsideTempC0;
                else
                    DRTemperature = IdleDRTemperatureDegC;
                return;
            }
            DRRunCycle = 0;
            
            // Fáze zahřívání vlivem zátěže DR
            float DRTemperatureDelta = elapsedClockSeconds * (DRTempCoef * CurrentLoadPercent * 0.01f * (MaxDRTemperatureDegC - IdleDRTemperatureDegC) + IdleDRTemperatureDegC - DRTemperature) * (CurrentLoadPercent * 0.5f) / DRTempTimeConstantSec;
            DRTemperature += MathHelper.Clamp(DRTemperatureDelta, 0, 1f);

            // Přirozené chladnutí vlivem okolního prostředí
            DRTemperature -= MathHelper.Clamp(elapsedClockSeconds * (DRTemperature - CarOutsideTempC0) / (DRTempTimeConstantSec / 5f), 0, 10f);
            //DRTemperature = 420;

            // Ochlazení během aktivního chlazení
            if (DRCoolingIsOn)            
                DRTemperature -= elapsedClockSeconds * (DRTemperature - (1.5f * CarOutsideTempCBase)) / DRTempTimeConstantSec * (AirDRCoolingPower / 500f);                                        

            if (DRTemperatureData > DRTemperature)
                DRTemperatureData -= 20 * elapsedClockSeconds; // 20°C/s               
            if (DRTemperatureData < DRTemperature)
                DRTemperatureData += 10 * elapsedClockSeconds; // 10°C/s                                
            DRTemperatureData = MathHelper.Clamp(DRTemperatureData, 0, 1000);
            DRTemperatureData0 = (float)Math.Round(DRTemperatureData);

            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Teplota DR: " + DRTemperature + " °C!" + "    DRTempCoef: " + DRTempCoef));
        }

        int SituationCoef_1;
        int SituationCoef_2;
        int SituationCoef_3;
        float preSituationCoef_1;        
        float[] RelayDelay = new float[6];
        float SituationTimer_1;
        float SituationTimer_2;
        float SituationTimer_3;
        public void StepControllerSituation(float elapsedClockSeconds)
        {
            if (CoefStepControllerCurves != null)
            {
                SituationCoef_1 = (int)CoefStepControllerCurves.Get(StepControllerValue, 1);
                SituationCoef_2 = (int)CoefStepControllerCurves.Get(StepControllerValue, 2);
                SituationCoef_3 = (int)CoefStepControllerCurves.Get(StepControllerValue, 3);
            }
            else return;
            
            if (SituationCoef_1 != preSituationCoef_1) SituationTimer_1 = 0;
            if (DRTemperature < MaxDRTemperatureDegC) SituationTimer_2 = 0;

            #region Coef 1
            if (SituationCoef_1 == 1) // Relé přechodu ze série na paralel
            {
                if (PowerOn)
                {
                    SituationTimer_1 += elapsedClockSeconds;
                    if (SituationTimer_1 > RelayDelay[1])
                    {
                        HVOff = true;
                        SituationTimer_1 = 0;
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Renegade relay policing the series transition to parallel!"));
                    }
                }                
            }
            #endregion Coef 1

            #region Coef 2
            if (SituationCoef_2 == 1) // Relé teploty odporů
            {
                if (PowerOn && DRTemperature > MaxDRTemperatureDegC)
                {
                    SituationTimer_2 += elapsedClockSeconds;
                    if (SituationTimer_2 > RelayDelay[2])
                    {
                        HVOff = true;
                        SituationTimer_2 = 0;
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Renegade relay temperature protection resistors!"));
                    }
                }
            }
            #endregion Coef 2

            #region Coef 3
            if (SituationCoef_3 == 1) // Relé zapnutí chladících ventilátorů
            {
                if (PowerOn)
                {
                    SituationTimer_3 += elapsedClockSeconds;
                    if (SituationTimer_3 > RelayDelay[3])
                    {
                        if (!DRCoolingIsOn)
                        {
                            DRCoolingIsOn = true;
                            SignalEvent(Event.DRCoolingOn);
                        }
                        SituationTimer_3 = 0;
                        //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Sepnutí relé chladících ventilátorů!"));
                    }
                }
                else
                {
                    if (DRCoolingIsOn)
                    {
                        DRCoolingIsOn = false;
                        SignalEvent(Event.DRCoolingOff);
                    }
                    SituationTimer_3 = 0;
                }
            }
            else
            {
                if (DRCoolingIsOn)
                {
                    DRCoolingIsOn = false;
                    SignalEvent(Event.DRCoolingOff);
                }
                SituationTimer_3 = 0;
            }
            #endregion Coef 3

            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("SituationCoef_1: " + SituationCoef_1 + "    RelayDelay: " + RelayDelay[1]));                
            preSituationCoef_1 = SituationCoef_1;            
        }

        // Icik
        public float I_AuxConsumption = 0;
        public float I_AuxConsumptionData = 0;
        public float I_AuxConsumptionData0 = 0;        
        public float ActualCurrent_CabHeating;
        public float ActualCurrent_Coolings;
        public float ActualCurrent_Compressors;
        public float Current_CabHeating;
        public float Current_TMCoolings;
        public float Current_OthersCoolings;
        public float Current_Compressor1;
        public float Current_Compressor2;
        public float Current_AuxCompressor;
        public void AuxConsumptionOnLocomotive(float elapsedClockSeconds)
        {
            if (!IsLeadLocomotive())
                return;

            ActualCurrent_CabHeating = (PowerOn && CabHeatingIsOn && StatusHeatIsOn ? Current_CabHeating : 0);

            float ActualCurrent_TMCoolings = (PowerOn && TMCoolingIsOn ? Current_TMCoolings : 0);
            float ActualCurrent_OthersCoolings = (PowerOn /*&& OthersCoolingsIsOn*/ ? Current_OthersCoolings : 0);
            ActualCurrent_Coolings = ActualCurrent_TMCoolings + ActualCurrent_OthersCoolings;

            float ActualCurrent_Compressor1 = (PowerOn && CompressorIsOn ? Current_Compressor1 : 0);
            float ActualCurrent_Compressor2 = (PowerOn && Compressor2IsOn ? Current_Compressor2 : 0);
            float ActualCurrent_AuxCompressor = (PowerOn && AuxCompressorIsOn ? Current_AuxCompressor : 0);
            ActualCurrent_Compressors = ActualCurrent_Compressor1 + ActualCurrent_Compressor2 + ActualCurrent_AuxCompressor;

            // Výpočet proudu pomocných pohonů
            I_AuxConsumption = ActualCurrent_CabHeating + ActualCurrent_Coolings + ActualCurrent_Compressors;
            if (I_AuxConsumptionData > I_AuxConsumption)
                I_AuxConsumptionData -= 20 * elapsedClockSeconds; // 20A/s               
            if (I_AuxConsumptionData < I_AuxConsumption)
                I_AuxConsumptionData += 10 * elapsedClockSeconds; // 10A/s                                
            I_AuxConsumptionData = MathHelper.Clamp(I_AuxConsumptionData, 0, 1000);
            I_AuxConsumptionData0 = (float)Math.Round(I_AuxConsumptionData);

            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Proud pomocných pohonů: " + I_AuxConsumption + " A!"));
        }

        // Icik
        public float I_Heating = 0;
        public float I_HeatingData = 0;
        public float I_HeatingData0 = 0;
        public float U_Heating = 3000;
        public bool HeatingOverCurrent = false;
        public bool HeatingIsOn = false;
        public float MSGHeatingCycle;        
        public void ElevatedConsumptionOnLocomotive(float elapsedClockSeconds)
        {
            foreach (TrainCar car in Train.Cars)
            {
                if (car is MSTSLocomotive)
                {
                    if (car.CabHeating_OffOn[LocoStation] && AuxPowerOn)
                        car.CabHeatingIsOn = true;
                    if (!car.CabHeating_OffOn[LocoStation] || !AuxPowerOn)
                        car.CabHeatingIsOn = false;
                }
            }

            // Spustí zvuk topení v kabině při inicializaci loko
            if (CabHeating_OffOn[LocoStation] && !CarCabHeatingIsSetOn)
            {
                SignalEvent(Event.CabHeating_OffOnOn);
                CarCabHeatingIsSetOn = true;
            }
            // Deaktivuje vytápění stanoviště při shozeném jističi topení nebo baterií
            if (CabHeating_OffOn[LocoStation] && (!BrakeSystem.HeatingIsOn || !Battery) && !DieselDirectionController && !DieselDirectionController2)
            {
                CabHeating_OffOn[LocoStation] = false;                
                SignalEvent(Event.CabHeating_OffOnOff);
            }            

            // Ochrana při nadproudu topení/klimatizace jen pro hráče
            if (IsLeadLocomotive())
            {                
                // Maximální proud topení            
                if (HeatingMaxCurrentA == 0)
                    HeatingMaxCurrentA = 130; // Default 130A

                if ((Heating_OffOn[LocoStation] && !HeatingOverCurrent && AuxPowerOn && StationIsActivated[LocoStation]) || Train.CarSteamHeatOn)
                    HeatingIsOn = true;
                if ((!Heating_OffOn[LocoStation] || HeatingOverCurrent || !AuxPowerOn) && !Train.CarSteamHeatOn)
                {
                    if (HeatingIsOn)                    
                        SignalEvent(Event.Heating_OffOnOff);                    
                    if (I_HeatingData > 0)
                        I_HeatingData -= 50 * elapsedClockSeconds; // 50A/s
                    HeatingIsOn = false;                    
                }

                if (HeatingOverCurrent)
                {
                    if (I_HeatingData > 0)
                        I_HeatingData -= 50 * elapsedClockSeconds; // 50A/s
                    SignalEvent(Event.HeatingOverCurrentOn);
                }
                else
                    SignalEvent(Event.HeatingOverCurrentOff);

                if (!Heating_OffOn[LocoStation])
                    HeatingOverCurrent = false;

                I_HeatingData0 = (float)Math.Round(I_HeatingData);
                I_Heating = I_HeatingData;
            }

            // Počítání teplot proběhne každý desátý cyklus 
            if (Simulator.GameTimeCyklus10 == 10 && IsLeadLocomotive())
            {
                foreach (TrainCar car in Train.Cars)
                {
                    // Označí kabinu lokomotivy
                    if (!car.HasPassengerCapacity && car.WagonType == WagonTypes.Engine)
                        car.LocomotiveCab = true;

                    if (car.WagonType == WagonTypes.Passenger || car.HasPassengerCapacity || car.WagonType == WagonTypes.Engine)
                    {
                        if (car.WagonType == WagonTypes.Passenger)
                            car.HasPassengerCapacity = true;

                        // Defaulty
                        if (!car.WagonHasTemperature && Simulator.GameTime > 1 || car.CarOutsideTempCLastStatus != car.CarOutsideTempC)
                        {
                            if (car.WagonType == WagonTypes.Engine)
                            {
                                // Motorové vozy
                                if (car.HasPassengerCapacity)
                                {
                                    if (car.CarLengthM <= 10)
                                    {
                                        if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 20.0f * 1000;   // 20kW                    
                                        if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 5; // 10l/h                                            
                                    }
                                    if (car.CarLengthM > 10 && car.CarLengthM <= 20)
                                    {
                                        if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 30.0f * 1000;   // 30kW
                                        if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 10; // 10l/h
                                    }
                                    if (car.CarLengthM > 20)
                                    {
                                        if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 50.0f * 1000;   // 50kW
                                        if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 14; // 14l/h                                            
                                    }
                                }
                                else
                                // Lokomotivy
                                {
                                    if (car.CarLengthM <= 10)
                                    {
                                        if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 10.0f * 1000;   // 10kW                    
                                        if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 2; // 2l/h
                                    }
                                    if (car.CarLengthM > 10)
                                    {
                                        if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 15.0f * 1000;   // 15kW
                                        if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 3; // 3l/h
                                    }
                                }
                            }
                            else
                            {
                                // Vozy
                                if (car.CarLengthM <= 10)
                                {
                                    if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 20.0f * 1000;   // 20kW
                                    if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 5; // 7l/h
                                    if (car.DieselHeaterTankCapacity == 0) car.DieselHeaterTankCapacity = 30; // 30l
                                }
                                if (car.CarLengthM > 10 && car.CarLengthM <= 20)
                                {
                                    if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 30.0f * 1000;   // 30kW
                                    if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 10; // 10l/h
                                    if (car.DieselHeaterTankCapacity == 0) car.DieselHeaterTankCapacity = 50; // 50l
                                }
                                if (car.CarLengthM > 20)
                                {
                                    if (car.PowerReductionByHeating == 0) car.PowerReductionByHeating = 50.0f * 1000;   // 50kW
                                    if (car.DieselHeaterConsumptionPerHour == 0) car.DieselHeaterConsumptionPerHour = 14; // 14l/h
                                    if (car.DieselHeaterTankCapacity == 0) car.DieselHeaterTankCapacity = 70; // 70l
                                }
                            }

                            car.PowerReductionByHeating = MathHelper.Clamp(car.PowerReductionByHeating, 0, 50.0f * 1000);
                            car.PowerReductionByAirCondition = MathHelper.Clamp(car.PowerReductionByAirCondition, 0, 50.0f * 1000);

                            // Zapne jednotky topení/klimy 
                            if (!Simulator.Settings.AirEmpty)
                            {
                                car.BrakeSystem.HeatingIsOn = true;
                                car.BrakeSystem.HeatingMenu = 0;

                                if (car.WagonHasStove)
                                {
                                    car.BrakeSystem.HeatingIsOn = false;
                                    car.BrakeSystem.HeatingMenu = 1;
                                    if (car.CarOutsideTempC < 20)
                                    {
                                        car.BrakeSystem.HeatingIsOn = true;
                                        car.BrakeSystem.HeatingMenu = 0;
                                    }
                                }
                            }

                            // Vozy nikdy nebudou startovat podchlazené pod 5°C                                                        
                            if (car.CarOutsideTempC < 5 && !car.WagonHasTemperature)
                            {
                                car.WagonTemperature = Simulator.Random.Next(5, 10);
                                car.CarOutsideTempC0 = car.WagonTemperature;
                                // Parní lokomotiva
                                if (car is MSTSSteamLocomotive)
                                {                                    
                                    car.WagonTemperature += 15f;
                                    car.SteamLocoCabTemperatureBase = car.WagonTemperature;
                                }
                            }
                            else
                            if (!car.WagonHasTemperature)
                            {
                                car.WagonTemperature = Simulator.Random.Next((int)car.CarOutsideTempC - 2, (int)car.CarOutsideTempC + 2);
                                car.CarOutsideTempC0 = car.WagonTemperature;
                                // Parní lokomotiva
                                if (car is MSTSSteamLocomotive)
                                {                                    
                                    car.WagonTemperature += 15f;
                                    car.SteamLocoCabTemperatureBase = car.WagonTemperature;
                                }
                            }
                            else
                                car.CarOutsideTempC0 = car.CarOutsideTempC;

                            car.CarOutsideTempC0 = MathHelper.Clamp(car.CarOutsideTempC0, 5, 50);
                            
                            // Natopené vozy, oživená loko
                            if (BrakeSystem.IsAirFull && !car.WagonHasTemperature)
                            {
                                if (Simulator.Season == SeasonType.Summer)
                                    car.WagonTemperature = Simulator.Random.Next(24, 29);
                                else
                                    car.WagonTemperature = Simulator.Random.Next(18, 23);
                                // Parní lokomotiva
                                if (car is MSTSSteamLocomotive && !car.WagonHasTemperature)
                                {                                    
                                    car.WagonTemperature += 10f;
                                    car.SteamLocoCabTemperatureBase = car.WagonTemperature;
                                }
                            }                            

                            car.WagonHasTemperature = true;
                            car.CarOutsideTempCLastStatus = car.CarOutsideTempC;
                        }

                        //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Teplota " + car.CarOutsideTempC0));


                        float TempStepUp = 200;
                        float TempStepDown = 300;
                        float TempStepUpSlow = 100;
                        float TempStepDownSlow = 100;
                        float TempCDeltaOutside;
                        float CarAirVolumeM3;

                        // Výpočet objemu vzduchu ve vozech
                        CarAirVolumeM3 = car.CarWidthM * car.CarLengthM * (car.CarHeightM - 1.06f);

                        // Výpočet objemu vzduchu v lokomotivách
                        if (car.WagonType == WagonTypes.Engine && !HasPassengerCapacity)
                        {
                            CarAirVolumeM3 = car.CarWidthM * 1.5f * (car.CarHeightM - 1.06f);
                            TempStepUp = 1000;
                            TempStepDown = 3000;
                            TempStepUpSlow = 10;
                            TempStepDownSlow = 10;
                        }

                        // Vliv otevření dveří u vozů
                        if (car.BrakeSystem.LeftDoorIsOpened)
                        {
                            TempStepUpSlow += 75;
                            TempStepDownSlow += 75;
                        }
                        if (car.BrakeSystem.RightDoorIsOpened)
                        {
                            TempStepUpSlow += 75;
                            TempStepDownSlow += 75;
                        }

                        // Ochlazování a oteplování vlivem protékajícího vzduchu a okolní teploty
                        TempCDeltaOutside = car.WagonTemperature / car.CarOutsideTempC0 / 5;
                        if (car.AbsSpeedMpS > 0 && car.WagonTemperature > car.CarOutsideTempC0 * (1 - (car.AbsSpeedMpS / (250 / 3.6f))))
                            car.TempCDeltaAir = -TempStepDownSlow / CarAirVolumeM3 * TempCDeltaOutside * (1 + (1 - (car.AbsSpeedMpS / (250 / 3.6f)))) * elapsedClockSeconds;
                        else
                        if (car.AbsSpeedMpS > 0 && car.WagonTemperature < car.CarOutsideTempC0 * (1 - (car.AbsSpeedMpS / (250 / 3.6f))))
                            car.TempCDeltaAir = +TempStepUpSlow / CarAirVolumeM3 * TempCDeltaOutside * (1 - (car.AbsSpeedMpS / (250 / 3.6f))) * elapsedClockSeconds;
                        else
                        if (car.AbsSpeedMpS == 0 && car.WagonTemperature < car.CarOutsideTempC0 * 1.05f)
                            car.TempCDeltaAir = +TempStepUpSlow / CarAirVolumeM3 * TempCDeltaOutside * elapsedClockSeconds;
                        else
                        if (car.AbsSpeedMpS == 0 && car.WagonTemperature > car.CarOutsideTempC0)
                            car.TempCDeltaAir = -TempStepDownSlow / CarAirVolumeM3 * TempCDeltaOutside * elapsedClockSeconds;
                        else
                            car.TempCDeltaAir = 0;

                        // Topení
                        if (Simulator.Season == SeasonType.Spring || Simulator.Season == SeasonType.Autumn || Simulator.Season == SeasonType.Winter)
                        {
                            float SetTempCHyst = 3.5f;
                            //TempCDeltaOutside = car.CarOutsideTempC0 / car.WagonTemperature;

                            if (car.SetTemperatureC == 0)
                            {
                                car.SetTemperatureC = Simulator.Random.Next(19, 27);
                                car.SetTempCThreshold = car.SetTemperatureC;
                            }

                            MSGHeatingCycle++;
                            if (MSGHeatingCycle > 500 && car.WagonTemperature < 14)
                            {
                                if (car.WagonType == WagonTypes.Engine && !car.HasPassengerCapacity && WagonTemperature < 14)
                                    Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("You're cold!"));
                                else
                                    if (car.PassengerList.Count > 0)
                                    Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("The passengers are cold!"));
                                MSGHeatingCycle = 0;
                            }
                            // Termostat vypnutý, topení aktivní
                            if (((!car.LocomotiveCab && HeatingIsOn) || car.DieselHeaterPower > 0 || (car.LocomotiveCab && car.CabHeatingIsOn)) && car.WagonTemperature < car.SetTempCThreshold && !car.ThermostatOn)
                            {
                                car.TempCDelta = +car.PowerReductionByHeating0 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                                if (car.DieselHeaterPower > 0)
                                    car.TempCDelta = +car.DieselHeaterPower0 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                                if (car.WagonTemperature > car.SetTempCThreshold - 0.1f)
                                    car.ThermostatOn = true;
                                car.StatusHeatIsOn = true;
                            }
                            else
                            {
                                // Termostat zapnutý, topení neaktivní                        
                                car.TempCDelta = 0;
                                if (car.WagonTemperature < car.SetTempCThreshold - SetTempCHyst)
                                    car.ThermostatOn = false;
                                car.StatusHeatIsOn = false;
                            }
                        }

                        // Klimatizace
                        if (Simulator.Season == SeasonType.Summer)
                        {
                            float SetTempCHyst = 2.5f;
                            TempCDeltaOutside = car.WagonTemperature / car.CarOutsideTempC;

                            if (car.SetTemperatureC == 0)
                            {
                                car.SetTemperatureC = Simulator.Random.Next(17, 25);
                                car.SetTempCThreshold = car.SetTemperatureC;
                            }

                            MSGHeatingCycle++;
                            if (MSGHeatingCycle > 1000 && car.WagonTemperature > 30)
                            {
                                if (car.WagonType == WagonTypes.Engine && !car.HasPassengerCapacity && WagonTemperature > 30)
                                    Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("You're hot!"));
                                else
                                    if (car.PassengerList.Count > 0)
                                    Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Passengers are too hot!"));
                                MSGHeatingCycle = 0;
                            }
                            // Termostat vypnutý, klimatizace aktivní
                            if (((!car.LocomotiveCab && HeatingIsOn) || (car.LocomotiveCab && car.CabHeatingIsOn)) && car.WagonTemperature > car.SetTempCThreshold && !car.ThermostatOn && car.PowerReductionByAirCondition > 0)
                            {
                                car.TempCDelta = -car.PowerReductionByAirCondition0 / TempStepDown / CarAirVolumeM3 * elapsedClockSeconds;
                                if (car.WagonTemperature < car.SetTempCThreshold + 0.1f)
                                    car.ThermostatOn = true;
                                car.StatusHeatIsOn = true;
                            }
                            else
                            {
                                // Termostat zapnutý, klimatizace neaktivní  
                                car.TempCDelta = 0;
                                if (car.WagonTemperature > car.SetTempCThreshold + SetTempCHyst)
                                    car.ThermostatOn = false;
                                car.StatusHeatIsOn = false;
                            }
                        }

                        // Kamna
                        float StovePowerKW = 10;
                        if (car.CarOutsideTempC0 < 0) StovePowerKW = 35;
                        if (car.CarOutsideTempC0 >= 0) StovePowerKW = 30;
                        if (car.CarOutsideTempC0 >= 10) StovePowerKW = 20;
                        if (car.CarOutsideTempC0 >= 15) StovePowerKW = 10;
                        if (car.WagonHasStove && car.BrakeSystem.HeatingIsOn)
                        {
                            if (car.WagonTemperature > 1.10f * car.SetTempCThreshold)
                                car.TempCDelta = +StovePowerKW * 0 * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                            else
                            if (car.WagonTemperature > 1.05f * car.SetTempCThreshold)
                                car.TempCDelta = +StovePowerKW * 0.25f  * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                            else
                            if (car.WagonTemperature > 1.0f * car.SetTempCThreshold)                            
                                car.TempCDelta = +StovePowerKW * 0.5f * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;                            
                            else
                            if (car.WagonTemperature < 0.90f * car.SetTempCThreshold)
                                car.TempCDelta = +StovePowerKW * 1.0f * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                            else
                                car.TempCDelta = +StovePowerKW * 0.75f * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                            car.WagonTemperature += car.TempCDelta + car.TempCDeltaAir;
                        }
                        else
                        // Parní topení počítá teplotu svým algoritmem
                        if ((Train.CarSteamHeatOn && !car.WagonHasStove) && !car.LocomotiveCab)
                            car.WagonTemperature += car.CarCurrentCarriageHeatDeltaTempC + car.TempCDeltaAir;
                        else
                            car.WagonTemperature += car.TempCDelta + car.TempCDeltaAir;

                        // Parní lokomotiva
                        if (car is MSTSSteamLocomotive && car.WagonTemperature < car.SteamLocoCabTemperatureBase)
                        {
                            float BoilerPowerKW = 10;
                            if (Simulator.Season == SeasonType.Winter)
                                car.WagonTemperature += BoilerPowerKW * 1.5f * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds;
                            else
                                car.WagonTemperature += (BoilerPowerKW * 1.0f * 1000 / TempStepUp / CarAirVolumeM3 * elapsedClockSeconds) + car.TempCDeltaAir;
                            
                            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Teplota " + car.WagonTemperature));
                        }
                    }
                    //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Teplota " + car.WagonTemperature));
                }
            }

            // Bufík
            if (Simulator.GameTimeCyklus10 == 10)
            {
                foreach (TrainCar car in Train.Cars)
                {
                    var mstsDieselLocomotive = car as MSTSDieselLocomotive;
                    if (car.DieselHeaterPower > 0 && (car.DieselHeaterTankCapacity > 2 || mstsDieselLocomotive != null && mstsDieselLocomotive.DieselLevelL > 0))
                    {
                        if (car.DieselHeaterTankCapacity == 0 && mstsDieselLocomotive != null)
                            car.DieselHeaterTankCapacityMark = mstsDieselLocomotive.DieselLevelL;
                        else
                            car.DieselHeaterTankCapacityMark = car.DieselHeaterTankCapacity;

                        car.PowerReductionByHeating0 = 0;
                        car.PowerReductionByAirCondition0 = 0;
                        if (!car.BrakeSystem.HeatingIsOn) // Pokud má vůz vypnutý bufík
                        {
                            car.DieselHeaterPower0 = 0;
                            car.DieselHeaterConsumptionPerHour0 = 0;
                            car.StatusHeatIsOn = false;
                        }
                        else
                        {   // Bufík je zapnutý a aktivní (termostat vypnutý)                            
                            if (car.StatusHeatIsOn)
                            {
                                car.DieselHeaterPower0 = car.DieselHeaterPower;
                                car.DieselHeaterConsumptionPerHour0 = car.DieselHeaterConsumptionPerHour;
                                // Motorové vozy a lokomotivy
                                if (car.DieselHeaterTankCapacity == 0 && mstsDieselLocomotive != null)
                                {
                                    mstsDieselLocomotive.DieselLevelL -= car.DieselHeaterConsumptionPerHour0 * elapsedClockSeconds / 3600;
                                    if (mstsDieselLocomotive.DieselLevelL < 0f) mstsDieselLocomotive.DieselLevelL = 0f;
                                }
                                else
                                // Vozy                                
                                {
                                    car.DieselHeaterTankCapacity -= car.DieselHeaterConsumptionPerHour0 * elapsedClockSeconds / 3600;
                                    if (car.DieselHeaterTankCapacity < 2f) car.DieselHeaterTankCapacity = 2f;
                                }
                            }
                        }

                        if (!car.StatusHeatIsOn) // Pokud je bufík neaktivní (termostat zapnutý)
                        {
                            car.DieselHeaterPower0 = 0;
                            car.DieselHeaterConsumptionPerHour0 = 0;
                        }
                    }
                }
            }

            // Elektrické topení a klimatizace
            PowerReductionByHeatingSum = 0;
            if (HeatingIsOn || this.CabHeatingIsOn)
            {
                PowerReductionByHeatingWag = 0;

                foreach (TrainCar car in Train.Cars)
                {
                    var mstsDieselLocomotive = car as MSTSDieselLocomotive;
                    if (!car.BrakeSystem.HeatingIsOn) // Pokud má vůz vypnuté topení nebo klimatizaci
                    {
                        car.PowerReductionByHeating0 = 0;
                        car.PowerReductionByAirCondition0 = 0;
                        car.StatusHeatIsOn = false;
                    }
                    else
                    {   // Jednotka je zapnutá a aktivní (termostat vypnutý)
                        if (car.LocomotiveCab && car.DieselHeaterPower == 0 && car is MSTSDieselLocomotive)
                        {
                            // Kalorifer
                            if (mstsDieselLocomotive.DieselEngines[0].DieselIdleWaterTemperatureDegC != 0)
                                mstsDieselLocomotive.DieselEngines[0].DieselIdleTemperatureDegC = mstsDieselLocomotive.DieselEngines[0].DieselIdleWaterTemperatureDegC;
                            car.PowerReductionByHeating0 = 0.85f * car.PowerReductionByHeating * mstsDieselLocomotive.DieselEngines[0].RealDieselWaterTemperatureDeg / mstsDieselLocomotive.DieselEngines[0].DieselIdleTemperatureDegC;
                        }
                        else
                            car.PowerReductionByHeating0 = car.PowerReductionByHeating;
                        car.PowerReductionByAirCondition0 = car.PowerReductionByAirCondition;
                    }

                    if (!car.StatusHeatIsOn) // Pokud je jednotka neaktivní (termostat zapnutý)
                    {
                        car.PowerReductionByHeating0 = 0;
                        car.PowerReductionByAirCondition0 = 0;
                    }

                    if (!car.LocomotiveCab && car.DieselHeaterPower == 0)
                    {
                        if (Simulator.Season == SeasonType.Summer)
                            PowerReductionByHeatingWag += car.PowerReductionByAirCondition0; // Klimatizace
                        else
                            PowerReductionByHeatingWag += car.PowerReductionByHeating0; // Topení                        
                    }

                    PowerReductionResult3 = 0;
                    if (I_HeatingData > HeatingMaxCurrentA && IsPlayerTrain)
                    {
                        if (car.WagonType == WagonTypes.Engine && this is MSTSDieselLocomotive)
                        {
                            PowerReductionResult3 = 0.9f;
                            HeatingOverCurrent = true;
                            Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Overcurrent heating/air conditioning protection!"));
                        }
                        if (car.WagonType == WagonTypes.Engine && this is MSTSElectricLocomotive)
                        {
                            HVOff = true;
                            HeatingOverCurrent = true;
                            Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Overcurrent heating/air conditioning protection!"));
                        }
                    }
                }

                PowerReductionByHeatingSum = PowerReductionByHeatingWag;

                if (IsLeadLocomotive())
                {
                    // Výpočet proudu při zapnutí topení nebo klimatizace
                    I_Heating = (float)Math.Round((PowerReductionByHeatingSum + PowerReductionByAuxEquipmentSum) / U_Heating);
                    if (I_HeatingData > I_Heating)
                        I_HeatingData -= 20 * elapsedClockSeconds; // 20A/s               
                    if (I_HeatingData < I_Heating)
                        I_HeatingData += 10 * elapsedClockSeconds; // 10A/s                                
                    I_HeatingData = MathHelper.Clamp(I_HeatingData, 0, 1000);
                    I_HeatingData0 = (float)Math.Round(I_HeatingData0);

                    //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Příkon topení/klimatizace " + PowerReductionByHeatingSum / 1000 + " kW" + "   Proud " + I_HeatingData0 + " A!"));
                    //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Zapnuté topení, výkon zredukován " + PowerReductionByHeatingSum * MaxPowerW / 1000) + " kW!");
                }
            }

            TElevatedConsumption = 1;
            PowerReductionByAuxEquipmentWag = 0;
            PowerReductionByAuxEquipmentEng = 0;
            PowerReductionByAuxEquipmentSum = 0;

            if (AuxPowerOn)
            {
                if (Heating_OffOn[LocoStation])
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car.WagonType == WagonTypes.Passenger) // Osobní vozy
                        {
                            //if (car.PowerReductionByAuxEquipment == 0) car.PowerReductionByAuxEquipment = 5 * 1000; // Default 5kW
                            PowerReductionByAuxEquipmentWag += car.PowerReductionByAuxEquipment;
                        }
                        if (car.WagonType == WagonTypes.Engine) // Lokomotivy
                        {
                            PowerReductionByAuxEquipmentEng += car.PowerReductionByAuxEquipment;
                        }
                    }
                }
                // I.Compressor
                if (/*WagonType == WagonTypes.Engine && this is MSTSDieselLocomotive &&*/ CompressorIsOn) // Lokomotivy
                {
                    if (AirBrakesIsCompressorElectricOrMechanical)
                        if (AirBrakesAirCompressorWattage == 0) AirBrakesAirCompressorWattage = 35000f; // 35kW Mechanický kompresor
                        else
                        if (AirBrakesAirCompressorWattage == 0) AirBrakesAirCompressorWattage = 25000f; // 25kW Elektrický kompresor
                    PowerReductionByAuxEquipmentEng += AirBrakesAirCompressorWattage;
                }
                // II.Compressor
                if (/*WagonType == WagonTypes.Engine && this is MSTSDieselLocomotive &&*/ Compressor2IsOn) // Lokomotivy
                {
                    if (AirBrakesIsCompressorElectricOrMechanical)
                        if (AirBrakesAirCompressorWattage == 0) AirBrakesAirCompressorWattage = 35000f; // 35kW Mechanický kompresor
                        else
                        if (AirBrakesAirCompressorWattage == 0) AirBrakesAirCompressorWattage = 25000f; // 25kW Elektrický kompresor
                    PowerReductionByAuxEquipmentEng += AirBrakesAirCompressorWattage;
                }
                // Pomocný kompresor
                if (/*WagonType == WagonTypes.Engine && this is MSTSDieselLocomotive &&*/ AuxCompressorIsOn) // Lokomotivy
                {
                    AirBrakesAirCompressorWattage = 5000f; // 5kW Elektrický kompresor
                    PowerReductionByAuxEquipmentEng += AirBrakesAirCompressorWattage;
                }
                PowerReductionByAuxEquipmentSum = PowerReductionByAuxEquipmentWag + PowerReductionByAuxEquipmentEng;
            }

            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Zvýšený odběr proudu, výkon zredukován "+ PowerReductionByAuxEquipmentSum * MaxPowerW/1000) + " kW!");                        

            if (IsLeadLocomotive() || PowerReductionByAuxEquipmentSum >= 0)
            {
                if (WagonType == WagonTypes.Engine && this is MSTSElectricLocomotive) // Elektrické lokomotivy
                {
                    //PowerReduction = PowerReduction0;
                    return;
                }

                if (WagonType == WagonTypes.Engine && this is MSTSDieselLocomotive && !Train.CarSteamHeatOn) // Diesel lokomotivy
                {
                    // Výpočet celkového úbytku výkonu 
                    if (MaxPowerW == 0) MaxPowerW = 1000000f; // Default pro výkon, který nesmí být 0kW
                    PowerReductionResult1 = (PowerReductionByHeatingSum + PowerReductionByAuxEquipmentSum) * (1000000f / MaxPowerW);
                    PowerReductionResult1 /= 1000000f;
                    PowerReductionResult1 = MathHelper.Clamp(PowerReductionResult1, 0, 1);
                }
            }
        }

        // Stanovení hodnot výkonů a síly pro AC-DC systém
        public void MaxPower_MaxForce_ACDC()
        {
            switch (SwitchingVoltageMode)
            {
                case 0:
                    if (MaxPowerWDC != 0)
                        MaxPowerW = MaxPowerWDC;
                    if (MaxForceNDC != 0)
                        MaxForceN = MaxForceNDC;
                    break;
                case 1:
                    break;
                case 2:
                    if (MaxPowerWAC != 0)
                        MaxPowerW = MaxPowerWAC;
                    if (MaxForceNAC != 0)
                        MaxForceN = MaxForceNAC;
                    break;
            }
        }

        public bool NoAuxCompressor;
        public void SetDefault_AuxCompressor()
        {
            // Netěsnost pomocné jímky pomocného kompresoru 0.002 bar/s
            if (AuxResPipeLeak == 0)
                AuxResPipeLeak = 0.002f * 14.50377f;

            // Velikost jímky pomocného kompresoru
            if (AuxResVolumeM3 == 0)
            {
                AuxResVolumeM3 = 60.0f / 1000f; // 60 L
                NoAuxCompressor = true;
            }

            // Maximální rychlost plnění jímky pomocným kompresorem
            if (AuxResChargingRatePSIpS == 0)
                AuxResChargingRatePSIpS = 0.027f * 14.50377f; // 0.027 bar/s 

            // Vícesystémové lokomotivy
            if (MultiSystemEngine)
            {
                // Maximální tlak v jímce pomocného kompresoru 
                if (MaxAuxResPressurePSI == 0)
                    MaxAuxResPressurePSI = 5.0f * 14.50377f; // 5 barů                                        

                // Hodnota pro restart pomocného kompresoru
                //if (AuxCompressorRestartPressurePSI == 0)
                //    AuxCompressorRestartPressurePSI = 4.5f * 14.50377f; // 4.5 barů

                // Minimální hodnota tlaku pro chod pantografu
                if (MinAuxPressurePantoPSI == 0)
                    MinAuxPressurePantoPSI = 4.4f * 14.50377f; // 4.4 barů

                // Minimální hodnota tlaku pro chod HV
                if (MinAuxPressureHVPSI == 0)
                    MinAuxPressureHVPSI = 4.2f * 14.50377f; // 4.2 barů                               
            }

            else
            // Jednosystémové lokomotivy
            {
                if (LocomotivePowerVoltage == 3000)
                {
                    // Maximální tlak v jímce pomocného kompresoru 
                    if (MaxAuxResPressurePSI == 0)
                        MaxAuxResPressurePSI = 5.0f * 14.50377f; // 5 barů                        

                    // Hodnota pro restart pomocného kompresoru
                    //if (AuxCompressorRestartPressurePSI == 0)
                    //    AuxCompressorRestartPressurePSI = 4.5f * 14.50377f; // 4.5 barů

                    // Minimální hodnota tlaku pro chod pantografu
                    if (MinAuxPressurePantoPSI == 0)
                        MinAuxPressurePantoPSI = 4.4f * 14.50377f; // 4.4 barů

                    // Minimální hodnota tlaku pro chod HV
                    if (MinAuxPressureHVPSI == 0)
                        MinAuxPressureHVPSI = 4.2f * 14.50377f; // 4.2 barů                    
                }
                if (LocomotivePowerVoltage > 3000)
                {
                    // Maximální tlak v jímce pomocného kompresoru 
                    if (MaxAuxResPressurePSI == 0)
                        MaxAuxResPressurePSI = 7.0f * 14.50377f; // 7 barů

                    // Hodnota pro restart pomocného kompresoru
                    //if (AuxCompressorRestartPressurePSI == 0)
                    //    AuxCompressorRestartPressurePSI = 5.5f * 14.50377f; // 5.5 barů

                    // Minimální hodnota tlaku pro chod pantografu
                    if (MinAuxPressurePantoPSI == 0)
                        MinAuxPressurePantoPSI = 5.8f * 14.50377f; // 5.8 barů

                    // Minimální hodnota tlaku pro chod HV
                    if (MinAuxPressureHVPSI == 0)
                        MinAuxPressureHVPSI = 5.0f * 14.50377f; // 5.0 barů                    
                }
            }
        }
        public void RDSTBreakerType()
        {
            int RDSTBreakerRDSTState = 0;
            int RDSTBreakerVZState = 0;
            int RDSTBreakerPowerState = 0;

            if (RDSTBreakerRDSTEnable && Battery && !EmergencyButtonPressed)
            {
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && (!car.RDSTBreaker[1] && !car.RDSTBreaker[2]))
                        RDSTBreakerRDSTState += 1;
                }
                if (RDSTBreakerRDSTState > 0)
                    TrainBrakeController.EmergencyBrakingPushButton = true;
                else
                    TrainBrakeController.EmergencyBrakingPushButton = false;
            }
            if (RDSTBreakerVZEnable && Battery && !EmergencyButtonPressed)
            {
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && (!car.RDSTBreaker[1] && !car.RDSTBreaker[2]))
                        RDSTBreakerVZState += 1;
                }
                if (RDSTBreakerVZState > 0)
                {
                    TrainBrakeController.EmergencyBrakingPushButton = true;
                    // Mirel
                    Mirel.Test1 = false;
                    Mirel.Test2 = false;
                    Mirel.Test3 = false;
                    Mirel.Test4 = false;
                    Mirel.Test5 = false;
                    Mirel.Test6 = false;
                    Mirel.Test7 = false;
                    Mirel.initTest = SubSystems.Mirel.InitTest.Off;
                    Mirel.BlueLight = false;
                    Mirel.selectedDriveMode = SubSystems.Mirel.DriveMode.Off;
                    Mirel.driveMode = SubSystems.Mirel.DriveMode.Off;
                    Mirel.MaxSelectedSpeed = Mirel.MirelMaximumSpeed = MpS.ToKpH(MaxSpeedMpS);
                    // LS90
                    Mirel.ls90tested = false;
                    Mirel.Ls90power[LocoStation] = SubSystems.Mirel.LS90power.Off;
                }
                else
                    TrainBrakeController.EmergencyBrakingPushButton = false;
            }
            if (RDSTBreakerPowerEnable && Battery)
            {
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && (!car.RDSTBreaker[1] && !car.RDSTBreaker[2]))
                        RDSTBreakerPowerState += 1;
                }
                if (RDSTBreakerPowerState > 0)
                    PowerReductionResult8 = 1;
                else
                    PowerReductionResult8 = 0;
            }
        }

        // AI akce pro definici světel a písknutí při posunu
        float AIBellTimer;
        float AITimerStart;
        bool AIStartOn;
        bool AIBellStartOn;
        bool CarIsWaitingAtStation;        
        public void SetAIAction(float elapsedClockSeconds)
        {
            if ((Train as AITrain) != null && (this as MSTSLocomotive) != null)
            {
                CarIsWaiting = false;
                if (((this as MSTSElectricLocomotive) != null && (this as MSTSElectricLocomotive).AIPantoDownStop)
                    || ((this as MSTSDieselLocomotive) != null && (this as MSTSDieselLocomotive).AIMotorStop)
                    || (this as MSTSLocomotive).LocoIsStatic)
                {
                    if (this.BrakeSystem.PowerForWagon == true)
                    {
                        foreach (TrainCar car in (Train as AITrain).Cars)
                        {
                            car.BrakeSystem.PowerForWagon = false;
                            PowerOn = false;
                        }
                    }
                }
                else
                {
                    if (this.BrakeSystem.PowerForWagon == false)
                    {
                        foreach (TrainCar car in (Train as AITrain).Cars)
                        {
                            car.BrakeSystem.PowerForWagon = true;
                            PowerOn = true;
                        }
                    }
                }

                // Parní lokomotivy nevypínají motor :)
                if (this as MSTSSteamLocomotive != null && !(this as MSTSLocomotive).LocoIsStatic)
                {
                    this.BrakeSystem.PowerForWagon = true;
                    PowerOn = true;
                }

                // AI je ve stanici nebo stojí
                if ((Train as AITrain).MovementState == AITrain.AI_MOVEMENT_STATE.STATION_STOP
                    || (Train as AITrain).MovementState == AITrain.AI_MOVEMENT_STATE.STOPPED
                    || (Train as AITrain).MovementState == AITrain.AI_MOVEMENT_STATE.SUSPENDED)
                    CarIsWaiting = true;

                // AI je ve stanici
                if ((Train as AITrain).MovementState == AITrain.AI_MOVEMENT_STATE.STATION_STOP)
                    CarIsWaitingAtStation = true;

                if ((Train as AITrain) != null && (Train as AITrain).nextActionInfo != null)
                {
                    if ((Train as AITrain).nextActionInfo.GetType().IsSubclassOf(typeof(AuxActionItem)))
                    {
                        if ((Train as AITrain).AuxActionsContain[0] != null && ((AIAuxActionsRef)(Train as AITrain).AuxActionsContain[0]).NextAction == AuxActionRef.AUX_ACTION.WAITING_POINT)
                        {
                            var AIActionPoint0 = ((Train as AITrain).AuxActionsContain.SpecAuxActions[0] as AIActionWPRef);
                            if (AIActionPoint0.Delay < 40000 && CarIsShunting && Math.Abs((Train as AITrain).SpeedMpS) > 0)
                                CarIsRunning = true;
                            if (AIActionPoint0.Delay < 40000 && CarIsRunning && (Train as AITrain).SpeedMpS == 0)
                                CarIsWaiting = true;
                        }
                    }
                }

                if (CarIsWaiting)
                {
                    CarIsShunting = false;
                    CarIsRunning = false;
                }

                // AI posunuje                     
                if ((Train as AITrain) != null && (Train as AITrain).nextActionInfo != null)
                {
                    if ((Train as AITrain).nextActionInfo.GetType().IsSubclassOf(typeof(AuxActionItem)))
                    {
                        if ((Train as AITrain).AuxActionsContain[0] != null && ((AIAuxActionsRef)(Train as AITrain).AuxActionsContain[0]).NextAction == AuxActionRef.AUX_ACTION.WAITING_POINT)
                        {
                            var AIActionPoint0 = ((Train as AITrain).AuxActionsContain.SpecAuxActions[0] as AIActionWPRef);
                            if ((AIActionPoint0.Delay > 40000 && AIActionPoint0.Delay < 60010) || (Train as AITrain).AITrainWillAttach)
                            {
                                CarIsShunting = true;
                                AIStartOn = true;
                            }
                            else
                            {
                                AIStartOn = false;
                                AIBellStartOn = false;
                            }
                        }
                    }
                }

                // AI zapíská
                if (AIStartOn && !AIBellStartOn && this.ThrottlePercent > 0.0f)
                {
                    if (!(Train as AITrain).AITrainWillAttach)
                        AITimerStart += elapsedClockSeconds;
                    if (AIBellTimer == 0.0f && (Train as AITrain).Name != (Train as AITrain).AITrainNameShunting) 
                        SignalEvent(Event.BellOn);
                    (Train as AITrain).AITrainNameShunting = (Train as AITrain).Name;

                    AIBellTimer += elapsedClockSeconds;                    
                    if (AIBellTimer > 0.5f)
                    {
                        SignalEvent(Event.BellOff);
                        AIBellStartOn = true;
                        AIBellTimer = 0.0f;
                    }
                }                

                // Výpravčí pískne k odjezdu AI ze stanice
                if (CarIsWaitingAtStation && this.ThrottlePercent > 0.0f)
                {                    
                    AITimerStart += elapsedClockSeconds;
                    CarIsWaitingAtStation = false;
                    if ((Train as AITrain).Name != (Train as AITrain).AITrainNameReadyToDepart)
                        SignalEvent(Event.AIPermissionToDepart);
                    (Train as AITrain).AITrainNameReadyToDepart = (Train as AITrain).Name;
                }

                // Vyčkávací čas AI po písknutí nebo povolení odjezdu
                if (AITimerStart > 0.0f)
                {
                    AITimerStart += elapsedClockSeconds;
                    if (AITimerStart < 3.0f)
                    {
                        ThrottlePercent = 0.0f;
                        SpeedMpS = 0.0f;
                    }
                    else
                        AITimerStart = 0.0f;
                }

                if (this.AbsSpeedMpS > 0.5f && (Train as AITrain).Name == (Train as AITrain).AITrainNameShunting)
                    (Train as AITrain).AITrainNameShunting = "NOP";
                if (this.AbsSpeedMpS > 0.5f && (Train as AITrain).Name == (Train as AITrain).AITrainNameReadyToDepart)
                    (Train as AITrain).AITrainNameReadyToDepart = "NOP";
            }
        }

        // Panto shodí HV po zadaném čase
        public bool PantoCanHVOffon;
        public void PantoCanHVOff(float elapsedClockSeconds)
        {
            if (this is MSTSElectricLocomotive)
            {
                if (PantoCanHVOffSpeedKpH > 0 && CircuitBreakerOn)
                {
                    if (Pantographs[1].State != PantographState.Up && Pantographs[2].State != PantographState.Up)
                    {
                        PantoCanHVOffon = true;
                        if (AbsSpeedMpS < PantoCanHVOffSpeedKpH)
                        {
                            HVOff = true;
                        }
                    }
                }
                if (PantoCanHVOffon && (Pantographs[1].State == PantographState.Raising || Pantographs[2].State == PantographState.Raising || !CircuitBreakerOn))
                    PantoCanHVOffon = false;
            }
        }

        // Nastaví příznak zapnutých baterií a napájení pro zapnutí světel
        public void SetCarLightsPowerOn()
        {
            //if (LocoReadyToGo)
            //    Headlight = 0;

            if (Battery)
                CarLightsPowerOn = true;
            else
                CarLightsPowerOn = false;
            if (this.Train.TrainType == Train.TRAINTYPE.AI || this.Train.TrainType == Train.TRAINTYPE.REMOTE)
            {
                if (PowerOn)
                    CarLightsPowerOn = true;
                else
                    CarLightsPowerOn = false;
                // AI nebude mít zhasnutá světla na stahovačkách
                if (AbsSpeedMpS > 0)
                    CarLightsPowerOn = true;
            }
        }

        // Nastaví výkon na postrku
        float HelperTimerIncrease;
        float HelperTimerDecrease;
        bool LocoBecomeHelper;
        bool HelperStartOn;
        float HelperBellTimer;
        public void SetHelperLoco(float elapsedClockSeconds)
        {
            if (IsLeadLocomotive() && (AcceptHelperSignals || PowerReductionResult12 > 0))
            {
                AcceptHelperSignals = false;
                PowerReductionResult12 = 0;
            }

            if (AcceptHelperSignals && PowerUnit)
            {
                LocoHelperOn = true;
                AcceptCableSignals = false;
            }
            if (!AcceptHelperSignals && PowerUnit)
            {
                LocoHelperOn = false;                
            }

            if (IsLeadLocomotive())
            {
                Simulator.ThrottleLocoHelper = LocalThrottlePercent;
                Simulator.DynamicBrakeLocoHelper = LocalDynamicBrakePercent;
                Simulator.ControllerVoltsLocoHelper = ControllerVolts;
                if (MSTSBrakeSystem.BrakeLine1PressurePSI < BrakeSystem.maxPressurePSI0 - (0.5f * 14.50377f))
                {
                    Simulator.ThrottleLocoHelper = 0;
                    Train.ControllerVolts = 0;
                }
            }            

            // Lokomotivy propojené datovým kabelem
            if (!LocoHelperOn && Simulator.ControllerVoltsLocoHelper == 0 && AcceptCableSignals)
                Train.ControllerVolts = 0;

            if (!LocoHelperOn && !IsLeadLocomotive())
            {
                if (!AcceptCableSignals)
                    PowerReductionResult12 = 1;
                else
                    PowerReductionResult12 = 0;
            }
            
            // Postrk aktivován
            if (LocoHelperOn)
            {
                CarPowerKey = true;
  
                if (DynamicBrakeController != null)
                    DynamicBrakePercent = Simulator.DynamicBrakeLocoHelper;
                
                if (WheelSlipWarning || WheelSlip)                                 
                {   
                    AntiSlip = true;
                    SimpleAdhesion();
                    Sander = true;
                }
                else
                    Sander = false;

                Mirel.Ls90power[LocoStation] = SubSystems.Mirel.LS90power.Off;

                if (!HelperLocoDontPush && !HelperLocoPush && !HelperLocoFollow)
                {
                    HelperLocoFollow = true;
                }

                if (Simulator.ControllerVoltsLocoHelper >= 0)
                    PowerReductionResult12 = 1;
                else
                    PowerReductionResult12 = 0;
                
                if (HelperLocoPush)
                {                    
                    PowerReductionResult12 = 0;                    
                    if (AbsSpeedMpS * 3.6 > HelperSpeedPush
                        || !HelperPushStart
                        || WheelSlipWarning
                        || WheelSlip
                        || MSTSBrakeSystem.BrakeLine1PressurePSI < BrakeSystem.maxPressurePSI0 - (0.5f * 14.50377f)
                        || Simulator.ControllerVoltsLocoHelper < -1.5f
                        || Direction == Direction.N
                        || (this is MSTSElectricLocomotive && !CircuitBreakerOn)
                        || PowerCurrent1 > 0.95f * MaxCurrentPower)
                    {
                        HelperTimerDecrease += elapsedClockSeconds;
                        if (HelperTimerDecrease > 0.1f)
                        {
                            HelperTimerDecrease = 0;                            
                            if (LocalThrottlePercent > 0)
                                LocalThrottlePercent--;
                        }
                    }
                    else
                    if (AbsSpeedMpS * 3.6 < HelperSpeedPush - 1 
                        && HelperPushStart 
                        && !WheelSlipWarning 
                        && !WheelSlip
                        && MSTSBrakeSystem.BrakeLine1PressurePSI > BrakeSystem.maxPressurePSI0 - (0.5f * 14.50377f))
                    {
                        HelperTimerIncrease += elapsedClockSeconds;
                        if (HelperTimerIncrease > (Simulator.Weather.PricipitationIntensityPPSPM2 + 0.5f))
                        {
                            if (LocalThrottlePercent == 0 && SpeedMpS == 0)
                                HelperStartOn = true;
                            HelperTimerIncrease = 0;
                            if (LocalThrottlePercent < 100)
                                LocalThrottlePercent++;                            
                        }
                    }
                    
                    // Postrk zapíská
                    if (HelperStartOn && Train.IsFreight && !AcceptCableSignals)
                    {
                        HelperBellTimer += elapsedClockSeconds;
                        if (HelperBellTimer > 1.0f)
                            SignalEvent(Event.BellOn);
                        if (HelperBellTimer > 1.5f)
                        {
                            SignalEvent(Event.BellOff);
                            HelperStartOn = false;
                            HelperBellTimer = 0;
                        }
                    }                    
                }                              

                if (HelperLocoDontPush)
                {
                    if (Simulator.ThrottleLocoHelper != 0)
                        PowerReductionResult12 = 0;
                    HelperTimerDecrease += elapsedClockSeconds;
                    if (HelperTimerDecrease > 0.1f || (this is MSTSElectricLocomotive && !CircuitBreakerOn) || PowerCurrent1 > 0.95f * MaxCurrentPower)
                    {
                        HelperTimerDecrease = 0;
                        if (LocalThrottlePercent > 0)
                            LocalThrottlePercent--;
                    }
                }

                if (HelperLocoFollow)
                {
                    if (Simulator.ThrottleLocoHelper != 0)
                        PowerReductionResult12 = 0;

                    if (ThrottlePercent > Simulator.ThrottleLocoHelper 
                        || (this is MSTSElectricLocomotive && !CircuitBreakerOn)
                        || PowerCurrent1 > 0.95f * MaxCurrentPower 
                        || WheelSlipWarning 
                        || WheelSlip)
                    {
                        HelperTimerDecrease += elapsedClockSeconds;
                        if (HelperTimerDecrease > 0.1f)
                        {
                            HelperTimerDecrease = 0;
                            if (LocalThrottlePercent > 0)
                                LocalThrottlePercent--;
                        }                        
                    }
                    else
                    {
                        HelperTimerIncrease += elapsedClockSeconds;
                        if (HelperTimerIncrease > (Simulator.Weather.PricipitationIntensityPPSPM2 + 0.5f))
                        {
                            HelperTimerIncrease = 0;
                            if (LocalThrottlePercent < 100)
                                LocalThrottlePercent++;
                        }
                    }
                }

                LocalThrottlePercent = MathHelper.Clamp(LocalThrottlePercent, 0, 100);
                Train.ControllerVolts = LocalThrottlePercent / 10f;
                StepControllerValue = (int)(LocalThrottlePercent / 100f * Simulator.StepControllerMaxValue);
                ForceHandleValue = LocalThrottlePercent;

                if (extendedPhysics != null)
                    extendedPhysics.Update(elapsedClockSeconds);
            }

            // Připojený MU kabel
            if (AcceptCableSignals)
            {
                AcceptMUSignals = true;                
            }

            // Odpojený MU kabel
            if (!AcceptCableSignals)
            {                
                AcceptMUSignals = false;                
            }

            // Výkon MU vypnutý
            if (!AcceptPowerSignals && AcceptCableSignals)
            {
                LocalThrottlePercent = 0;                
                LocalDynamicBrakePercent = -1;
                ControllerVolts = 0;
                //if (CruiseControl != null && CruiseControl.Equipped)
                //{
                //    CruiseControl.SpeedRegMode[LocoStation] = SubSystems.CruiseControl.SpeedRegulatorMode.Manual;
                //    CruiseControl.SelectedSpeedMpS = MpS.FromKpH(0);
                //    CruiseControl.SpeedSelMode[LocoStation] = SubSystems.CruiseControl.SpeedSelectorMode.Neutral;
                //    AripotControllerValue[LocoStation] = 0;
                //}
            }            
        }

        // Určí řídící vůz        
        public void SetControlUnit()
        {
            PowerUnit = false;
            ControlUnit = false;

            if (MaxPowerWBase > 10 * 1000 || (this as MSTSDieselLocomotive != null && (this as MSTSDieselLocomotive).MaximumDieselEnginePowerW > 10 * 1000))
                PowerUnit = true;
            else
                ControlUnit = true;

            if (PowerUnit && AcceptCableSignals)
            {
                Simulator.PowerUnitAvailable = true;
                Simulator.DataDriveForceN = DriveForceN;
                Simulator.DataMaxCurrentA = MaxCurrentA;
                Simulator.DataMaxForceN = MaxForceN;
                Simulator.DataDynamicBrakeMaxCurrentA = DynamicBrakeMaxCurrentA;
                Simulator.DataDynamicBrakeForceN = DynamicBrakeForceN;
                Simulator.DataMaxDynamicBrakeForceN = MaxDynamicBrakeForceN;
                Simulator.DataDynamicBrakeAvailable = DynamicBrakeAvailable;
                if (this as MSTSDieselLocomotive != null)
                {
                    Simulator.DataFakeDieselWaterTemperatureDeg = (this as MSTSDieselLocomotive).DieselEngines[0].FakeDieselWaterTemperatureDeg;
                    Simulator.DataFakeDieselOilTemperatureDeg = (this as MSTSDieselLocomotive).DieselEngines[0].FakeDieselOilTemperatureDeg;
                    Simulator.DataRealRPM = (this as MSTSDieselLocomotive).DieselEngines[0].RealRPM;
                }
            }
            SetControlUnitParameters();
        }

        // Nastaví parametry pro řídící vůz
        public void SetControlUnitParameters()
        {
            if (ControlUnit && AcceptCableSignals && Simulator.PowerUnitAvailable)
            {
                DriveForceN = Simulator.DataDriveForceN;
                MaxCurrentA = Simulator.DataMaxCurrentA;
                MaxForceN = Simulator.DataMaxForceN;
                MaxPowerW = 0;
                DynamicBrakeMaxCurrentA = Simulator.DataDynamicBrakeMaxCurrentA;
                DynamicBrakeForceN = Simulator.DataDynamicBrakeForceN;
                MaxDynamicBrakeForceN = Simulator.DataMaxDynamicBrakeForceN;
                DynamicBrakeAvailable = Simulator.DataDynamicBrakeAvailable;
                if (this as MSTSDieselLocomotive != null)
                {
                    (this as MSTSDieselLocomotive).DieselEngines[0].FakeDieselWaterTemperatureDeg = Simulator.DataFakeDieselWaterTemperatureDeg;
                    (this as MSTSDieselLocomotive).DieselEngines[0].FakeDieselOilTemperatureDeg = Simulator.DataFakeDieselOilTemperatureDeg;
                    (this as MSTSDieselLocomotive).DieselEngines[0].RealRPM = Simulator.DataRealRPM;
                }
            }
        }

        float WheelNoSlipWarningTimer;
        float WheelNoSlipTimer;
        public void CheckMUWheelSlip(float elapsedClockSeconds)
        {
            if (IsLeadLocomotive())
            {
                Simulator.WheelSlipWarning = false;
                Simulator.WheelSlip = false;
            }

            if (Simulator.MUCableLocoCount > 1)
            {
                Train.TrainHasMUControl = true;
                if (IsLeadLocomotive() && !AcceptCableSignals)
                    Train.TrainHasMUControl = false;

                if (Train.TrainHasMUControl)
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive && !car.CarIsPlayerLoco)
                        {
                            if (car.WheelSlipWarning)
                            {
                                Simulator.WheelSlipWarning = true;
                                Simulator.IsWheelSlipWarning = true;
                            }
                            if (car.WheelSlip)
                            {
                                Simulator.WheelSlip = true;
                                Simulator.IsWheelSlip = true;
                            }
                        }                        
                    }
                    if (IsLeadLocomotive())
                    {
                        if (!Simulator.MU_WheelSlipWarningOn && Simulator.WheelSlipWarning)
                        {
                            Simulator.MU_WheelSlipWarningOn = true;
                            SignalEvent(Event.MUWheelSlipWarningOn);
                        }
                        if (!Simulator.MU_WheelSlipOn && Simulator.WheelSlip)
                        {
                            Simulator.MU_WheelSlipOn = true;
                            SignalEvent(Event.MUWheelSlipOn);
                        }
                    }
                }
            }
            if (IsLeadLocomotive())
            {
                if (Simulator.IsWheelSlipWarning)
                {
                    if (!Simulator.WheelSlipWarning)
                        WheelNoSlipWarningTimer += elapsedClockSeconds;
                    if (WheelNoSlipWarningTimer > 1.0f)
                    {
                        Simulator.IsWheelSlipWarning = false;
                        WheelNoSlipWarningTimer = 0.0f;
                        Simulator.MU_WheelSlipWarningOn = false;
                        SignalEvent(Event.MUWheelSlipWarningOff);
                    }
                }
                if (Simulator.IsWheelSlip)
                {
                    if (!Simulator.WheelSlip)
                        WheelNoSlipTimer += elapsedClockSeconds;
                    if (WheelNoSlipTimer > 1.0f)
                    {
                        Simulator.IsWheelSlip = false;
                        WheelNoSlipTimer = 0.0f;
                        Simulator.MU_WheelSlipOn = false;
                        SignalEvent(Event.MUWheelSlipOff);
                    }
                }
            }
        }

        public void ResetControlUnitParameters()
        {
            if (ControlUnit && Simulator.PowerUnitAvailable)
            {
                DriveForceN = 0;
                MaxCurrentA = 0;
                //MaxForceN = 0;
                MaxPowerW = 0;
                DynamicBrakeMaxCurrentA = 0;
                DynamicBrakeForceN = 0;
                //MaxDynamicBrakeForceN = 0;
            }
        }

        public void CheckPantos()
        {
            switch (PantoMode)
            {
                case PantoModes.Auto:
                    if (Direction == Direction.Forward)
                    {
                        Pantograph pantograph2 = Pantographs.List[0];
                        if (pantograph2.State == PantographState.Down)
                            pantograph2.State = PantographState.Raising;
                        pantograph2 = Pantographs.List[1];
                        if (pantograph2.State == PantographState.Up)
                            pantograph2.State = PantographState.Lowering;
                    }
                    break;
                case PantoModes.Both:
                    foreach (Pantograph pantograph4 in Pantographs.List)
                    {
                        if (pantograph4.State == PantographState.Down)
                            pantograph4.State = PantographState.Raising;
                    }
                    break;
                case PantoModes.Aft:
                    Pantograph pantograph = Pantographs.List[0];
                    if (pantograph.State == PantographState.Down)
                        pantograph.State = PantographState.Raising;
                    pantograph = Pantographs.List[1];
                    if (pantograph.State == PantographState.Up)
                        pantograph.State = PantographState.Lowering;
                    break;
                case PantoModes.Forward:
                    pantograph = Pantographs.List[1];
                    if (pantograph.State == PantographState.Down)
                        pantograph.State = PantographState.Raising;
                    pantograph = Pantographs.List[0];
                    if (pantograph.State == PantographState.Up)
                        pantograph.State = PantographState.Lowering;
                    break;
            }
        }


        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's subsystems.
        /// </summary>
        private bool trainBrakeApply = false;
        private bool trainBrakeRelease = false;
        protected float EngineBrakePercentSet = 0;
        public bool CanCheckEngineBrake = true;
        protected int checkParkingBrakeCount = 0;
        protected float SplashScreenDisplayed = 0;
        protected float SplashScreenRandomTime = 0;
        public bool SplashScreenWillBeDisplayed = false;
        protected float HvPantoTimer = 0;
        protected bool firstFrame = true;        
        public override void Update(float elapsedClockSeconds)
        {
            if (firstFrame && BrakeSystem.StartOn)
            {                                
                HV5Switch[1] = HV5Switch[2] = 2;
                LastStateHV5[1] = LastStateHV5[2] = 2;
                HV4Switch[1] = HV4Switch[2] = -1;
                LastStateHV4[1] = LastStateHV4[2] = 1;
                HV3Switch[1] = HV3Switch[2] = 1;
                LastStateHV3[1] = LastStateHV3[2] = 1;
                Pantograph4Switch[1] = Pantograph4Switch[2] = 0;
                Pantograph3Switch[1] = Pantograph3Switch[2] = 0;
                DoorSwitch[1] = DoorSwitch[2] = 1;                
                DieselDirectionControllerPosition[1] = DieselDirectionController2Position[1] = DieselDirectionController4Position[1] = -1;
                DieselDirectionControllerPosition[2] = DieselDirectionController2Position[2] = DieselDirectionController4Position[2] = -1;
                Headlight[1] = Headlight[2] = 0;
                MirelRSDirectionControllerPosition[1] = preMirelRSDirectionControllerPosition[1] = MirelRSDirectionControllerPosition[2] = preMirelRSDirectionControllerPosition[2] = 1;
                MirelRSControllerPosition[1] = preMirelRSControllerPosition[1] = MirelRSControllerPosition[2] = preMirelRSControllerPosition[2] = 3;

                if (CruiseControl != null)
                {
                    CruiseControl.SpeedSelMode[1] = CruiseControl.SpeedSelMode[2] = SpeedSelectorMode.Neutral;
                }

                firstFrame = false;
                if (Simulator.Settings.AirEmpty)
                {
                    PantoCommandDown = true;
                }
                else
                {
                    if (!LocoIsStatic)
                    {
                        Battery = true;
                        ToggleCabRadio(true);
                        ActiveStation = UsingRearCab ? DriverStation.Station2 : DriverStation.Station1;
                        if (Flipped)
                            ActiveStation = UsingRearCab ? DriverStation.Station1 : DriverStation.Station2;
                        // Mirel
                        Mirel.Test1 = true;
                        Mirel.Test2 = true;
                        Mirel.Test3 = true;
                        Mirel.Test4 = true;
                        Mirel.Test5 = true;
                        Mirel.Test6 = true;
                        Mirel.Test7 = true;
                        Mirel.initTest = SubSystems.Mirel.InitTest.Passed;
                        Mirel.BlueLight = true;
                        Mirel.selectedDriveMode = SubSystems.Mirel.DriveMode.Normal;
                        Mirel.driveMode = SubSystems.Mirel.DriveMode.Off;
                        Mirel.MaxSelectedSpeed = Mirel.MirelMaximumSpeed = MpS.ToKpH(MaxSpeedMpS);
                        // LS90
                        Mirel.ls90tested = true;
                        Mirel.Ls90power[LocoStation] = SubSystems.Mirel.LS90power.On;

                        LocoStation = 1;
                        if (UsingRearCab)
                            LocoStation = 2;

                        // ARR
                        if (IsLeadLocomotive())
                        {
                            PowerKeyPosition[LocoStation] = 2;
                            PowerKey = true;
                            StationIsActivated[LocoStation] = true;

                            if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Lap
                                || TrainBrakeController.TrainBrakeControllerState == ControllerState.Neutral
                                || LapActive[LocoStation])
                                EngineBrakeValue[LocoStation] = 1.0f;

                            prevEngineBrakeValue[LocoStation] = EngineBrakeValue[LocoStation];

                            /*if (CruiseControl != null && CruiseControl.Equipped)
                            {
                                CruiseControl.SpeedRegMode[LocoStation] = SubSystems.CruiseControl.SpeedRegulatorMode.Auto;
                                CruiseControl.SelectedSpeedMpS = MpS.FromKpH(40);
                                CruiseControl.SpeedSelMode[LocoStation] = SubSystems.CruiseControl.SpeedSelectorMode.Parking;
                                AripotControllerValue[LocoStation] = CruiseControl.SelectedSpeedMpS / MaxSpeedMpS;
                            }*/
                        }
                    }
                }
            }
            

            if (AbsSpeedMpS == 0)
                WheelSpeedMpS = 0;
            if (IsPlayerTrain)
            {
                if (LocoType == LocoTypes.Vectron && !PantoCommandDown)
                    CheckPantos();
                if (IsPlayerTrain && !Simulator.Paused)
                {
                    if (LocoType == LocoTypes.Vectron)
                    {
                        if (CircuitBreakerOn && extendedPhysics.GeneratoricModeBlocked)
                            extendedPhysics.GeneratoricModeBlocked = false;
                        if (ChangingPowerSystem)
                            PowerChangeRoutine(elapsedClockSeconds);
                        else
                        {
                            if (!CircuitBreakerOn && (Pantographs.List[0].State == PantographState.Up || Pantographs.List[1].State == PantographState.Up))
                            {
                                HvPantoTimer += elapsedClockSeconds;
                                if (SystemAnnunciator == 0)
                                {
                                    SystemAnnunciator = 6;
                                }
                                else if (SystemAnnunciator == 6 && HvPantoTimer > 2)
                                {
                                    SystemAnnunciator = 4;
                                }
                                else if ((SystemAnnunciator == 4 || SystemAnnunciator == 3) && HvPantoTimer > 1)
                                {
                                    SystemAnnunciator = 5;
                                    HvPantoTimer = 0;
                                }
                            }
                            if (!CircuitBreakerOn && (Pantographs.List[0].State == PantographState.Lowering || Pantographs.List[0].State == PantographState.Raising || Pantographs.List[1].State == PantographState.Lowering || Pantographs.List[1].State == PantographState.Raising))
                            {
                                SystemAnnunciator = 3;
                            }
                            if (!CircuitBreakerOn && Pantographs.List[0].State == PantographState.Down && Pantographs.List[1].State == PantographState.Down && HvPantoTimer < 5)
                            {
                                HvPantoTimer += elapsedClockSeconds;
                                SystemAnnunciator = 4;
                            }
                            if (CircuitBreakerOn && (Pantographs.List[0].State == PantographState.Lowering || Pantographs.List[0].State == PantographState.Raising || Pantographs.List[1].State == PantographState.Lowering || Pantographs.List[1].State == PantographState.Raising))
                            {
                                SystemAnnunciator = 3;
                            }
                            if (CircuitBreakerOn && Pantographs.List[0].State == PantographState.Down && Pantographs.List[1].State == PantographState.Down && HvPantoTimer < 5)
                            {
                                HvPantoTimer += elapsedClockSeconds;
                                SystemAnnunciator = 4;
                            }
                            if (!CircuitBreakerOn && Pantographs.List[0].State == PantographState.Down && Pantographs.List[1].State == PantographState.Down && HvPantoTimer >= 5)
                            {
                                SystemAnnunciator = 1;
                            }

                            if (CircuitBreakerOn && (Pantographs.List[0].State == PantographState.Up || Pantographs.List[1].State == PantographState.Up))
                            {
                                bool motorDisabled = false;
                                foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                                {
                                    foreach (ExtendedAxle ea in uc.Axles)
                                    {
                                        foreach (ElectricMotor em in ea.ElectricMotors)
                                        {
                                            if (em.Disabled)
                                            {
                                                motorDisabled = true;
                                                goto Action;
                                            }
                                        }
                                    }
                                }
                            Action:
                                HvPantoTimer = 0;
                                if (!motorDisabled)
                                {
                                    SystemAnnunciator = 0;
                                }
                                else
                                {
                                    SystemAnnunciator = 6;
                                }
                            }

                            if (SystemAnnunciator == 3 && !CircuitBreakerOn && Pantographs.List[0].State == PantographState.Up && Pantographs.List[1].State == PantographState.Up && HvPantoTimer > 6)
                            {
                                SystemAnnunciator = 5;
                            }

                            if (SystemAnnunciator == 0 && TrainBrakeController.TrainBrakeControllerState != ControllerState.Release)
                            {
                                SystemAnnunciator = 6;
                            }

                            MSTSElectricLocomotive elecLoco = this as MSTSElectricLocomotive;
                            if (SystemAnnunciator == 5 && elecLoco.PowerSupply.CircuitBreaker.State == CircuitBreakerState.Closing)
                            {
                                SystemAnnunciator = 4;
                            }
                        }
                    }

                    if (UsingForceHandle && TrainBrakeController.TrainBrakeControllerState != ControllerState.EPApply)
                    {
                        if (ForceHandleIncreasing)
                        {
                            ForceHandleValue += 0.5f;
                            if (ForceHandleValue > 100)
                                ForceHandleValue = 100;
                            Simulator.Confirmer.Information("Force inreased to " + ((int)ForceHandleValue).ToString());
                        }
                        if (ForceHandleDecreasing)
                        {
                            ForceHandleValue -= 0.5f;
                            if (ForceHandleValue < -100)
                                ForceHandleValue = -100;
                            Simulator.Confirmer.Information("Force dereased to " + ((int)ForceHandleValue).ToString());
                        }
                        if (!ForceHandleDecreasing && !ForceHandleIncreasing)
                        {
                            if (ForceHandleValue < 1.5f && ForceHandleValue > 0)
                            {
                                ForceHandleValue = 0;
                                SelectedMaxAccelerationStep[LocoStation] = 0;
                            }
                            if (ForceHandleValue > -1.5f && ForceHandleValue < 0)
                                ForceHandleValue = 0;
                        }
                        if (CruiseControl == null)
                        {
                            if (ForceHandleValue == 0)
                            {
                                ThrottlePercent = 0;
                                if (DynamicBrakePercent >= 0)
                                {
                                    DynamicBrakePercent = 0;
                                    DynamicBrakeChangeActiveState(false);
                                }
                            }
                            if (ForceHandleValue > 0)
                            {
                                SetThrottlePercent(ForceHandleValue);
                            }
                            if (ForceHandleValue < 0)
                            {
                                if (!EngineBrakeEngageEDB && !BrakeSystem.OL3active && !BreakEDBButton_Activated)
                                    SetDynamicBrakePercent(-ForceHandleValue);
                            }
                        }
                        else
                        {
                            if (CruiseControl.SpeedRegMode[LocoStation] != CruiseControl.SpeedRegulatorMode.Auto && CruiseControl.SpeedRegMode[LocoStation] != CruiseControl.SpeedRegulatorMode.AVV)
                            {
                                if (ForceHandleValue == 0 && !LocoHelperOn)
                                {
                                    ThrottlePercent = 0;
                                    if (DynamicBrakePercent >= 0)
                                    {
                                        SetDynamicBrakeValue(-1);
                                    }
                                }
                                if (ForceHandleValue > 0)
                                {
                                    SetThrottlePercent(ForceHandleValue);
                                }
                                if (ForceHandleValue < 0)
                                {
                                    if (!EngineBrakeEngageEDB && !BrakeSystem.OL3active && !BreakEDBButton_Activated)
                                        DynamicBrakePercent = -ForceHandleValue;
                                }
                            }
                            else
                            {
                                if (ForceHandleValue == 0)
                                {
                                    ThrottlePercent = 0;
                                    if (DynamicBrakePercent >= 0)
                                    {
                                        DynamicBrakeChangeActiveState(false);
                                    }
                                }
                                if (ForceHandleValue > 0)
                                {
                                    SelectedMaxAccelerationStep[LocoStation] = ForceHandleValue;
                                }
                                if (ForceHandleValue < 0)
                                {
                                    if (!EngineBrakeEngageEDB && !BrakeSystem.OL3active && !BreakEDBButton_Activated)
                                        DynamicBrakePercent = -ForceHandleValue;
                                }
                            }
                        }
                        ControllerVolts = ForceHandleValue / 10;
                    }

                    float speedDiff = 0;
                    if (IsPlayerTrain && !Simulator.Paused)
                    {
                        if (extendedPhysics == null)
                        {
                            speedDiff = AbsWheelSpeedMpS - AbsSpeedMpS;
                        }
                        if (extendedPhysics != null)
                        {
                            speedDiff = extendedPhysics.FastestAxleSpeedMpS - extendedPhysics.AverageAxleSpeedMpS;
                        }
                        speedDiff = Math.Abs(speedDiff);

                        if (IsLeadLocomotive() || LocoHelperOn || AcceptCableSignals)
                        {
                            if (speedDiff > AntiWheelSpinSpeedDiffThreshold || (AbsWheelSpeedMpS - AbsSpeedMpS) > AntiWheelSpinSpeedDiffThreshold)
                            {
                                skidSpeedDegratation += 0.5f;
                                if (skidSpeedDegratation + 0.5f > ControllerVolts)
                                    skidSpeedDegratation = ControllerVolts - 0.5f;

                            }
                            else if (skidSpeedDegratation > 0)
                            {
                                skidSpeedDegratation -= 0.05f; // původně 0.01                                
                            }
                        }

                        if (wasRestored && IsPlayerTrain && MultiPositionControllers != null && !Simulator.Paused)
                        {
                            foreach (MultiPositionController mpc in MultiPositionControllers)
                            {
                                if (mpc.controllerBinding == MultiPositionController.ControllerBinding.TrainBrake || mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                                {
                                    mpc.DoMovement(MultiPositionController.Movement.Aft);
                                    mpc.DoMovement(MultiPositionController.Movement.Neutral);
                                    mpc.CheckNeutralPosition();
                                    mpc.ReloadPositions();
                                }
                            }
                        }

                        if (extendedPhysics != null && !Simulator.Paused)
                        {
                            if (extendedPhysics.OverridenControllerVolts > ControllerVolts && ControllerVolts == 0 && wasRestored)
                            {
                                ControllerVolts = extendedPhysics.OverridenControllerVolts;
                            }
                            if (IsLeadLocomotive())
                                extendedPhysics.OverridenControllerVolts = ControllerVolts;
                            if (!IsLeadLocomotive())
                            {
                                // Postrk
                                if (LocoHelperOn && !HelperLocoPush)
                                    ControllerVolts = Train.ControllerVolts;
                                if (!LocoHelperOn)
                                // Dvojčlen
                                {
                                    if (AcceptCableSignals)
                                        ControllerVolts = Train.ControllerVolts;
                                    else
                                        ControllerVolts = 0;
                                }
                            }
                        }
                        if (wasRestored && !Simulator.Paused)
                            wasRestored = false;
                        if (AntiWheelSpinEquipped)
                        {
                            if (extendedPhysics == null && skidSpeedDegratation > 0)
                            {
                                TractiveForceN /= skidSpeedDegratation * 10;
                                if (TractiveForceN > MaxForceN)
                                    TractiveForceN = MaxForceN;
                            }
                            else if (extendedPhysics != null && LocoType != LocoTypes.Vectron)
                            {
                                extendedPhysics.OverridenControllerVolts = Train.OverridenControllerVolts = ControllerVolts - skidSpeedDegratation;
                            }
                        }
                        if (extendedPhysics != null && extendedPhysics.OverridenControllerVolts > 10)
                            extendedPhysics.OverridenControllerVolts = 10;
                    }

                    if (extendedPhysics != null && !LocoHelperOn)
                        extendedPhysics.Update(elapsedClockSeconds);
                    if (CruiseControl != null)
                    {
                        if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Manual)
                        {
                            CruiseControl.controllerVolts = ControllerVolts;
                        }
                        if (CruiseControl.RestrictedSpeedActive)
                            CruiseControl.CheckRestrictedSpeedZone();
                    }
                    if (Mirel != null && Simulator.PlayerIsInCab && this.CarIsPlayerLoco)
                    {
                        if (IsPlayerTrain && Mirel.Equipped)
                            Mirel.Update(elapsedClockSeconds, AbsSpeedMpS, AbsWheelSpeedMpS);
                    }

                    if (CruiseControl != null && CruiseControl.controllerVolts > 0 && DynamicBrakePercent > -1)
                        DynamicBrakeChangeActiveState(false);

                    if (extendedPhysics == null)
                    {
                        if (CruiseControl == null)
                        {
                            if (ThrottlePercent > 0)
                            {
                                ControllerVolts = ThrottlePercent / 10;
                            }
                        }
                        else if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Manual)
                        {
                            ControllerVolts = ThrottlePercent / 10;
                        }
                    }

                    if (DynamicBrakePercent > 0)
                    {
                        if (PowerOn)
                        {
                            ControllerVolts = -(DynamicBrakePercent / 100) * MaxControllerVolts;
                        }
                        else
                        {
                            if (PowerOnFilter > 0)
                            {
                                ControllerVolts = -(DynamicBrakePercent / 100) * MaxControllerVolts;
                            }
                        }
                    }
                    else if (DynamicBrakePercent <= 0 && ControllerVolts < 0 && CruiseControl != null && !CruiseControl.IReallyWantToBrake)
                        ControllerVolts = 0;

                    if (ControllerVolts == 0)
                        SetDynamicBrakeValue(-1);
                }
            }

            // Icik            
            SetCarLightsPowerOn();
            SetLapButton();            
            CarFrameUpdate(elapsedClockSeconds);

            if (IsLeadLocomotive())
            {
                CarIsPlayerLoco = true;
                LocoIsStatic = false;
            }
            else
                CarIsPlayerLoco = false;

            // Inicialzace loko hráče (důležité pro TT scénář)
            if (CarIsPlayerLoco && !CarIsPlayerLocoSet && Train is Timetables.TTTrain)
            {
                BrakeSystem.StartOn = true;
                BrakeSystem.IsAirEmpty = Simulator.Settings.AirEmpty;
                BrakeSystem.IsAirFull = !Simulator.Settings.AirEmpty;
                LocoReadyToGo = !Simulator.Settings.AirEmpty;                
                CarIsPlayerLocoSet = true;
                if (LocoReadyToGo)
                {
                    Battery = true;
                    PowerKey = true;
                    PowerKeyPosition[LocoStation] = 2;
                    StationIsActivated[LocoStation] = true;
                    /*if (CruiseControl != null && CruiseControl.Equipped)
                    {
                        CruiseControl.SpeedRegMode[LocoStation] = SubSystems.CruiseControl.SpeedRegulatorMode.Auto;
                        CruiseControl.SelectedSpeedMpS = MpS.FromKpH(40);
                        CruiseControl.SpeedSelMode[LocoStation] = SubSystems.CruiseControl.SpeedSelectorMode.Parking;
                        AripotControllerValue[LocoStation] = CruiseControl.SelectedSpeedMpS / MaxSpeedMpS;
                    }*/
                }
                else
                {
                    Battery = false;
                    PowerKey = false;
                    PowerKeyPosition[1] = 0;
                    PowerKeyPosition[2] = 0;
                }
            }

            if (!IsPlayerTrain && !Simulator.Paused && CarLengthM > 1f)
            {
                SetAIAction(elapsedClockSeconds);
                AcceptMUSignals = true;
            }

            if (IsPlayerTrain && !Simulator.Paused)
            {
                //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("WeatherAdv: " + Simulator.WeatherAdv));                                                                
                StepControllerValue = Simulator.StepControllerValue;
                // StepController odpovídá v defaultu throttle
                if (IsLeadLocomotive() && !MirerControllerEnable && !MirelRSControllerEnable)
                    Simulator.StepControllerValue = LocalThrottlePercent / 100;
                
                TogglePowerKey();
                PowerKeyLogic();
                MUCableLogic();
                TrainAlerterLogic();
                EngineBrakeValueLogic(elapsedClockSeconds);
                TrainBrakeValueLogic();
                WipersLogic();
                DirectionControllerLogic();
                PowerCurrentCalculation(elapsedClockSeconds);
                BrakeCurrentCalculation();
                Overcurrent_Protection();
                AntiSlip_Protection();
                MaxPower_MaxForce_ACDC();
                RDSTBreakerType();
                ToggleDieselDirectionController();
                ToggleDieselDirectionController2();
                MirerController();
                MirelRSController(elapsedClockSeconds);
                CommandCylinder(elapsedClockSeconds);
                TogglePantograph4Switch();
                TogglePantograph3Switch();
                ToggleHV2Switch();
                ToggleHV3Switch();
                ToggleHV4Switch();
                ToggleHV5Switch();
                EDBCancelByBreakEDBButton();
                EDBCancelByEngineBrake();
                EDBCancelByOL3BailOff();
                PowerOn_Filter(elapsedClockSeconds);
                SetAuxPower();
                TM_Temperature(elapsedClockSeconds);
                DriveResistance_Temperature(elapsedClockSeconds);
                StepControllerSituation(elapsedClockSeconds);
                AuxConsumptionOnLocomotive(elapsedClockSeconds); 
                ElevatedConsumptionOnLocomotive(elapsedClockSeconds);
                HVOffbyAirPressureE();
                HVOffbyAirPressureD();
                TMFailure(elapsedClockSeconds);
                PowerReductionResult(elapsedClockSeconds);
                SetControlUnit();
                SetHelperLoco(elapsedClockSeconds);
                PantoCanHVOff(elapsedClockSeconds);
                DirectionButtonSetup();
                PlayerSwitchToRearCab();
                LightPositionHandle();
                RainWindow(elapsedClockSeconds);
                WipersWindow(elapsedClockSeconds);
                CabRadioOnOff();
                CheckMUWheelSlip(elapsedClockSeconds);
                BatterySetOn = false;                
                if (LocoReadyToGo && this is MSTSSteamLocomotive)
                    LocoReadyToGo = false;                
            }
            
            // Hodnoty pro výpočet zvukových proměnných
            TrainBrakeControllerValueForSound = (float)Math.Round(TrainBrakeController.CurrentValue, 2);
            EngineBrakeControllerValueForSound = (float)Math.Round(EngineBrakeController.CurrentValue, 2);
            Variable5 = (float)Math.Round(Math.Abs(CurrentFilter.Filter(DriveForceN, elapsedClockSeconds) / 1000));


            TrainControlSystem.Update();

            elapsedTime = elapsedClockSeconds;
            string s = this.LocomotiveName;
            UpdatePowerSupply(elapsedClockSeconds);
            UpdateControllers(elapsedClockSeconds);
            
            if (Battery)
            {
                if (SplashScreenWillBeDisplayed && SplashScreen)
                {
                    if (SplashScreenRandomTime == 0)
                    {
                        Random rnd = new Random();
                        SplashScreenRandomTime = rnd.Next((int)SplashScreenMinDuration, (int)SplashScreenMaxDuration);
                    }
                    SplashScreenDisplayed += elapsedClockSeconds;
                    if (SplashScreenDisplayed > SplashScreenRandomTime) SplashScreen = false;
                }
            }
            else
            {
                SplashScreen = SplashScreenWillBeDisplayed;
                SplashScreenRandomTime = 0;
                SplashScreenDisplayed = 0;
            }

            if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Apply || TrainBrakeController.TrainBrakeControllerState == ControllerState.Emergency)
            {
                if (Mirel.initTest != Mirel.InitTest.Passed)
                {
                    if (!trainBrakeApply)
                    {
                        trainBrakeApply = !trainBrakeApply;
                        SignalEvent(Event.MirelBrakeReleasingPipePressure);
                    }
                }
            }
            else if (trainBrakeApply)
            {
                SignalEvent(Event.MirekBrakeStopReleaseSound);
                trainBrakeApply = !trainBrakeApply;
            }

            if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Release)
            {
                if (Mirel.initTest != Mirel.InitTest.Passed)
                {
                    if (!trainBrakeRelease)
                    {
                        trainBrakeRelease = !trainBrakeRelease;
                        SignalEvent(Event.MirelBrakeFillingPipePressure);
                    }
                }
            }
            else if (trainBrakeRelease)
            {
                SignalEvent(Event.MirekBrakeStopFillSound);
                trainBrakeRelease = !trainBrakeRelease;
            }

            // Train Heading - only check the lead locomotive otherwise flipped locomotives further in consist will overwrite the train direction
            if (IsLeadLocomotive())
            {
                var heading = (float)Math.Atan2(WorldPosition.XNAMatrix.M13, WorldPosition.XNAMatrix.M11);
                Train.PhysicsTrainLocoDirectionDeg = MathHelper.ToDegrees((float)heading);

                if (Flipped)
                {
                    Train.PhysicsTrainLocoDirectionDeg += 180.0f; // Reverse direction of train
                    if (Train.PhysicsTrainLocoDirectionDeg > 360) // If this results in an angle greater then 360, then convert it back to an angle between 0 & 360.
                    {
                        Train.PhysicsTrainLocoDirectionDeg -= 360;
                    }
                }
            }

            if (IsSteamHeatFitted)
            {
                UpdateCarSteamHeat(elapsedClockSeconds);
            }
            checkParkingBrakeCount++;
            if (AutomaticParkingBrake && IsPlayerTrain && checkParkingBrakeCount == 10)
            {
                checkParkingBrakeCount = 0;
                if (CruiseControl != null)
                {
                    if (((CruiseControl.SpeedRegMode[1] == CruiseControl.SpeedRegulatorMode.Auto && StationIsActivated[1]) || (CruiseControl.SpeedRegMode[2] == CruiseControl.SpeedRegulatorMode.Auto && StationIsActivated[2]))
                        || ((CruiseControl.SpeedRegMode[1] == CruiseControl.SpeedRegulatorMode.AVV && StationIsActivated[1]) || (CruiseControl.SpeedRegMode[2] == CruiseControl.SpeedRegulatorMode.AVV && StationIsActivated[2])))
                    {
                        bool braking = false;
                        bool forceBrake = false;
                        if (MultiPositionControllers != null)
                        {
                            foreach (MultiPositionController mpc in MultiPositionControllers)
                            {
                                if ((mpc.controllerBinding == MultiPositionController.ControllerBinding.Throttle || mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                                    && mpc.controllerPosition != MultiPositionController.ControllerPosition.Drive
                                    && mpc.controllerPosition != MultiPositionController.ControllerPosition.KeepCurrent
                                    && mpc.controllerPosition != MultiPositionController.ControllerPosition.ThrottleIncrease
                                    && mpc.controllerPosition != MultiPositionController.ControllerPosition.ThrottleIncreaseFast
                                    && mpc.controllerPosition != MultiPositionController.ControllerPosition.ThrottleIncreaseOrDynamicBrakeDecrease
                                    && mpc.controllerPosition != MultiPositionController.ControllerPosition.ThrottleIncreaseOrDynamicBrakeDecreaseFast
                                    )
                                {
                                    braking = true;
                                }
                                if (mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                                {
                                    if (mpc.controllerPosition != MultiPositionController.ControllerPosition.ThrottleIncrease)
                                    {
                                        forceBrake = braking = true;
                                    }
                                }
                            }
                        }

                        // Icik
                        if (CruiseControl.AripotEquipment)
                        {
                            braking = true;
                        }

                        if (((CruiseControl.SpeedSelMode[1] != CruiseControl.SpeedSelectorMode.Parking && StationIsActivated[1]) || (CruiseControl.SpeedSelMode[2] != CruiseControl.SpeedSelectorMode.Parking && StationIsActivated[2]))                            
                            && CruiseControl.SpeedRegulatorOptions.Contains("selectorparking") && !forceBrake)
                            braking = false;
                        if (AbsSpeedMpS > MpS.FromKpH(AutomaticParkingBrakeEngageSpeedKpH))
                            braking = false;
                        //if (!braking && !EngineBrakePriority)
                        //{
                        //    SetEngineBrakePercent(0);
                        //    EngineBrakePercentSet = 0;
                        //}
                        if (CanCheckEngineBrake && BrakeSystem.GetCylPressurePSI() < 0.01 || AbsSpeedMpS == 0)
                        {
                            if (EngineBrakeController.CurrentValue == 0.0f)
                                EngineBrakePriority = false;
                        }
                        AutomaticParkingBrakeEngaged = braking;
                    }
                    else AutomaticParkingBrakeEngaged = false;

                    if (LocoType == LocoTypes.Vectron && CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto)
                    {
                        if (ForceHandleValue <= 0)
                        {
                            if (AbsSpeedMpS < MpS.FromKpH(AutomaticParkingBrakeEngageSpeedKpH))
                            {
                                AutomaticParkingBrakeEngaged = true;
                            }
                        }
                        else if (ForceHandleValue > 0 && !ManualParkingBrakeReleaseRequired)
                        {
                            AutomaticParkingBrakeEngaged = false;
                        }
                    }
                }
            }

            if (IsPlayerTrain)
            {
                string test = GetTrainBrakeStatus();
                if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Release || TrainBrakeController.TrainBrakeControllerState == ControllerState.Neutral)
                {
                    if (Mirel.initTest != Mirel.InitTest.Passed)
                    {
                        if (!trainBrakeRelease)
                        {
                            trainBrakeRelease = !trainBrakeRelease;
                            SignalEvent(Event.MirelBrakeFillingPipePressure);
                        }
                    }
                    else
                    {
                        trainBrakeRelease = true;
                    }
                }
                else if (trainBrakeRelease)
                {
                    SignalEvent(Event.MirekBrakeStopFillSound);
                    trainBrakeRelease = !trainBrakeRelease;
                }
            }


            // TODO  this is a wild simplification for electric and diesel electric
            float t = ThrottlePercent / 100f;

            if (!AdvancedAdhesionModel)  // Advanced adhesion model turned off.
                AbsWheelSpeedMpS = AbsSpeedMpS;

            // For the advanced adhesion model, a rudimentary form of slip control is incorporated by using the wheel speed to calculate tractive effort.
            // As wheel speed is increased tractive effort is decreased. Hence wheel slip is "controlled" to a certain extent.
            // This doesn't cover all types of locomotives, for example if DC traction motors and no slip control, then the tractive effort shouldn't be reduced.
            // This won't eliminate slip, but limits its impact. 
            // More modern locomotive have a more sophisticated system that eliminates slip in the majority (if not all circumstances).
            // Simple adhesion control does not have any slip control feature built into it.
            // TODO - a full review of slip/no slip control.
            if (WheelSlip && AdvancedAdhesionModel)
            {
                AbsTractionSpeedMpS = AbsWheelSpeedMpS;
            }
            else
            {
                AbsTractionSpeedMpS = AbsSpeedMpS;
            }

            // Jindrich
            //UpdateMotiveForce(elapsedClockSeconds, t, AbsSpeedMpS, AbsWheelSpeedMpS);
            CheckAccelerationBits(elapsedClockSeconds, AbsWheelSpeedMpS);

            if (CruiseControl != null && !TrainBrakeController.TCSEmergencyBraking)
            {
                if (!IsPlayerTrain || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Manual)
                    CruiseControl.WasForceReset = false;
                else if (CruiseControl.SelectedSpeedMpS > 0)
                    CruiseControl.Update(elapsedClockSeconds, AbsWheelSpeedMpS);
                else if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                    CruiseControl.Update(elapsedClockSeconds, AbsWheelSpeedMpS);
            }
            else
                if (CruiseControl != null && (TrainBrakeController.TCSEmergencyBraking || TrainBrakeController.TCSFullServiceBraking))
                CruiseControl.WasBraking = true;

            UpdateTractiveForce(elapsedClockSeconds, t, AbsSpeedMpS, AbsWheelSpeedMpS);

            if (IsPlayerTrain)
            {
                if (MultiPositionControllers != null && MultiPositionController != null)
                {
                    foreach (MultiPositionController mpc in MultiPositionControllers)
                        mpc.Update(elapsedClockSeconds);
                }
            }
            
            if (float.IsNaN(TractiveForceN))
                Debugger.Break();

            ApplyDirectionToTractiveForce();

            // Calculate the total motive force for the locomotive - ie TractiveForce (driving force) + Dynamic Braking force.
            // Note typically only one of the above will only ever be non-zero at the one time.
            // For flipped locomotives the force is "flipped" elsewhere, whereas dynamic brake force is "flipped" below by the direction of the speed.            

            // Icik            
            if (!PowerOn || (!AcceptPowerSignals && AcceptCableSignals))                
                TractiveForceN = 0;

            MotiveForceN = TractiveForceN;

            if (DynamicBrakePercent > 0 && (DynamicBrakeForceCurves != null || DynamicBrakeForceCurvesAC != null || DynamicBrakeForceCurvesDC != null) && AbsSpeedMpS > 0)
            {
                float f = 0;
                switch (SwitchingVoltageMode)
                {
                    case 0:
                        if (DynamicBrakeForceCurvesDC != null)
                            f = DynamicBrakeForceCurvesDC.Get(.01f * DynamicBrakePercent, AbsTractionSpeedMpS);
                        else
                            if (DynamicBrakeForceCurves != null)
                            f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, AbsTractionSpeedMpS);
                        break;
                    case 1:
                        if (DynamicBrakeForceCurves != null)
                            f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, AbsTractionSpeedMpS);
                        break;
                    case 2:
                        if (DynamicBrakeForceCurvesAC != null)
                            f = DynamicBrakeForceCurvesAC.Get(.01f * DynamicBrakePercent, AbsTractionSpeedMpS);
                        else
                            if (DynamicBrakeForceCurves != null)
                            f = DynamicBrakeForceCurves.Get(.01f * DynamicBrakePercent, AbsTractionSpeedMpS);
                        break;
                }
                f = f * UiPowerLose;

                //if (f > 0 && PowerOn)
                // Icik 
                // EDB funguje z baterií
                if (f > 0 && (PowerOn || PowerOnFilter > 0))
                {
                    DynamicBrakeForceN = f * (1 - PowerReduction);
                    MotiveForceN = -(SpeedMpS > 0 ? 1 : SpeedMpS < 0 ? -1 : Direction == Direction.Reverse ? -1 : 1) * DynamicBrakeForceN;
                    
                    // Lokomotiva nesmí být poháněna EDB silou, jen bržděna
                    if (MotiveForceN / Math.Abs(MotiveForceN) == SpeedMpS / AbsSpeedMpS)
                        MotiveForceN = 0;
                }
                else
                {
                    DynamicBrakeForceN = 0f;
                }
            }
            else
                DynamicBrakeForceN = 0; // Set dynamic brake force to zero if in Notch 0 position

            UpdateFrictionCoefficient(elapsedClockSeconds); // Find the current coefficient of friction depending upon the weather

            UpdateWaterTroughRefill(elapsedClockSeconds, AbsSpeedMpS); // Update refill from trough

            switch (this.Train.TrainType)
            {
                case Train.TRAINTYPE.AI:
                case Train.TRAINTYPE.AI_PLAYERHOSTING:
                    if (AcceptMUSignals)
                    {
                        if (!PowerOn)
                        {
                            //Train.SignalEvent(PowerSupplyEvent.RaisePantograph, 1);

                            if (this is MSTSDieselLocomotive)
                            {
                                foreach (DieselEngine de in (this as MSTSDieselLocomotive).DieselEngines)
                                {
                                    if (de.EngineStatus != DieselEngine.Status.Running)
                                        de.Initialize(true);
                                }
                            }
                        }
                        if (this is MSTSDieselLocomotive)
                        {
                            foreach (DieselEngine de in (this as MSTSDieselLocomotive).DieselEngines)
                            {
                                if (de.GearBox != null)
                                    de.GearBox.GearBoxOperation = GearBoxOperation.Automatic;
                            }
                        }
                    }

                    AntiSlip = true; // Always set AI trains to AntiSlip
                    SimpleAdhesion();   // Simple adhesion model used for AI trains
                    if (Train.IsActualPlayerTrain) FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
                    WheelSpeedMpS = Flipped ? -AbsSpeedMpS : AbsSpeedMpS;            //make the wheels go round
                    break;
                case Train.TRAINTYPE.STATIC:
                case Train.TRAINTYPE.INTENDED_PLAYER:
                    break;
                case Train.TRAINTYPE.PLAYER:
                case Train.TRAINTYPE.AI_PLAYERDRIVEN:
                case Train.TRAINTYPE.REMOTE:
                    // For notched throttle controls (e.g. Dash 9 found on Marias Pass) UpdateValue is always 0.0
                    if (ThrottleController.UpdateValue != 0.0)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                            ThrottleController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            ThrottleController.CurrentValue * 100);
                    }
                    if (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0 && DynamicBrake)
                    {
                        Simulator.Confirmer.UpdateWithPerCent(
                            CabControl.DynamicBrake,
                            DynamicBrakeController.UpdateValue > 0 ? CabSetting.Increase : CabSetting.Decrease,
                            DynamicBrakeController.CurrentValue * 100);
                    }

                    // Icik
                    //if (Simulator.UseAdvancedAdhesion && !Simulator.Paused) 
                    if (Simulator.UseAdvancedAdhesion && Simulator.GameSpeed == 1)
                    {
                        AdvancedAdhesion(elapsedClockSeconds); // Use advanced adhesion model
                        AdvancedAdhesionModel = true;  // Set flag to advise advanced adhesion model is in use
                    }
                    else
                    {
                        SimpleAdhesion();  // Use simple adhesion model
                        AdvancedAdhesionModel = false; // Set flag to advise simple adhesion model is in use
                    }

                    UpdateTrackSander(elapsedClockSeconds);

                    if (this is MSTSDieselLocomotive || this is MSTSElectricLocomotive)  // Antislip and throttle down should only work on diesel or electric locomotives.
                    {

                        // If wheel slip waring activated, and antislip is set in ENG file then reduce throttle setting to a value below warning power
                        if (WheelSlipWarning && AntiSlip)
                        {
                            ThrottleController.SetValue(PreviousThrottleSetting);
                        }


                        PreviousThrottleSetting = (ThrottlePercent / 100.0f) - 0.005f;
                        PreviousThrottleSetting = MathHelper.Clamp(PreviousThrottleSetting, 0.0f, 1.0f); // Prevents parameter going outside of bounds 

                        // If wheels slip and WheelslipCausesThrottleDown is set in engine file reduce throttle to 0 setting
                        if (WheelslipCausesThrottleDown && WheelSlip)
                            ThrottleController.SetValue(0.0f);
                    }

                    //Force to display
                    if (Simulator.GameSpeed == 1)
                        FilteredMotiveForceN = CurrentFilter.Filter(MotiveForceN, elapsedClockSeconds);
   
                    break;
                default:
                    break;

            }

            // always set AntiSlip for AI trains
            if (Train.TrainType == Train.TRAINTYPE.AI || Train.TrainType == Train.TRAINTYPE.AI_PLAYERHOSTING)
            {
                AntiSlip = true;
            }

            // If the train is vacuumed braked then no need to update the compressor, but udate the ejector instead
            if (BrakeSystem is VacuumSinglePipe)
            {

                if (VacuumBrakeEQFitted) // Only update exhauster/main reservoir on locomotives fitted ith an EQ reservoir
                {
                    UpdateVacuumExhauster(elapsedClockSeconds);
                }
                else
                {
                    UpdateSteamEjector(elapsedClockSeconds);
                }

            }
            else
            {
                UpdateCompressor(elapsedClockSeconds);
            }

            UpdateHornAndBell(elapsedClockSeconds);

            UpdateSoundVariables(elapsedClockSeconds);

            if (LocoType == LocoTypes.Katr7507)
                TryKeepDeceleration(elapsedClockSeconds);

            PrevMotiveForceN = MotiveForceN;
            base.Update(elapsedClockSeconds);                                    

#if DEBUG_ADHESION
            // Timer to determine travel time - resets when locomotive stops
            if (AbsSpeedMpS > 0)
            {
                DebugTimer += elapsedClockSeconds;  // Increment debug timer whilever train is moving
            }
            else
            {
                DebugTimer = 0.0f; // Reset timer if train is stopped
            }

            // Speed detector, set to print out an adhesion snapshot every 5mph increment
            if (AbsSpeedMpS > MpS.FromMpH(DebugSpeed))
            {
                if (!DebugSpeedReached)
                {
                    DebugSpeedReached = true;                    
                }
                else
                {
                    if (DebugSpeedReached)
                    {
                        DebugSpeed += DebugSpeedIncrement;
                    }
                    DebugSpeedReached = false;

                }

            }

            // Only prints out in speed increments of 5mph
            if (DebugSpeedReached)
            {
                
                Trace.TraceInformation("====================================== Debug Adhesion (MSTSLocomotive.cs) ===============================");
                Trace.TraceInformation("AntiSlip - {0} ABSWheelSpeed {1}", AntiSlip, AbsWheelSpeedMpS);
                Trace.TraceInformation("Advanced Adhesion Model - {0}", Simulator.UseAdvancedAdhesion);
                Trace.TraceInformation("Car Id: {0} Engine type: {1} Speed: {2} Gradient: {3} Time: {4}", CarID, EngineType, FormatStrings.FormatSpeedDisplay(AbsSpeedMpS, IsMetric), -CurrentElevationPercent, DebugTimer);
                Trace.TraceInformation("Rail TE: {0} DBTE: {1}", FormatStrings.FormatForce(MotiveForceN, IsMetric), FormatStrings.FormatForce(CouplerForceU, IsMetric));

                Trace.TraceInformation("Axle - Drive Force: {0} Axle Force: {1} Wheelspeed: {2}", FormatStrings.FormatForce(LocomotiveAxle.DriveForceN, IsMetric), FormatStrings.FormatForce(LocomotiveAxle.AxleForceN, IsMetric), FormatStrings.FormatSpeedDisplay(WheelSpeedMpS, IsMetric));
                Trace.TraceInformation("Axle - Axle Inertia: {0} Wheel Radius: {1}", LocomotiveAxle.InertiaKgm2, DriverWheelRadiusM);

                Trace.TraceInformation("Adhesion - Curtius_A: {0} Curtius_B: {1} Curtius_C: {2} Curtius_D: {3}", Curtius_KnifflerA, Curtius_KnifflerB, Curtius_KnifflerC, AdhesionK);
                Trace.TraceInformation("Locomotive Weight: {0} Axle Weight: {1}", MassKG, DrvWheelWeightKg);

                Trace.TraceInformation("Axle Speed: {0} TrainSpeed: {1} Slip Speed: {2}", LocomotiveAxle.AxleSpeedMpS, LocomotiveAxle.TrainSpeedMpS, LocomotiveAxle.SlipSpeedMpS);

                Trace.TraceInformation("Adhesion Conditions: {0}", LocomotiveAxle.AdhesionConditions);

                Trace.TraceInformation("Fog - Min {0} fog {1}", Math.Min((Simulator.Weather.FogDistance * 2.75e-4f + 0.45f), 1.0f), Simulator.Weather.FogDistance);

                Trace.TraceInformation("Rain - Min {0} pric {1}", Math.Min((Simulator.Weather.PricipitationIntensityPPSPM2 * 0.0078f + 0.45f), 0.607f), Simulator.Weather.PricipitationIntensityPPSPM2);

            }
#endif
        } // End Method Update

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's power supply.
        /// </summary>
        protected virtual void UpdatePowerSupply(float elapsedClockSeconds)
        {
        }

        /// <summary>
        /// This function updates periodically the steam heating in wagons.
        /// </summary>
        protected virtual void UpdateCarSteamHeat(float elapsedClockSeconds)
        {
        }

        /// <summary>
        /// This function updates periodically the states and physical variables of the locomotive's controllers.
        /// </summary>
        bool EDBOn;
        protected virtual void UpdateControllers(float elapsedClockSeconds)
        {
            SteamHeatController.Update(elapsedClockSeconds);
            if (IsPlayerTrain)
            {
                if (SteamHeatController.UpdateValue > 0.0)
                    Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, CabSetting.Increase, SteamHeatController.CurrentValue * 100);
                if (SteamHeatController.UpdateValue < 0.0)
                    Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, CabSetting.Decrease, SteamHeatController.CurrentValue * 100);
            }

            TrainBrakeController.Update(elapsedClockSeconds);
            if (TrainBrakeController != null)
            {
                if (TrainBrakeController.UpdateValue > 0.0)
                {
                    SignalEvent(Event.TrainBrakeChange);
                    Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Increase, GetTrainBrakeStatusSimple());
                }
                if (TrainBrakeController.UpdateValue < 0.0)
                {
                    SignalEvent(Event.TrainBrakeChange);
                    Simulator.Confirmer.Update(CabControl.TrainBrake, CabSetting.Decrease, GetTrainBrakeStatusSimple());
                }
            }

            if (EngineBrakeController != null)
            {
                EngineBrakeController.Update(elapsedClockSeconds);
                if (EngineBrakeController.UpdateValue > 0.0)
                {
                    //SignalEvent(Event.EngineBrakeChange);
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());                    
                }
                if (EngineBrakeController.UpdateValue < 0.0)
                {
                    //SignalEvent(Event.EngineBrakeChange);
                    Simulator.Confirmer.Update(CabControl.EngineBrake, CabSetting.Decrease, GetEngineBrakeStatus());                    
                }
            }

            if (BrakemanBrakeController != null)
            {
                BrakemanBrakeController.Update(elapsedClockSeconds);
                if (BrakemanBrakeController.UpdateValue > 0.0)
                {
                    Simulator.Confirmer.Update(CabControl.BrakemanBrake, CabSetting.Increase, GetBrakemanBrakeStatus());
                }
                if (BrakemanBrakeController.UpdateValue < 0.0)
                {
                    Simulator.Confirmer.Update(CabControl.BrakemanBrake, CabSetting.Decrease, GetBrakemanBrakeStatus());
                }
            }

            DynamicBrakeBlending(elapsedClockSeconds);
            if (DynamicBrakeController != null && DynamicBrakeController.CommandStartTime > DynamicBrakeCommandStartTime) // use the latest command time
                DynamicBrakeCommandStartTime = DynamicBrakeController.CommandStartTime;

            // Icik
            //if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && (DynamicBrakePercent >= 0 || IsLeadLocomotive() && DynamicBrakeIntervention >= 0))
            if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && (DynamicBrakePercent >= 0 || DynamicBrakeIntervention >= 0))
            {
                if (!DynamicBrake)
                {
                    if (DynamicBrakeCommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime /*|| (DynamicBrakeController != null && DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)*/)
                    {
                        DynamicBrake = true; // Engage
                        if (IsLeadLocomotive() && DynamicBrakeController != null && LocoType != LocoTypes.Vectron && LocoType != LocoTypes.Katr7507)
                            Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                    }
                    else if (IsLeadLocomotive() && LocoType != LocoTypes.Vectron)
                        Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
                }
                else if (this.IsLeadLocomotive() || !this.IsLeadLocomotive()) // Icik
                {
                    if (DynamicBrakeController != null)
                    {
                        // Icik
                        if (LocoHelperOn && DynamicBrakeIntervention == -1)
                            DynamicBrakeController.CurrentValue = 0;

                        DynamicBrakeController.Update(elapsedClockSeconds);
                        DynamicBrakePercent = (DynamicBrakeIntervention < 0.1f ? DynamicBrakeController.CurrentValue : DynamicBrakeIntervention) * 100f;
                        LocalDynamicBrakePercent = (DynamicBrakeIntervention < 0.1f ? DynamicBrakeController.CurrentValue : DynamicBrakeIntervention) * 100f;
                 
                        // Icik
                        if (DynamicBrakeController.CurrentValue > 0 || DynamicBrakePercent > 0)
                            EDBOn = true;                        
                        if (DynamicBrakeIntervention == -1 && EDBOn && DynamicBrakeController.CurrentValue == 0)
                        {
                            DynamicBrakePercent = -1;
                            LocalDynamicBrakePercent = -1;
                            EDBOn = false;
                        }
                    }
                    else
                    {
                        DynamicBrakePercent = Math.Max(DynamicBrakeIntervention * 100f, 0f);
                        LocalDynamicBrakePercent = Math.Max(DynamicBrakeIntervention * 100f, 0f);
                    }

                    if (DynamicBrakeIntervention < 0.1f && PreviousDynamicBrakeIntervention >= 0 && DynamicBrakePercent == 0)
                    {
                        DynamicBrakePercent = 0;
                        LocalDynamicBrakePercent = 0;
                    }
                    PreviousDynamicBrakeIntervention = DynamicBrakeIntervention;
                }
                else if (DynamicBrakeController != null)
                    DynamicBrakeController.Update(elapsedClockSeconds);
            }
            else if ((DynamicBrakeController != null || DynamicBrakeBlendingEnabled || DynamicBrakeAvailable) && DynamicBrakeIntervention < 0 && DynamicBrakePercent < 0 && DynamicBrake)
            {
                // <CScomment> accordingly to shown documentation dynamic brake delay is required only when engaging
                //           if (DynamicBrakeController.CommandStartTime + DynamicBrakeDelayS < Simulator.ClockTime)
                //           {
                EDBOn = false;
                DynamicBrake = false; // Disengage
                DynamicBrakeForceN = 0f; // Reset dynamic brake force
                if (IsLeadLocomotive() && LocoType != LocoTypes.Vectron)
                    Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.Off);
                //           }
                //            else if (IsLeadLocomotive())
                //               Simulator.Confirmer.Confirm(CabControl.DynamicBrake, CabSetting.On); // Keeping status string on screen so user knows what's happening
            }

            //Currently the ThrottlePercent is global to the entire train
            //So only the lead locomotive updates it, the others only updates the controller (actually useless)           
            if (this.IsLeadLocomotive())
            {
                var throttleCurrentNotch = ThrottleController.CurrentNotch;
                ThrottleController.Update(elapsedClockSeconds);
                if (ThrottleController.CurrentNotch < throttleCurrentNotch && ThrottleController.ToZero)
                    SignalEvent(Event.ThrottleChange);
                ThrottlePercent = (ThrottleIntervention < 0 ? ThrottleController.CurrentValue : ThrottleIntervention) * 100.0f;
                ConfirmWheelslip(elapsedClockSeconds);
                LocalThrottlePercent = (ThrottleIntervention < 0 ? ThrottleController.CurrentValue : ThrottleIntervention) * 100.0f;
            }
            else
            {
                ThrottleController.Update(elapsedClockSeconds);
            }

#if INDIVIDUAL_CONTROL
            //this train is remote controlled, with mine as a helper, so I need to send the controlling information, but not the force.
            if (MultiPlayer.MPManager.IsMultiPlayer() && this.Train.TrainType == Train.TRAINTYPE.REMOTE && this == Program.Simulator.PlayerLocomotive)
            {
                //cannot control train brake as it is the remote's job to do so
                if ((EngineBrakeController != null && EngineBrakeController.UpdateValue != 0.0) || (DynamicBrakeController != null && DynamicBrakeController.UpdateValue != 0.0) || ThrottleController.UpdateValue != 0.0)
                {
                    controlUpdated = true;
                }
                ThrottlePercent = ThrottleController.Update(elapsedClockSeconds) * 100.0f;
                if ((DynamicBrakeController != null) && (DynamicBrakePercent >= 0)) DynamicBrakePercent = DynamicBrakeController.Update(elapsedClockSeconds) * 100.0f;
                return; //done, will go back and send the message to the remote train controller
            }

            if (MultiPlayer.MPManager.IsMultiPlayer() && this.notificationReceived == true)
            {
                ThrottlePercent = ThrottleController.CurrentValue * 100.0f;
                this.notificationReceived = false;
            }
#endif
        }

        /// <summary>
        /// This function updates periodically the locomotive's motive force.
        /// </summary>
        protected virtual void UpdateTractiveForce(float elapsedClockSeconds, float t, float AbsSpeedMpS, float AbsWheelSpeedMpS)
        {
            // Method to set force and power info
            // An alternative method in the steam locomotive will override this and input force and power info for it.
            if (ThrottleOverriden != 0)
                t = ThrottleOverriden;
            if (DynamicBrakeFullRangeIncreaseTimeSeconds == 0)
                DynamicBrakeFullRangeIncreaseTimeSeconds = 4;
            if (DynamicBrakeFullRangeDecreaseTimeSeconds == 0)
                DynamicBrakeFullRangeDecreaseTimeSeconds = 6;
            if (PowerOn && Direction != Direction.N)
            {
                if (extendedPhysics == null || !IsPlayerTrain) // AI musí vždy počítat TractiveForceN kvůli zvukům
                {
                    if (TractiveForceCurves == null && TractiveForceCurvesAC == null && TractiveForceCurvesDC == null
                        && TractiveForceStepControllerCurves == null && TractiveForceStepControllerCurvesAC == null && TractiveForceStepControllerCurvesDC == null)
                    {
                        float maxForceN = MaxForceN * t * (1 - PowerReduction);
                        float maxPowerW = MaxPowerW * t * t * (1 - PowerReduction);

                        if (maxForceN * AbsTractionSpeedMpS > maxPowerW)
                            maxForceN = maxPowerW / AbsTractionSpeedMpS;
                        //if (AbsSpeedMpS > MaxSpeedMpS)
                        //    maxForceN = 0;
                        if (AbsTractionSpeedMpS > MaxSpeedMpS - 0.05f)
                            maxForceN = 20 * (MaxSpeedMpS - AbsTractionSpeedMpS) * maxForceN;
                        if (AbsSpeedMpS > (MaxSpeedMpS))
                            maxForceN = 0;

                        maxForceN = maxForceN * UiPowerLose;
                        TractiveForceN = maxForceN;
                    }
                    else
                    {                        
                        if (t > 0)
                        {
                            // Icik
                            switch (SwitchingVoltageMode)
                            {
                                case 0:
                                    if (TractiveForceStepControllerCurvesDC != null)
                                    {
                                        TractiveForceN = TractiveForceStepControllerCurvesDC.Get(StepControllerValue, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceStepControllerCurvesDC.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else
                                    if (TractiveForceStepControllerCurves != null)
                                    {
                                        TractiveForceN = TractiveForceStepControllerCurves.Get(StepControllerValue, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceStepControllerCurves.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else
                                    if (TractiveForceCurvesDC != null)
                                    {
                                        TractiveForceN = TractiveForceCurvesDC.Get(t, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceCurvesDC.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else                                    
                                    if (TractiveForceCurves != null)
                                    { 
                                        TractiveForceN = TractiveForceCurves.Get(t, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceCurves.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    break;
                                case 1:
                                    if (TractiveForceStepControllerCurves != null)
                                    {
                                        TractiveForceN = TractiveForceStepControllerCurves.Get(StepControllerValue, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceStepControllerCurves.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else
                                    if (TractiveForceCurves != null)
                                    {
                                        TractiveForceN = TractiveForceCurves.Get(t, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceCurves.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    break;
                                case 2:
                                    if (TractiveForceStepControllerCurvesAC != null)
                                    {
                                        TractiveForceN = TractiveForceStepControllerCurvesAC.Get(StepControllerValue, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceStepControllerCurvesAC.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else
                                    if (TractiveForceStepControllerCurves != null)
                                    {
                                        TractiveForceN = TractiveForceStepControllerCurves.Get(StepControllerValue, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceStepControllerCurves.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else
                                    if (TractiveForceCurvesAC != null)
                                    {
                                        TractiveForceN = TractiveForceCurvesAC.Get(t, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceCurvesAC.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    else
                                    if (TractiveForceCurves != null)
                                    {
                                        TractiveForceN = TractiveForceCurves.Get(t, AbsTractionSpeedMpS) * (1 - PowerReduction);
                                        if (TractiveForceN < 0 && !TractiveForceCurves.AcceptsNegativeValues())
                                            TractiveForceN = 0;
                                    }
                                    break;
                            }
                            TractiveForceN = TractiveForceN * UiPowerLose;
                        }
                        else
                        {
                            TractiveForceN = 0;
                        }
                    }
                }
                else
                {
                    TractiveForceN = 0;
                    foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                    {
                        foreach (ExtendedAxle ea in uc.Axles)
                        {
                            if (extendedPhysics.UseControllerVolts)
                                TractiveForceN += ea.ForceN;
                            else
                                TractiveForceN += ea.maxForceN;
                        }
                    }
                }
            }
            else if (TractiveForceN > 0)
                TractiveForceN = 0f;

            /*if (MaxForceN > 0 && MaxContinuousForceN > 0 && PowerReduction < 1)
            {
                if (!float.IsNaN(AverageForceN))
                    TractiveForceN *= 1 - (MaxForceN - MaxContinuousForceN) / (MaxForceN * MaxContinuousForceN) * AverageForceN * (1 - PowerReduction);
                float w = (ContinuousForceTimeFactor - elapsedClockSeconds) / ContinuousForceTimeFactor;
                if (w < 0)
                    w = 0;
                AverageForceN = w * AverageForceN + (1 - w) * TractiveForceN;
            }*/
        }

        /// <summary>
        /// This function applies a sign to the motive force as a function of the direction of the train.
        /// </summary>
        protected virtual void ApplyDirectionToTractiveForce()
        {
            // Steam locomotives have their MotiveForceN already pre-inverted based on Direction
            if (!(this is MSTSSteamLocomotive))
            {
                if (Train.IsPlayerDriven)
                {
                    switch (Direction)
                    {
                        case Direction.Forward:
                            //MotiveForceN *= 1;     //Not necessary
                            break;
                        case Direction.Reverse:
                            TractiveForceN *= -1;
                            break;
                        case Direction.N:
                        default:
                            TractiveForceN *= 0;
                            break;
                    }
                }
                else // for AI locomotives
                {
                    switch (Direction)
                    {
                        case Direction.Reverse:
                            TractiveForceN *= -1;
                            break;
                        default:
                            break;
                    }
                }// end AI locomotive
            }
        }

        public enum CurrentDirectionEnum // used for drive or dynamic brake
        {
            Accelerating,
            Braking
        };

        protected enum Wheelslip
        {
            None,
            Warning,
            Occurring
        };

        protected Wheelslip WheelslipState = Wheelslip.None;

        public void ConfirmWheelslip(float elapsedClockSeconds)
        {
            if (extendedPhysics != null) // extended physics calculates its own wheelslip parametres
            {
                WheelSlip = false;
                return;
            }
            if (elapsedClockSeconds > 0 && Simulator.GameTime - LocomotiveAxle.ResetTime > 5)
            {
                if (AdvancedAdhesionModel)
                {
                    // Wheelslip
                    if (LocomotiveAxle.IsWheelSlip)
                    {
                        if (WheelslipState != Wheelslip.Occurring)
                        {
                            WheelslipState = Wheelslip.Occurring;
                            Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                        }
                    }
                    else
                    {
                        if (LocomotiveAxle.IsWheelSlipWarning)
                        {
                            if (WheelslipState != Wheelslip.Warning)
                            {
                                WheelslipState = Wheelslip.Warning;
                                Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Warn1);
                            }
                        }
                        else
                        {
                            if (WheelslipState != Wheelslip.None)
                            {
                                WheelslipState = Wheelslip.None;
                                Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                            }
                        }
                    }
                }
                else
                {
                    if (WheelSlip && (WheelslipState != Wheelslip.Occurring))
                    {
                        WheelslipState = Wheelslip.Occurring;
                        Simulator.Confirmer.Warning(CabControl.Wheelslip, CabSetting.On);
                    }
                    if ((!WheelSlip) && (WheelslipState != Wheelslip.None))
                    {
                        WheelslipState = Wheelslip.None;
                        Simulator.Confirmer.Confirm(CabControl.Wheelslip, CabSetting.Off);
                    }
                }
            }
        }

        /// <summary>
        /// This function updates periodically the state of the steam ejector or vacuum pump on a vacuum braked system.
        /// </summary>
        protected virtual void UpdateSteamEjector(float elapsedClockSeconds)
        {
            // Ejectors are controlled independently for the "straight_vacuum_single_pipe" brake type 
            // Ejectors are controlled by brake control valves in Simple Physics Control
            if (Simulator.Settings.SimpleControlPhysics && CarBrakeSystemType != "straight_vacuum_single_pipe")
            // Simple braking - control Ejector automatically based upon the brake control position
            // Stop ejector operation if full vacuum pressure reached
            {
                if ((TrainBrakeController.TrainBrakeControllerState == ControllerState.Release || TrainBrakeController.TrainBrakeControllerState == ControllerState.FullQuickRelease || (TrainBrakeController.TrainBrakeControllerState == ControllerState.VacContServ)) && (this.BrakeSystem.BrakeLine1PressurePSI > Vac.ToPress(this.TrainBrakeController.MaxPressurePSI)))
                {
                    LargeSteamEjectorIsOn = true;  // If brake is set to a release controller, then turn ejector on
                    LargeEjectorSoundOn = true;
                }
                else
                {
                    LargeSteamEjectorIsOn = false; // If brake is not set to a release controller, or full vacuum reached, then turn ejector off
                    LargeEjectorSoundOn = false;
                }
            }
            else if (!LargeEjectorControllerFitted && CarBrakeSystemType != "straight_vacuum_single_pipe") // Use an "automatic" large ejector when using a dreadnought style brake controller - large ejector stays on until moved back to released position
            {
                if (TrainBrakeController.TrainBrakeControllerState == ControllerState.Release)
                {
                    LargeSteamEjectorIsOn = true;  // If brake is set to a release controller, then turn ejector on
                    LargeEjectorSoundOn = true;
                }
                else
                {
                    LargeSteamEjectorIsOn = false; // If brake is not set to a release controller, then turn ejector off
                    if (LargeEjectorSoundOn)
                    {
                        SignalEvent(Event.LargeEjectorOff);
                        LargeEjectorSoundOn = false;
                    }
                }

            }
            else if (LargeEjectorControllerFitted)// Advanced braking - control ejector based upon using a "manual" large ejector control setting
            {
                if (LargeEjectorFeedFraction > 0.05)
                {
                    LargeSteamEjectorIsOn = true;  // turn ejector on
                    LargeEjectorSoundOn = true;
                }
                else
                {
                    LargeSteamEjectorIsOn = false; // turn ejector off
                    LargeEjectorSoundOn = false;
                }
            }


            if (SmallEjectorControllerFitted && CarBrakeSystemType != "straight_vacuum_single_pipe")
                // Turn small ejector on if controlled from drivers controller
                if (SmallEjectorFeedFraction > 0.05)
                {
                    SmallSteamEjectorIsOn = true;  // turn ejector on
                    SmallEjectorSoundOn = true;
                }
                else if (SmallEjectorControllerFitted)
                {
                    SmallSteamEjectorIsOn = false; // turn ejector off
                    SmallEjectorSoundOn = false;
                }


            // If diesel or electric locomotive, assume vacuum pump (exhauster) is continually running.
            if (!(this is MSTSSteamLocomotive))
            {
                VacuumPumpOperating = true;
            }
        }

        /// <summary>
        /// This function updates periodically the state of the vacuum exhauster on a vacuum braked system with a EQ reservoir.
        /// Resevoir vacuum is maintained in "atmospheric pressure" and converted to vacuum
        /// Vacuum reservoir should normally be maintained at approx 26InHg (4.185 psi)
        /// </summary>
        protected virtual void UpdateVacuumExhauster(float elapsedClockSeconds)
        {
            if (VacuumMainResVacuumPSIAorInHg > VacuumBrakesExhausterRestartVacuumPSIAorInHg && AuxPowerOn && !VacuumExhausterIsOn)
                SignalEvent(Event.VacuumExhausterOn);
            else if ((VacuumMainResVacuumPSIAorInHg < VacuumBrakesMainResMaxVacuumPSIAorInHg || !AuxPowerOn) && VacuumExhausterIsOn)
                SignalEvent(Event.VacuumExhausterOff);

        }

        /// <summary>
        /// This function updates periodically the state of the compressor and charges the main reservoir if the compressor is active.
        /// </summary>
        protected virtual void UpdateCompressor(float elapsedClockSeconds)
        {
            if (CompressorIsOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS;

            if (Compressor2IsOn)
                MainResPressurePSI += elapsedClockSeconds * MainResChargingRatePSIpS_2;

            if (TwoPipesConnectionLocoCount < 1)
                TwoPipesConnectionLocoCount = 1;

            if (AuxCompressorIsOn)
                AuxResPressurePSI += elapsedClockSeconds * AuxResChargingRatePSIpS / TwoPipesConnectionLocoCount;
        }

        /// <summary>
        /// This function updates periodically the states of the horn/whistle and the bell of the locomotive.
        /// </summary>
        protected virtual void UpdateHornAndBell(float elapsedClockSeconds)
        {
            Horn = ManualHorn || TCSHorn;
            if (Horn && !PreviousHorn)
            {
                SignalEvent(Event.HornOn);
                if (MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "HORN", 1)).ToString());
            }
            else if (!Horn && PreviousHorn)
            {
                SignalEvent(Event.HornOff);
                if (MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "HORN", 0)).ToString());
            }

            if (ManualBell)
            {
                BellState = SoundState.Sound;
            }
            else if (DoesHornTriggerBell && Horn)
            {
                BellState = SoundState.ContinuousSound;
            }
            else if (!ManualBell && BellState == SoundState.Sound)
            {
                BellState = SoundState.Stopped;
            }

            Bell = BellState != SoundState.Stopped;
            if (Bell && !PreviousBell)
            {
                SignalEvent(Event.BellOn);
                if (Train.TrainType != Train.TRAINTYPE.REMOTE && MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "BELL", 1)).ToString());
            }
            else if (!Bell && PreviousBell)
            {
                SignalEvent(Event.BellOff);
                if (Train.TrainType != Train.TRAINTYPE.REMOTE && MPManager.IsMultiPlayer()) MPManager.Notify((new MSGEvent(MPManager.GetUserName(), "BELL", 0)).ToString());
            }

            PreviousHorn = Horn;
            PreviousBell = Bell;
        }

        /// <summary>
        /// This function updates periodically the locomotive's sound variables.
        /// </summary>
        protected virtual void UpdateSoundVariables(float elapsedClockSeconds)
        {
        }

        /// <summary>
        /// Calls the Update method in the parent class MSTSWagon.
        /// </summary>
        /// <param name="elapsedClockSeconds"></param>
        protected void UpdateParent(float elapsedClockSeconds)
        {
            base.Update(elapsedClockSeconds);
        }

        /// <summary>
        /// Adjusts the MotiveForce to account for adhesion limits
        /// If UseAdvancedAdhesion is true, dynamic adhesion model is computed
        /// If UseAdvancedAdhesion is false, the basic force limits are calculated the same way MSTS calculates them, but
        /// the weather handleing is different and Curtius-Kniffler curves are considered as a static limit
        /// </summary>
        public void AdvancedAdhesion(float elapsedClockSeconds)
        {

            if (LocoNumDrvAxles <= 0)
            {
                WheelSpeedMpS = AbsSpeedMpS;
                return;
            }

            //Curtius-Kniffler computation for the basic model
            //        float max0 = 1.0f;  //Adhesion conditions [N]

            if (EngineType == EngineTypes.Steam && SteamEngineType != MSTSSteamLocomotive.SteamEngineTypes.Geared)
            {
                // Steam locomotive details updated in UpdateTractiveForce method, and inserted into adhesion module
                // ****************  NB WheelSpeed updated within Steam Locomotive module at the moment - to be fixed to prevent discrepancies ******************
            }

            else
            {

                //Compute axle inertia from parameters if possible
                if (AxleInertiaKgm2 > 10000.0f) // if axleinertia value supplied in ENG file, then use in calculations
                {
                    LocomotiveAxle.InertiaKgm2 = AxleInertiaKgm2;
                }
                else // if no value in ENG file, calculate axleinertia value.
                {
                    if (WheelAxles.Count > 0 && DriverWheelRadiusM > 0)
                    {
                        float upperLimit = 2.0f * WheelAxles.Count * (15000.0f * DriverWheelRadiusM - 2900.0f);
                        upperLimit = upperLimit < 100.0f ? 100.0f : upperLimit;

                        float lowerLimit = WheelAxles.Count * (9000.0f * DriverWheelRadiusM - 1750.0f);
                        lowerLimit = lowerLimit < 100.0f ? 100.0f : lowerLimit;

                        LocomotiveAxle.InertiaKgm2 = (upperLimit - lowerLimit) / (5000000.0f) * MaxPowerW + lowerLimit;
                    }
                    else
                        LocomotiveAxle.InertiaKgm2 = 32000.0f;
                }
                //Limit the inertia to 40000 kgm2
                LocomotiveAxle.InertiaKgm2 = LocomotiveAxle.InertiaKgm2 > 40000.0f ? 40000.0f : LocomotiveAxle.InertiaKgm2;

                LocomotiveAxle.AxleRevolutionsInt.MinStep = LocomotiveAxle.InertiaKgm2 / MaxPowerW / 5.0f;


                //Set axle model parameters
                // Icik                
                DriveForceN = LocomotiveAxle.DriveForceN;
                if (AdhesionEfficiencyKoef == 0) AdhesionEfficiencyKoef = 1.0f;
                LocomotiveAxle.AdhesionEfficiencyKoef = AdhesionEfficiencyKoef;                
                LocomotiveAxle.BrakeRetardForceN = BrakeRetardForceN / (MassKG / DrvWheelWeightKg); // Upravuje chybu v adhezi pokud vůz brzdí (brzdí plnou vahou tzn. všemi koly)
                LocomotiveAxle.AxleWeightN = 9.81f * DrvWheelWeightKg;   //will be computed each time considering the tilting
                LocomotiveAxle.DriveForceN = MotiveForceN * (1 - PowerReduction);  //Total force applied to wheels
                LocomotiveAxle.TrainSpeedMpS = SpeedMpS;            //Set the train speed of the axle model
                LocomotiveAxle.Update(elapsedClockSeconds);         //Main updater of the axle model               
                
                if (extendedPhysics == null)
                {                                        
                    MotiveForceN = LocomotiveAxle.AxleForceN;           
                    if (elapsedClockSeconds > 0)
                    {
                        WheelSlip = LocomotiveAxle.IsWheelSlip;             
                        WheelSlipWarning = LocomotiveAxle.IsWheelSlipWarning;
                    }                    
                }
                else 
                if (!extendedPhysics.UseControllerVolts)
                {
                    MotiveForceN = LocomotiveAxle.AxleForceN;
                    if (elapsedClockSeconds > 0)
                    {
                        WheelSlip = extendedPhysics.IsWheelSlip;
                        WheelSlipWarning = extendedPhysics.IsWheelSlipWarning;
                    }
                }
                else
                {
                    // MotiveForceN je počítán v EP
                    if (elapsedClockSeconds > 0)
                    {
                        WheelSlip = extendedPhysics.IsWheelSlip;
                        WheelSlipWarning = extendedPhysics.IsWheelSlipWarning;
                    }                    
                }
                WheelSpeedMpS = LocomotiveAxle.AxleSpeedMpS;
            }
        }

        public void SimpleAdhesion()
        {

            // Check if the following few lines are required???
            if (LocoNumDrvAxles <= 0)
            {
                WheelSpeedMpS = AbsSpeedMpS;
                return;
            }

            if (LocoNumDrvAxles <= 0)
                return;

            //Curtius-Kniffler computation
            // Set to a high level of adhesion to ensure that locomotive rarely slips in dry mode
            float uMax = 1.3f * (7.5f / (AbsSpeedMpS + 44.0f) + 0.161f); // Curtius - Kniffler equation

            float max0 = DrvWheelWeightKg * 9.81f * uMax;  //Ahesion limit in [N]
            float max1;

            if (Simulator.WeatherType == WeatherType.Rain || Simulator.WeatherType == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Simulator.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Simulator.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                    max0 *= 0.8f;
                if (Simulator.WeatherType == WeatherType.Rain)
                    max0 *= 0.8f;
                else
                    max0 *= 0.7f;
            }
            //float max1 = (Sander ? .95f : Adhesion2) * max0;  //Not used this way
            max1 = MaxForceN;
            //add sander
            if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityL > 0.0 && MainResPressurePSI > 80.0)
            {
                if (SanderSpeedEffectUpToMpS > 0.0f)
                {
                    if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                    {
                        switch (Simulator.WeatherType)
                        {
                            case WeatherType.Clear: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.2f; break;
                            case WeatherType.Rain: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 1.8f; break;
                            case WeatherType.Snow: max0 *= (1.0f - 0.5f / SanderSpeedEffectUpToMpS * AbsSpeedMpS) * 2.5f; break;
                        }
                    }
                }
                else
                    if (Sander)
                {
                    switch (Simulator.WeatherType)
                    {
                        case WeatherType.Clear: max0 *= 1.2f; break;
                        case WeatherType.Rain: max0 *= 1.8f; break;
                        case WeatherType.Snow: max0 *= 2.5f; break;
                    }
                }
            }

            max1 = max0;

            WheelSlip = false;

            if (MotiveForceN > max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = max1;
                else
                    MotiveForceN = Adhesion1 * max0;        //Lowers the adhesion limit to 20% of its full
            }
            else if (MotiveForceN < -max1)
            {
                WheelSlip = true;
                if (AntiSlip)
                    MotiveForceN = -max1;
                else
                    MotiveForceN = -Adhesion1 * max0;       //Lowers the adhesion limit to 20% of its full
            }
        }

        /// <summary>
        /// Refills the locomotive from a water trough
        /// </summary>
        public virtual void UpdateWaterTroughRefill(float elapsedClockSeconds, float absSpeedMpS)
        {
            // Check to see whether locomotive is to be refilled over water trough
            if (Simulator.PlayerLocomotive == this && IsWaterScoopDown)
            {
                var fraction = GetFilledFraction((uint)MSTSWagon.PickupType.FuelWater);

                if (!HasWaterScoop)
                {
                    if (!WaterScoopNotFittedFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("No water scoop on this loco"));
                        WaterScoopNotFittedFlag = true;
                    }
                    RefillingFromTrough = false;
                }
                else if (ScoopIsBroken)
                {
                    Simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Scoop is broken, can't refill"));
                    RefillingFromTrough = false;
                }
                else if (IsOverJunction())
                {
                    if (!ScoopIsBroken) // Only display message first time scoop is broken
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Error, Simulator.Catalog.GetString("Scoop is broken by junction track"));
                    }
                    ScoopIsBroken = true;
                    RefillingFromTrough = false;
                    SignalEvent(Event.WaterScoopBroken);
                }
                else if (!IsOverTrough())
                {
                    if (!WaterScoopOverTroughFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Scoop is not over trough, can't refill"));
                        WaterScoopOverTroughFlag = true;
                        MSTSWagon.RefillProcess.OkToRefill = false;
                        MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                    }
                    RefillingFromTrough = false;
                }
                else if (IsTenderRequired == 1 && Direction == Direction.Reverse) // Locomotives with tenders cannot go in reverse
                {
                    if (!WaterScoopDirectionFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetStringFmt("Refill: Loco must be moving forward."));
                        WaterScoopDirectionFlag = true;
                    }
                    RefillingFromTrough = false;
                }
                else if (absSpeedMpS < WaterScoopMinSpeedMpS)
                {
                    if (!WaterScoopSlowSpeedFlag)
                    {
                        Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetStringFmt("Refill: Loco speed must exceed {0} for water to enter tender.",
                                FormatStrings.FormatSpeedLimit(WaterScoopMinSpeedMpS, MilepostUnitsMetric)));
                        WaterScoopSlowSpeedFlag = true;
                        MSTSWagon.RefillProcess.OkToRefill = false;
                        MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                    }
                    RefillingFromTrough = false;
                }
                else if (fraction > 1.0)
                {
                    Simulator.Confirmer.Message(ConfirmLevel.None, Simulator.Catalog.GetStringFmt("Refill: Water supply now replenished."));
                }
                else
                {
                    MSTSWagon.RefillProcess.OkToRefill = true;
                    MSTSWagon.RefillProcess.ActivePickupObjectUID = -1;
                    RefillingFromTrough = true;
                    WaterScoopOverTroughFlag = false; // Reset flag so that message will come up again
                }

            }
            else if (HasWaterScoop && MSTSWagon.RefillProcess.OkToRefill == true && IsOverTrough())// water scoop has been raised, stop water filling
            {
                MSTSWagon.RefillProcess.OkToRefill = false;
                MSTSWagon.RefillProcess.ActivePickupObjectUID = 0;
                RefillingFromTrough = false;
            }


            // update water scoop
            // Water scoop fill charateristics can be found in - 
            // Calculate water velocity entering pipe: v = SQRT ( loco speed^2 - 2 * gravity * h)
            // Calculate the drag of the water scoop in the water: Drag Force = 0.5 * Drag Coeff * Fluid Density * Reference Area * Velocity

            if (RefillingFromTrough)
            {
                // Calculate water velocity
                const float Aconst = 2;
                const float Bconst = 2.15f;
                float Avalue = ((float)Math.Pow(MpS.ToMpH(absSpeedMpS), 2) * Bconst);
                float Bvalue = Aconst * GravitationalAccelerationFtpSpS * Me.ToFt(WaterScoopFillElevationM);

                if (Avalue > Bvalue)
                {
                    WaterScoopVelocityMpS = Me.FromFt((float)Math.Sqrt(Avalue - Bvalue));
                }
                else
                {
                    WaterScoopVelocityMpS = 0;
                }

                // calculate volume of water scooped per period
                const float CuFttoGalUK = 6.22884f; // imperial gallons of water in a cubic foot of water
                WaterScoopedQuantityLpS = L.FromGUK(Me2.ToFt2((WaterScoopDepthM * WaterScoopWidthM)) * Me.ToFt(WaterScoopVelocityMpS) * CuFttoGalUK);
                WaterScoopInputAmountL = WaterScoopedQuantityLpS * elapsedClockSeconds; // Calculate current input quantity

                // Max sure that water level can't exceed maximum tender water level. Assume that water will be vented out of tender if maximum value exceeded. 
                // If filling from water trough this will be done with force
                // The water controller can only be used by one stock item at a time.
                if (EngineType == EngineTypes.Steam)
                {
                    const float NominalExtraWaterVolumeFactor = 1.0001f;
                    CombinedTenderWaterVolumeUKG += L.ToGUK(WaterScoopInputAmountL); // add the amount of water added by scoop
                    WaterScoopTotalWaterL += WaterScoopInputAmountL;
                    CombinedTenderWaterVolumeUKG = MathHelper.Clamp(CombinedTenderWaterVolumeUKG, 0.0f, MaxTotalCombinedWaterVolumeUKG * NominalExtraWaterVolumeFactor);
                }
                else
                {
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL += WaterScoopInputAmountL; // add water if it is a steam heat boiler
                    CurrentLocomotiveSteamHeatBoilerWaterCapacityL = MathHelper.Clamp(CurrentLocomotiveSteamHeatBoilerWaterCapacityL, 0.0f, MaximumSteamHeatBoilerWaterTankCapacityL);
                }

                // Calculate drag force
                float ScoopDragCoeff = 1.05f;
                float ScoopDragAreaM = WaterScoopDepthM * WaterScoopWidthM;
                float ScoopFluidDensityKgpM3 = 998.2f; // Fuild density of water @ 20c
                WaterScoopDragForceN = 0.5f * ScoopDragCoeff * ScoopFluidDensityKgpM3 * ScoopDragAreaM * absSpeedMpS * absSpeedMpS;

                // Turn water scoop sound on
                if (!WaterScoopSoundOn)
                {
                    WaterScoopSoundOn = true;
                    SignalEvent(Event.WaterScoopDown);
                }
            }
            else // Ensure water scoop values are zero if not taking water.
            {
                WaterScoopDragForceN = 0f;
                WaterScoopedQuantityLpS = 0;
                WaterScoopInputAmountL = 0;
                WaterScoopVelocityMpS = 0;

                if (!IsOverTrough()) // Only reset once train moves off the trough
                {
                    WaterScoopTotalWaterL = 0.0f; // Reset amount of water picked up by water sccop.
                }

                // Turn water scoop sound off
                if (WaterScoopSoundOn)
                {
                    WaterScoopSoundOn = false;
                    SignalEvent(Event.WaterScoopUp);
                }
            }
        }

        #region Calculate Friction Coefficient
        /// <summary>
        /// Calculates the current coefficient of friction based upon the current weather 
        /// The calculation of Coefficient of Friction appears to provide a wide range of 
        /// variations depending upon a number of factors including the wheel and track 
        /// composition, and whether the track is dry, wet (or lubricated), icy, covered 
        /// in leaf litter, etc.
        /// For the purposes of simulating frcition the following values have been used. 
        /// Some reference documents have suggested that friction can vary between 0.07 
        /// for lubricated or icy track to 0.78 for dry track.
        /// The standard Cutius-Kniffler formula for dry rail is used as a base.
        /// Dry track = 0.33 
        /// 
        /// The following values are indicatitive values only (sourced from Principles and Applications of Tribology).
        /// Wet track (clean) = 0.18 <=> 0.2
        /// Wet track (sand) = 0.22 <=> 0.25
        /// Dew or fog = 0.09 <=> 0.15
        /// Sleet = 0.15
        /// Sleet (sand) = 0.2
        /// Snow track = 0.1 
        /// Snow track (sand) = 0.15
        /// 
        /// Note Heavy rain will actually wash track clean, and will give a higher value of adhesion then light drizzling rain
        /// </summary>
        float Time0;
        float Time1;
        bool TimeToGenerate;
        public float TreeLeavesLevel;
        float RandomDelay0;
        float RandomDelay1;
        public virtual void UpdateFrictionCoefficient(float elapsedClockSeconds)
        {
            // Icik
            if (Simulator.GameSpeed > 1)
                return;
            SanderSpeedOfMpS = 1000;

            //float BaseuMax = AdhesionEfficiencyKoef * (Curtius_KnifflerA / (MpS.ToKpH(AbsSpeedMpS) + Curtius_KnifflerB) + Curtius_KnifflerC); // Base Curtius - Kniffler equation - u = 0.33, all other values are scaled off this formula
            if (AdhesionEfficiencyKoef == 0) AdhesionEfficiencyKoef = 1.00f;
            float BaseuMax = AdhesionEfficiencyKoef * (Curtius_KnifflerA / (MpS.ToKpH(AbsSpeedMpS) + Curtius_KnifflerB) + Curtius_KnifflerC); // Base Curtius - Kniffler equation - u = 0.33, all other values are scaled off this formula
            float SandingFrictionCoefficientFactor = 0.0f;
            //Set the friction coeff due to weather
            if (Simulator.WeatherType == WeatherType.Rain || Simulator.WeatherType == WeatherType.Snow)
            {
                if (Train.SlipperySpotDistanceM < 0)
                {
                    Train.SlipperySpotLengthM = 10 + 40 * (float)Simulator.Random.NextDouble();
                    Train.SlipperySpotDistanceM = Train.SlipperySpotLengthM + 2000 * (float)Simulator.Random.NextDouble();
                }
                if (Train.SlipperySpotDistanceM < Train.SlipperySpotLengthM)
                {
                    BaseFrictionCoefficientFactor = 0.8f;
                }
                if (Simulator.WeatherType == WeatherType.Rain) // Wet weather
                {
                    if (Simulator.Settings.AdhesionProportionalToWeather && AdvancedAdhesionModel && !Simulator.Paused)  // Adjust clear weather for precipitation presence - base friction value will be approximately between 0.15 and 0.2
                    // ie base value between 0.8 and 1.0 (TODO) 
                    // note lowest friction will be for drizzle rain; friction will increase for precipitation both higher and lower than drizzle rail
                    {
                        // Icik
                        float pric = Simulator.Weather.PricipitationIntensityPPSPM2; // Nabývá max 1
                        // precipitation will calculate a value between 0.15 (light rain) and 0.2 (heavy rain) - this will be a factor that is used to adjust the base value - assume linear value between upper and lower precipitation values
                        if (pric >= 0.50f)
                        {   //BaseFrictionCoefficientFactor = Math.Min((pric * 0.0078f + 0.45f), 0.8f); // should give a minimum value between 0.8 and 1.0
                            BaseFrictionCoefficientFactor = Math.Min(pric - (0.1f * pric), 0.86f);
                        }
                        else
                        {   //BaseFrictionCoefficientFactor = Math.Min((0.4539f + 1.0922f * (0.5f - pric)), 0.8f); // should give a minimum value between 0.8 and 1.0
                            BaseFrictionCoefficientFactor = Math.Min(1 - (pric * 0.5f), BaseFrictionCoefficientFactor0);
                        }
                        if (BaseFrictionCoefficientFactor < 0.78f) BaseFrictionCoefficientFactor = 0.78f;
                    }
                    else // if not proportional to precipitation use fixed friction value of 0.8 x friction coefficient of 0.33
                    {
                        BaseFrictionCoefficientFactor = 0.8f;
                    }
                }
                else     // Snow weather
                {
                    //BaseFrictionCoefficientFactor = 0.6f;
                    // Icik
                    float pric = Simulator.Weather.PricipitationIntensityPPSPM2; // Nabývá max 1                               
                    if (pric >= 0.60f)
                    {
                        BaseFrictionCoefficientFactor = Math.Min(1 - (pric * 0.28f), BaseFrictionCoefficientFactor0);
                    }
                    else
                    {
                        BaseFrictionCoefficientFactor = Math.Min(1 - (pric * 0.05f), BaseFrictionCoefficientFactor0);
                    }
                    if (BaseFrictionCoefficientFactor < 0.72f) BaseFrictionCoefficientFactor = 0.72f;
                }

                //add sander - more effective in wet weather, so increases adhesion by more
                if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityL > 0.0 && MainResPressurePSI > 80.0 && (AbsSpeedMpS > 0.1f))
                {
                    // Icik
                    if (SanderSpeedEffectUpToMpS == 0) SanderSpeedEffectUpToMpS = 112 / 3.6f; // 112km/h
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                        {
                            // Icik
                            SandingFrictionCoefficientFactor = 1 + (0.75f * ((SanderSpeedEffectUpToMpS - AbsSpeedMpS) / SanderSpeedEffectUpToMpS));
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor - MathHelper.Clamp((50f - LocomotiveAxle.SlipSpeedPercent) / 50f, 0, SandingFrictionCoefficientFactor - 1);                            
                        }
                    }
                    else
                    {
                        if (Sander)  // If sander is on, and train speed is greater then zero, then put sand on the track
                        {
                            SandingFrictionCoefficientFactor = 1.75f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 175% adhesion (best case)
                        }
                    }
                }
            }
            else // Default to Dry (Clear) weather
            {

                if (Simulator.Settings.AdhesionProportionalToWeather && AdvancedAdhesionModel && !Simulator.Paused)  // Adjust clear weather for fog presence
                {
                    float fog = Simulator.Weather.FogDistance;
                    if (fog > 2000)
                    {
                        BaseFrictionCoefficientFactor = 1.0f; // if fog is not too thick don't change the friction
                    }
                    else
                    {
                        //BaseFrictionCoefficientFactor = Math.Min((fog * 2.75e-4f + 0.8f), 0.8f); // If fog is less then 2km then it will impact friction, decrease adhesion by up to 20% (same as clear to wet transition)
                        BaseFrictionCoefficientFactor = Math.Min((fog * 2.75e-4f + 0.9f), 0.95f); // If fog is less then 2km then it will impact friction, decrease adhesion by up to 20% (same as clear to wet transition)
                    }
                }
                else // if not proportional to fog use fixed friction value approximately equal to 0.33, thus factor will be 1.0 x friction coefficient of 0.33
                {
                    BaseFrictionCoefficientFactor = 1.0f;
                }

                //add sander - not as effective in dry weather
                if (AbsSpeedMpS < SanderSpeedOfMpS && CurrentTrackSandBoxCapacityL > 0.0 && MainResPressurePSI > 80.0 && (AbsSpeedMpS > 0))
                {
                    // Icik
                    if (SanderSpeedEffectUpToMpS == 0) SanderSpeedEffectUpToMpS = 112 / 3.6f; // 112km/h
                    if (SanderSpeedEffectUpToMpS > 0.0f)
                    {
                        if ((Sander) && (AbsSpeedMpS < SanderSpeedEffectUpToMpS))
                        {
                            // Icik
                            SandingFrictionCoefficientFactor = 1 + (0.25f * ((SanderSpeedEffectUpToMpS - AbsSpeedMpS) / SanderSpeedEffectUpToMpS));
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor;
                        }
                    }
                    else
                    {
                        if (Sander)  // If sander is on, and train speed is greater then zero, then put sand on the track
                        {
                            SandingFrictionCoefficientFactor = 1.25f;
                            BaseFrictionCoefficientFactor *= SandingFrictionCoefficientFactor; // Sanding track adds approx 125% adhesion (best case)
                        }
                    }
                }
                BaseFrictionCoefficientFactor0 = BaseFrictionCoefficientFactor;
            }
            
            // Podzim
            if (Simulator.Season == SeasonType.Autumn && AbsSpeedMpS > 0.1f)
            {
                Time0 += elapsedClockSeconds;
                if (Time0 < 0.5f)
                    RandomDelay0 = Simulator.Random.Next(50, 90);
                if (Time0 > RandomDelay0 || TimeToGenerate)
                {                    
                    if (!TimeToGenerate)
                        TreeLeavesLevel = Simulator.Random.Next(1, 50);
                    Time1 += elapsedClockSeconds;
                    if (Time1 < 0.5f)
                        RandomDelay1 = Simulator.Random.Next(5, 10);
                    TimeToGenerate = true;
                    if (Time1 > RandomDelay1)
                    {                        
                        Time1 = 0;
                        TimeToGenerate = false;
                        TreeLeavesLevel = 0;
                    }
                    Time0 = 0;
                }                                                                
                BaseFrictionCoefficientFactor *= (1 - (TreeLeavesLevel / 100f));
            }

            BaseFrictionCoefficientFactor *= TrackFactor;

            // For wagons use base Curtius-Kniffler adhesion factor - u = 0.33
            float WagonCurtius_KnifflerA = 7.5f;
            float WagonCurtius_KnifflerB = 44.0f;
            float WagonCurtius_KnifflerC = 0.161f;

            var AdhesionMultiplier = Simulator.Settings.AdhesionFactor / 100.0f; // Convert to a factor where 100% = no change to adhesion
            var AdhesionRandom = (float)((float)(Simulator.Settings.AdhesionFactorChange) * 0.01f * 2f * (Simulator.Random.NextDouble() - 0.5f));

            float WagonBaseuMax = (WagonCurtius_KnifflerA / (MpS.ToKpH(AbsSpeedMpS) + WagonCurtius_KnifflerB) + WagonCurtius_KnifflerC);
            // Icik
            Train.WagonCoefficientFriction = WagonBaseuMax * BaseFrictionCoefficientFactor * AdhesionMultiplier;  // Find friction coefficient factor for wagons based upon environmental conditions
            WagonCoefficientFrictionHUD = Train.WagonCoefficientFriction; // Save value for HUD display

            if (EngineType == EngineTypes.Steam && SteamDrvWheelWeightLbs < 10000 && Simulator.WeatherType == WeatherType.Clear)
            {
                BaseFrictionCoefficientFactor *= 0.75f;  // Dry track - static friction for vehicles with wheel weights less then 10,000lbs - u = 0.25
            }

            if (WheelSlip && ThrottlePercent > 0.2f && !BrakeSkid)   // Test to see if loco wheel is slipping, then coeff of friction will be decreased below static value. Sanding will override this somewhat
            {
                BaseFrictionCoefficientFactor = 0.15f * SandingFrictionCoefficientFactor;  // Descrease friction to take into account dynamic (kinetic) friction U = 0.0525
            }
            else 
            if (WheelSlip && ThrottlePercent < 0.1f && BrakeSkid) // Test to see if loco wheel is skidding due to brake application
            {
                BaseFrictionCoefficientFactor = 0.15f * SandingFrictionCoefficientFactor;  // Descrease friction to take into account dynamic (kinetic) friction U = 0.0525
            }
            
            // Icik
            Train.LocomotiveCoefficientFriction = BaseuMax * BaseFrictionCoefficientFactor * AdhesionMultiplier;  // Find friction coefficient factor for locomotive
            //Train.LocomotiveCoefficientFriction = MathHelper.Clamp(Train.LocomotiveCoefficientFriction, 0.05f, 0.8f); // Ensure friction coefficient never exceeds a "reasonable" value

            // Set adhesion conditions for diesel, electric or steam geared locomotives
            if (elapsedClockSeconds > 0)
            {
                LocomotiveAxle.AdhesionConditions = AdhesionMultiplier * AdhesionFilter.Filter(BaseFrictionCoefficientFactor + AdhesionRandom, elapsedClockSeconds);
                LocomotiveAxle.AdhesionConditions = MathHelper.Clamp(LocomotiveAxle.AdhesionConditions, 0.05f, 2.5f); // Avoids NaNs in axle speed computing
            }

            // Set adhesion conditions for other steam locomotives
            if (EngineType == EngineTypes.Steam && SteamEngineType != MSTSSteamLocomotive.SteamEngineTypes.Geared)  // ToDo explore adhesion factors
            {
                LocomotiveCoefficientFrictionHUD = Train.LocomotiveCoefficientFriction; // Set display value for HUD - steam
            }
            else
            {
                LocomotiveCoefficientFrictionHUD = BaseuMax * LocomotiveAxle.AdhesionConditions; // Set display value for HUD - diesel
            }


        }

        #endregion

        public void UpdateTrackSander(float elapsedClockSeconds)
        {
            // updates track sander in terms of sand usage and impact on air compressor
            // The following assumptions have been made:
            //
            // Icik
            TrackSanderSandConsumptionLpS = MathHelper.Clamp(TrackSanderSandConsumptionLpS, 0.025f, 0.05f);
            if (Sander)  // If sander is on adjust parameters
            {
                if (CurrentTrackSandBoxCapacityL > 0.0) // if sand still in sandbox then sanding is available
                {
                    // Calculate consumption of sand, and drop in sand box level
                    float ActualSandConsumptionLpS = TrackSanderSandConsumptionLpS * elapsedClockSeconds;
                    MassKG -= ActualSandConsumptionLpS * 1.4f;
                    CurrentTrackSandBoxCapacityL -= ActualSandConsumptionLpS;
                    CurrentTrackSandBoxCapacityL = MathHelper.Clamp(CurrentTrackSandBoxCapacityL, 0.0f, MaxTrackSandBoxCapacityL);
                    if (CurrentTrackSandBoxCapacityL == 0.0f)
                    {
                        if (IsLeadLocomotive())
                            Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("There's no more sand in the storage!"));
                        else
                        if (LocoHelperOn)
                            Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("Helper") + " - " + Simulator.Catalog.GetString("There's no more sand in the storage!"));
                    }
                }
                CurrentTrackSandBoxCapacityKG = (float)Math.Round(CurrentTrackSandBoxCapacityL * 1.4f, 2);

                // Calculate air consumption and change in main air reservoir pressure
                float ActualAirConsumptionM3pS = TrackSanderAirComsumptionLpS * elapsedClockSeconds / 1000f;
                float SanderPressureDiffPSI = ActualAirConsumptionM3pS / MainResVolumeM3;
                MainResPressurePSI -= SanderPressureDiffPSI;
                MainResPressurePSI = MathHelper.Clamp(MainResPressurePSI, 0.001f, MaxMainResPressurePSI);
                if (IsLeadLocomotive())
                    Simulator.Confirmer.Message(ConfirmLevel.Information, CurrentTrackSandBoxCapacityKG + " Kg");
                else
                if (LocoHelperOn)
                    Simulator.Confirmer.Message(ConfirmLevel.Information, Simulator.Catalog.GetString("Helper") + " " + CurrentTrackSandBoxCapacityKG + " Kg");
            }
            //Simulator.Confirmer.Message(ConfirmLevel.Warning, Simulator.Catalog.GetString("CurrentTrackSandBoxCapacityL: " + CurrentTrackSandBoxCapacityL));
        }

        public override bool GetSanderOn()
        {
            return Sander;
        }

        #region Reverser
        public void SetDirection(Direction direction)
        {
            if (Direction != direction && ThrottlePercent < 1)
            {
                Direction = direction;
                // Icik
                //switch (direction)
                //{
                //    case Direction.Reverse: SignalEvent(Event.ReverserToForwardBackward); break;
                //    case Direction.N: SignalEvent(Event.ReverserToNeutral); break;
                //    case Direction.Forward: SignalEvent(Event.ReverserToForwardBackward); break;
                //}
                //// passes event also to other locomotives
                //foreach (TrainCar car in Train.Cars)
                //{
                //    var loco = car as MSTSLocomotive;
                //    if (loco != null && car != this && loco.AcceptMUSignals)
                //        switch (direction)
                //        {
                //            case Direction.Reverse: loco.SignalEvent(Event.ReverserToForwardBackward); break;
                //            case Direction.N: loco.SignalEvent(Event.ReverserToNeutral); break;
                //            case Direction.Forward: loco.SignalEvent(Event.ReverserToForwardBackward); break;
                //        }

                //}
                //SignalEvent(Event.ReverserChange);
                if (direction == Direction.Forward)
                    Train.MUReverserPercent = 100;
                else
                    Train.MUReverserPercent = -100;
            }

        }

        public virtual void StartReverseIncrease(float? target)
        {
            // Icik
            if (!DirectionButton && !DieselDirectionController && !DieselDirectionController2 && !DieselDirectionController3 && !DieselDirectionController4 && !MirelRSControllerEnable)
            {
                if (DirectionPosition[LocoStation] < 1)
                {
                    DirectionPosition[LocoStation]++;
                    if (DirectionPosition[LocoStation] == 1)
                        SignalEvent(Event.ReverserToForwardBackward);
                    else
                        SignalEvent(Event.ReverserToNeutral);
                    SignalEvent(Event.ReverserChange);
                }
                
                if (StationIsActivated[LocoStation] && !this.DirectionControllerBlocked)
                {
                    AlerterReset(TCSEvent.ReverserChanged);
                    if (this.IsLeadLocomotive())
                    {
                        {
                            switch (Direction)
                            {
                                case Direction.Reverse: SetDirection(Direction.N); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral); break;
                                case Direction.N: SetDirection(Direction.Forward); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On); break;
                                case Direction.Forward: SetDirection(Direction.Forward); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.On); break;
                            }
                        }
                    }
                }
            }
        }

        public virtual void StartReverseDecrease(float? target)
        {
            // Icik
            if (!DirectionButton && !DieselDirectionController && !DieselDirectionController2 && !DieselDirectionController3 && !DieselDirectionController4 && !MirelRSControllerEnable)
            {
                if (DirectionPosition[LocoStation] > -1)
                {
                    DirectionPosition[LocoStation]--;
                    if (DirectionPosition[LocoStation] == -1)
                        SignalEvent(Event.ReverserToForwardBackward);
                    else
                        SignalEvent(Event.ReverserToNeutral);
                    SignalEvent(Event.ReverserChange);
                }

                if (StationIsActivated[LocoStation] && !this.DirectionControllerBlocked)
                {
                    AlerterReset(TCSEvent.ReverserChanged);
                    if (this.IsLeadLocomotive())
                    {
                        {
                            switch (Direction)
                            {
                                case Direction.Reverse: SetDirection(Direction.Reverse); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off); break;
                                case Direction.N: SetDirection(Direction.Reverse); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Off); break;
                                case Direction.Forward: SetDirection(Direction.N); Simulator.Confirmer.Confirm(CabControl.Reverser, CabSetting.Neutral); break;
                            }
                        }
                    }
                }
            }
        }
        #endregion

        #region ThrottleController
        public void StartThrottleIncrease(float? target)
        {
            // Icik
            if ((DieselDirectionController && DieselDirection_0) 
                || (DieselDirectionController2 && DieselDirection_0) 
                || (DieselDirectionController3 && DieselDirection_0) 
                || (DieselDirectionController4 && DieselDirection_0))
                return;
            if (AripotControllerEnable)
                return;
            if (MirerControllerEnable)
                return;
            if (MirelRSControllerEnable)
                return;
            if (CommandCylinderEnable)                            
                return;            

            if (LocoType != LocoTypes.Vectron) // vectron bdělost nevybaví (MichalM 2.10.2022)
                Mirel.ResetVigilance();
            
            if (CruiseControl != null && target != null)
            {
                if (CruiseControl.DisableCruiseControlOnThrottleAndZeroSpeed && CruiseControl.SelectedSpeedMpS == 0 && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
                {
                    CruiseControl.SpeedRegMode[LocoStation] = CruiseControl.SpeedRegulatorMode.Manual;
                }
                if (CruiseControl.DisableCruiseControlOnThrottleAndZeroForce && CruiseControl.SelectedMaxAccelerationPercent == 0 && SelectedMaxAccelerationStep[LocoStation] == 0 && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
                {
                    CruiseControl.SetSpeed(0);
                    CruiseControl.SpeedRegMode[LocoStation] = CruiseControl.SpeedRegulatorMode.Manual;
                }
                if ((CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.UseThrottleAsSpeedSelector)
                {
                    CruiseControl.SpeedRegulatorSelectedSpeedStartIncrease();
                    return;
                }
            }
            if (ThrottleController.CurrentValue >= ThrottleController.MaximumValue)
                return;

            if (target != null) ThrottleController.StartIncrease(target);
            else new NotchedThrottleCommand(Simulator.Log, true);

            SignalEvent(Event.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = Simulator.ClockTime;
        }

        public bool ForceHandleIncreasing = false;
        public bool ForceHandleDecreasing = false;
        public void StartThrottleIncrease()
        {
            if (DynamicBrakePercent > 0 && SpeedMpS == 0)
            {
                DynamicBrakePercent = 0;
                DynamicBrakeChangeActiveState(false);
            }
            if (LocoType != LocoTypes.Vectron)
            Mirel.ResetVigilance();
            if (UsingForceHandle)
            {
                ForceHandleIncreasing = true;
                return;
            }
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.Throttle || mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                    {
                        if (!mpc.StateChanged)
                        {
                            mpc.StateChanged = true;
                            mpc.DoMovement(MultiPositionController.Movement.Forward);
                        }
                        return;
                    }
                }
            }
            if (CruiseControl != null && (CombinedControlType == CombinedControl.None || CombinedControlType == CombinedControl.ThrottleDynamic))
            {
                if (CruiseControl.UseThrottleAsForceSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && DynamicBrakePercent < 1)
                {
                    CruiseControl.SpeedRegulatorMaxForceStartIncrease();
                    return;
                }
                else
                {
                    if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                    {
                        if (!CruiseControl.UseThrottleAsSpeedSelector)
                            return;
                    }
                }
            }
            bool checkBraking = true;
            if (CruiseControl != null)
            {
                if ((CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.UseThrottleAsSpeedSelector)
                {
                    checkBraking = false;
                }
            }
            if (DynamicBrakeController != null && DynamicBrakeController.CurrentValue >= 0 && (DynamicBrakePercent >= 0 || !(DynamicBrakePercent == -1 && !DynamicBrake || DynamicBrakePercent >= 0 && DynamicBrake)))
            {
                if (!(CombinedControlType == CombinedControl.ThrottleDynamic
                    || CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0))
                {
                    Simulator.Confirmer.Warning(CabControl.Throttle, CabSetting.Warn1);
                    return;
                }
            }

            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake)
                StartDynamicBrakeDecrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
                StartTrainBrakeDecrease(null);
            else
                StartThrottleIncrease(ThrottleController.SmoothMax());
        }

        public void StopThrottleIncrease()
        {
            ForceHandleIncreasing = false;
            if (LocoType != LocoTypes.Vectron)
                Mirel.ResetVigilance();
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.Throttle || mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                    {
                        if (mpc.StateChanged)
                        {
                            mpc.StateChanged = false;
                            mpc.DoMovement(MultiPositionController.Movement.Neutral);
                        }
                        return;
                    }
                }
            }
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsForceSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
                {
                    CruiseControl.SpeedRegulatorMaxForceStopIncrease();
                    return;
                }
                else
                {
                    if ((CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SelectedSpeedMpS > 0)
                    {
                        CruiseControl.SpeedRegulatorSelectedSpeedStopIncrease();
                        return;
                    }
                }
            }

            AlerterReset(TCSEvent.ThrottleChanged);
            ThrottleController.StopIncrease();

            if (CombinedControlType == CombinedControl.ThrottleDynamic)
                StopDynamicBrakeDecrease();
            else if (CombinedControlType == CombinedControl.ThrottleAir)
                StopTrainBrakeDecrease(0);
            else if (ThrottleController.SmoothMax() != null)
                new ContinuousThrottleCommand(Simulator.Log, true, ThrottleController.CurrentValue, CommandStartTime);
        }

        public void StartThrottleDecrease(float? target)
        {
            // Icik
            if ((DieselDirectionController && DieselDirection_0) 
                || (DieselDirectionController2 && DieselDirection_0) 
                || (DieselDirectionController3 && DieselDirection_0) 
                || (DieselDirectionController4 && DieselDirection_0))
                return;
            if (AripotControllerEnable)
                return;
            if (MirerControllerEnable)
                return;
            if (MirelRSControllerEnable)
                return;
            if (CommandCylinderEnable)
                return;                
  
            if (LocoType != LocoTypes.Vectron)
                Mirel.ResetVigilance();
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsSpeedSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.SelectedSpeedMpS > 0)
                {
                    CruiseControl.SpeedRegulatorSelectedSpeedStartDecrease();
                    return;
                }
            }
            if (ThrottleController.CurrentValue <= ThrottleController.MinimumValue)
                return;

            if (target != null) ThrottleController.StartDecrease(target);
            else new NotchedThrottleCommand(Simulator.Log, false);

            SignalEvent(Event.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = Simulator.ClockTime;
        }

        protected bool speedSelectorModeDecreasing = false;
        public void StartThrottleDecrease()
        {
            if (LocoType != LocoTypes.Vectron)
                Mirel.ResetVigilance();
            if (UsingForceHandle)
            {
                ForceHandleDecreasing = true;
                return;
            }
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.Throttle || mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                    {
                        if (!mpc.StateChanged)
                        {
                            mpc.StateChanged = true;
                            mpc.DoMovement(MultiPositionController.Movement.Aft);
                        }
                        return;
                    }
                }
            }
            if (CruiseControl != null)
            {
                if ((CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.UseThrottleAsSpeedSelector && CruiseControl.SelectedSpeedMpS > 0)
                {
                    ThrottleController.CurrentValue = 1;
                }
            }
            if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue <= 0)
                StartDynamicBrakeIncrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && ThrottleController.CurrentValue <= 0)
                StartTrainBrakeIncrease(null, 0);
            else
                StartThrottleDecrease(ThrottleController.SmoothMin());
        }

        public void StopThrottleDecrease()
        {
            if (LocoType != LocoTypes.Vectron)
                Mirel.ResetVigilance();
            if (UsingForceHandle)
            {
                ForceHandleDecreasing = false;
                return;
            }
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.Throttle || mpc.controllerBinding == MultiPositionController.ControllerBinding.Combined)
                    {
                        if (mpc.StateChanged)
                        {
                            mpc.StateChanged = false;
                            mpc.DoMovement(MultiPositionController.Movement.Neutral);
                        }
                        return;
                    }
                }
            }
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsSpeedSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.SelectedSpeedMpS > 0)
                {
                    CruiseControl.SpeedRegulatorSelectedSpeedStopDecrease();
                    CruiseControl.SpeedRegulatorMaxForceStopDecrease();
                    return;
                }
                else
                {
                    if ((CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && CruiseControl.SelectedSpeedMpS > 0)
                    {
                        CruiseControl.SpeedRegulatorSelectedSpeedStopDecrease();
                        CruiseControl.SpeedRegulatorMaxForceStopDecrease();
                        speedSelectorModeDecreasing = false;
                    }
                }
            }
            AlerterReset(TCSEvent.ThrottleChanged);
            ThrottleController.StopDecrease();

            if (CombinedControlType == CombinedControl.ThrottleDynamic)
                StopDynamicBrakeIncrease();
            else if (CombinedControlType == CombinedControl.ThrottleAir)
                StopTrainBrakeIncrease(0);
            if (ThrottleController.SmoothMin() != null)
                new ContinuousThrottleCommand(Simulator.Log, false, ThrottleController.CurrentValue, CommandStartTime);
        }

        //Steam Heat Controller

        #region Steam heating controller

        public void StartSteamHeatIncrease(float? target)
        {
            SteamHeatController.CommandStartTime = Simulator.ClockTime;
            if (IsPlayerTrain)
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.SteamHeat, CabSetting.Increase, SteamHeatController.CurrentValue * 100);
            SteamHeatController.StartIncrease(target);
            SignalEvent(Event.SteamHeatChange);
        }

        public void StopSteamHeatIncrease()
        {
            SteamHeatController.StopIncrease();
            new ContinuousSteamHeatCommand(Simulator.Log, 1, true, SteamHeatController.CurrentValue, SteamHeatController.CommandStartTime);
        }

        public void StartSteamHeatDecrease(float? target)
        {
            if (IsPlayerTrain)
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.SteamHeat, CabSetting.Decrease, SteamHeatController.CurrentValue * 100);
            SteamHeatController.StartDecrease(target);
            SignalEvent(Event.SteamHeatChange);
        }

        public void StopSteamHeatDecrease()
        {
            SteamHeatController.StopDecrease();
            if (IsPlayerTrain)
                new ContinuousSteamHeatCommand(Simulator.Log, 1, false, SteamHeatController.CurrentValue, SteamHeatController.CommandStartTime);
        }

        public void SteamHeatChangeTo(bool increase, float? target)
        {
            if (increase)
            {
                if (target > SteamHeatController.CurrentValue)
                {
                    StartSteamHeatIncrease(target);
                }
            }
            else
            {
                if (target < SteamHeatController.CurrentValue)
                {
                    StartSteamHeatDecrease(target);
                }
            }
        }

        public void SetSteamHeatValue(float value)
        {
            var controller = SteamHeatController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new ContinuousSteamHeatCommand(Simulator.Log, 1, change > 0, controller.CurrentValue, Simulator.GameTime);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.UpdateWithPerCent(CabControl.SteamHeat, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, controller.CurrentValue * 100);
        }

        public void ToggleWaterScoop()
        {
            if (Simulator.PlayerLocomotive == this)
            {
                WaterScoopDown = !WaterScoopDown;
                SignalEvent(Event.WaterScoopRaiseLower);
                if (WaterScoopDown)
                {
                    IsWaterScoopDown = true; // Set flag to potentially fill from water trough
                }
                else
                {
                    IsWaterScoopDown = false;
                    WaterScoopOverTroughFlag = false; // Reset flags so that message will come up again
                    WaterScoopNotFittedFlag = false;
                    WaterScoopSlowSpeedFlag = false;
                    WaterScoopDirectionFlag = false;
                }
                Simulator.Confirmer.Confirm(CabControl.WaterScoop, WaterScoopDown ? CabSetting.On : CabSetting.Off);
            }
        }

        #endregion

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        public void ThrottleChangeTo(bool increase, float? target)
        {
            if (increase)
            {
                if (target > ThrottleController.CurrentValue)
                {
                    StartThrottleIncrease(target);
                }
            }
            else
            {
                if (target < ThrottleController.CurrentValue)
                {
                    StartThrottleDecrease(target);
                }
            }
        }

        /// <summary>
        /// Used by commands to make a single adjustment.
        /// </summary>
        public void AdjustNotchedThrottle(bool increase)
        {
            if (increase)
            {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
            }
            else
            {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
            }
            Simulator.Confirmer.ConfirmWithPerCent(CabControl.Throttle, ThrottleController.CurrentValue * 100);
        }

        public void SetThrottleValue(float value)
        {
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsForceSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
                {
                    CruiseControl.SetMaxForcePercent((float)Math.Round(value * 100, 0));
                    return;
                }
                if (CruiseControl.UseThrottleAsSpeedSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
                {
                    CruiseControl.SetSpeed((float)Math.Round((MpS.ToKpH(MaxSpeedMpS) / 100) * value * 100, 0));
                    return;
                }
            }
            var controller = ThrottleController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new ContinuousThrottleCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(Event.ThrottleChange);
                AlerterReset(TCSEvent.ThrottleChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.UpdateWithPerCent(
                    this is MSTSSteamLocomotive ? CabControl.Regulator : CabControl.Throttle,
                    oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease,
                    controller.CurrentValue * 100);
        }

        public void SetThrottlePercent(float percent)
        {
            if (CruiseControl != null)
            {
                if (CruiseControl.UseThrottleAsForceSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV) && !UsingForceHandle)
                {
                    CruiseControl.SetMaxForcePercent(percent, true);
                    return;
                }
                else
                    ThrottleController.SetPercent(percent);
            }
            else
                ThrottleController.SetPercent(percent);
        }

        public void SetThrottlePercentWithSound(float percent)
        {
            var oldThrottlePercent = ThrottleController.CurrentValue * 100;
            SetThrottlePercent(percent);
            if (Math.Abs(oldThrottlePercent - ThrottleController.CurrentValue * 100) > 2)
                SignalEvent(Event.ThrottleChange);
        }

        public void ThrottleToZero()
        {
            if (CommandCylinderEnable)
                return;

            if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue <= 0)
                StartDynamicBrakeIncrease(null);
            else if (CombinedControlType == CombinedControl.ThrottleAir && ThrottleController.CurrentValue <= 0)
                StartTrainBrakeIncrease(null, 0);
            else
                StartThrottleToZero(0.0f);

        }

        public void StartThrottleToZero(float? target)
        {
            if (ThrottleController.CurrentValue <= ThrottleController.MinimumValue)
                return;

            ThrottleController.StartDecrease(target, true);
            if (ThrottleController.NotchCount() <= 0) SignalEvent(Event.ThrottleChange);
            AlerterReset(TCSEvent.ThrottleChanged);
            CommandStartTime = Simulator.ClockTime;
        }

        #endregion

        #region CombinedHandle
        /// <summary>
        /// Determines which sub-control of combined handle is to be set when receiving a combined value.
        /// Combined value is in 0-1 range, where arrangement is [[1--throttle--0]split[0--dynamic|airbrake--1]].
        /// </summary>
        public void SetCombinedHandleValue(float value)
        {
            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake != null && DynamicBrake)
            {
                if (DynamicBrakeController.CurrentValue == 0 && value < CombinedControlSplitPosition)
                    DynamicBrakeChangeActiveState(false);
                else if (DynamicBrakePercent > -1)
                    SetDynamicBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition));
            }
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
            {
                SetTrainBrakeValue((MathHelper.Clamp(value, CombinedControlSplitPosition, 1) - CombinedControlSplitPosition) / (1 - CombinedControlSplitPosition), 0);
            }
            else
            {
                if (CombinedControlType == CombinedControl.ThrottleDynamic && ThrottleController.CurrentValue == 0 && value > CombinedControlSplitPosition)
                    DynamicBrakeChangeActiveState(true);
                else if (DynamicBrakePercent < 0)
                    SetThrottleValue(1 - MathHelper.Clamp(value, 0, CombinedControlSplitPosition) / CombinedControlSplitPosition);
            }
        }

        /// <summary>
        /// Determines which sub-control of combined handle is active (based on its type), 
        /// and returns the overall position considering the split position. 
        /// </summary>
        /// <param name="intermediateValue">Whather asking for intermediate (for mouse operation) or notched (for displaying) value.</param>
        /// <returns>Combined position into 0-1 range, where arrangement is [[1--throttle--0]split[0--dynamic|airbrake--1]]</returns>
        public float GetCombinedHandleValue(bool intermediateValue)
        {            
            if (CombinedControlType == CombinedControl.ThrottleDynamic && DynamicBrake != null && DynamicBrake)
            {
                if (CruiseControl != null)
                {
                    if (CruiseControl.SkipThrottleDisplay && !UsingForceHandle)
                    {
                        return CombinedControlSplitPosition;
                    }
                    else
                    {
                        if (UsingForceHandle)
                            return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * ForceHandleValue / 100;
                        else
                            return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? -DynamicBrakeController.IntermediateValue : -DynamicBrakeController.CurrentValue);
                    }
                }
                else
                {
                    return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? DynamicBrakeController.IntermediateValue : DynamicBrakeController.CurrentValue);
                }
            }
            else if (CombinedControlType == CombinedControl.ThrottleAir && TrainBrakeController.CurrentValue > 0)
                return CombinedControlSplitPosition + (1 - CombinedControlSplitPosition) * (intermediateValue ? TrainBrakeController.IntermediateValue : TrainBrakeController.CurrentValue);
            else if (CruiseControl == null)
                return CombinedControlSplitPosition * (1 - (intermediateValue ? ThrottleController.IntermediateValue : ThrottleController.CurrentValue));
            else if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Manual)
            {
                if (UsingForceHandle)
                {
                    float test = -ForceHandleValue / 100;
                    test = 1 - test;
                    if (test < 0.02f && test > 0)
                        test = 0.021f;
                    test = CombinedControlSplitPosition * test;
                    test = test * 100;
                    return test;
                }
                return CombinedControlSplitPosition * (1 - (intermediateValue ? ThrottleController.IntermediateValue : ThrottleController.CurrentValue));
            }
            else if (CruiseControl.UseThrottleAsSpeedSelector)
                return CombinedControlSplitPosition * (1 - (CruiseControl.SelectedSpeedMpS / MaxSpeedMpS));
            else if (CruiseControl.UseThrottleAsForceSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
            {
                float test = CruiseControl.SelectedMaxAccelerationPercent / 100;
                if (UsingForceHandle)
                    test = -ForceHandleValue / 100;
                test = 1 - test;
                if (test < 0.02f && test > 0)
                    test = 0.021f;
                test = CombinedControlSplitPosition * test;
                test = test * 100;
                return test;
            }
            else
                return CombinedControlSplitPosition;

        }
        #endregion

        #region GearBoxController
        public virtual void ChangeGearUp()
        {
        }

        public virtual void StartGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StartIncrease();
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Increase, GearBoxController.CurrentNotch);
                AlerterReset(TCSEvent.GearBoxChanged);
                SignalGearBoxChangeEvents();
            }

            ChangeGearUp();
        }

        public virtual void StopGearBoxIncrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopIncrease();
            }
        }

        public virtual void ChangeGearDown()
        {
        }

        public virtual void StartGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StartDecrease();
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.CurrentNotch);
                AlerterReset(TCSEvent.GearBoxChanged);
                SignalGearBoxChangeEvents();
            }

            ChangeGearDown();
        }

        public virtual void StopGearBoxDecrease()
        {
            if (GearBoxController != null)
            {
                GearBoxController.StopDecrease();
            }
        }

        /// <summary>
        /// Trigger sound events when the gearbox increases or decreases.
        /// </summary>
        private void SignalGearBoxChangeEvents()
        {
            // Only activate sound event if notch has actually changed
            if (GearBoxController.CurrentNotch != PreviousGearBoxNotch)
            {
                switch (GearBoxController.CurrentNotch)
                {
                    case 0:
                        SignalEvent(Event.GearPosition0);
                        break;
                    case 1:
                        SignalEvent(Event.GearPosition1);
                        break;
                    case 2:
                        SignalEvent(Event.GearPosition2);
                        break;
                    case 3:
                        SignalEvent(Event.GearPosition3);
                        break;
                    case 4:
                        SignalEvent(Event.GearPosition4);
                        break;
                    case 5:
                        SignalEvent(Event.GearPosition5);
                        break;
                    case 6:
                        SignalEvent(Event.GearPosition6);
                        break;
                    case 7:
                        SignalEvent(Event.GearPosition7);
                        break;
                    default:
                        SignalEvent(Event.GearPosition8);
                        break;
                }
                PreviousGearBoxNotch = GearBoxController.CurrentNotch; // Update previous value for next time around
            }
        }

        public void SetGearBoxValue(float value)
        {
            var controller = GearBoxController;
            var oldValue = controller.CurrentValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                //new GarBoxCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(change > 0 ? Event.GearUp : Event.GearDown);
                AlerterReset(TCSEvent.GearBoxChanged);
            }
            if (oldValue != controller.CurrentValue)
                Simulator.Confirmer.ConfirmWithPerCent(CabControl.GearBox, CabSetting.Decrease, GearBoxController.CurrentNotch);
        }
        #endregion

        #region TrainBrakeController
        public bool TractionBlocked = false;
        public void StartTrainBrakeIncrease(float? target, int from) // from 0 = keyboard, 1 = CruiseControl
        {
            if (TrainBrakeController.BS2ControllerOnStation && !StationIsActivated[LocoStation])
                return;

            TractionBlocked = true;

            if (Mirel.Equipped && !Mirel.BlueLight && Mirel.initTest == Mirel.InitTest.Passed && SpeedMpS > 0) Mirel.AlerterPressed(true);
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.TrainBrake)
                    {
                        mpc.DoMovement(MultiPositionController.Movement.Aft);
                        SignalEvent(Event.TrainBrakeChange);
                        return;
                    }
                }
            }
            if (CombinedControlType == CombinedControl.ThrottleAir)
                ThrottleController.SetValue(0);

            TrainBrakeController.StartIncrease(target);
            TrainBrakeController.CommandStartTime = Simulator.ClockTime;
            if (CruiseControl != null)
            {
                CruiseControl.TrainBrakePriority = true;
                if (from == 0)
                    CruiseControl.IReallyWantToBrake = true;
            }
        }

        public void StopTrainBrakeIncrease(int from)
        {
            if (Mirel.Equipped && !Mirel.BlueLight && Mirel.initTest == Mirel.InitTest.Passed && SpeedMpS > 0) Mirel.AlerterPressed(true);
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.TrainBrake)
                    {
                        mpc.DoMovement(MultiPositionController.Movement.Neutral);
                        SignalEvent(Event.TrainBrakeChange);
                        return;
                    }
                }
            }
            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StopIncrease();
            new TrainBrakeCommand(Simulator.Log, true, TrainBrakeController.CurrentValue, TrainBrakeController.CommandStartTime, from);
        }

        public void StartTrainBrakeDecrease(float? target, bool toZero = false)
        {
            if (TrainBrakeController.BS2ControllerOnStation && !StationIsActivated[LocoStation])
                return;

            if (Mirel.Equipped && !Mirel.BlueLight && Mirel.initTest == Mirel.InitTest.Passed && SpeedMpS > 0) Mirel.AlerterPressed(true);
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.TrainBrake)
                    {
                        mpc.DoMovement(MultiPositionController.Movement.Forward);
                        SignalEvent(Event.TrainBrakeChange);
                        return;
                    }
                }
            }
            TrainBrakeController.StartDecrease(target, toZero);
            TrainBrakeController.CommandStartTime = Simulator.ClockTime;
        }

        public void StopTrainBrakeDecrease(int from)
        {
            if (CruiseControl != null)
                if (Mirel.Equipped && !Mirel.BlueLight && Mirel.initTest == Mirel.InitTest.Passed && SpeedMpS > 0 && CruiseControl.SpeedRegMode[LocoStation] != CruiseControl.SpeedRegulatorMode.Manual)
                    Mirel.AlerterPressed(true);
                else
                if (Mirel.Equipped && !Mirel.BlueLight && Mirel.initTest == Mirel.InitTest.Passed && SpeedMpS > 0)
                    Mirel.AlerterPressed(true);
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.TrainBrake)
                    {
                        mpc.DoMovement(MultiPositionController.Movement.Neutral);
                        SignalEvent(Event.TrainBrakeChange);
                        return;
                    }
                }
            }

            if (TrainBrakeController.Notches[TrainBrakeController.CurrentNotch].SpringLoaded)
                TrainBrakeController.StartIncrease();

            AlerterReset(TCSEvent.TrainBrakeChanged);
            TrainBrakeController.StopDecrease();
            new TrainBrakeCommand(Simulator.Log, false, TrainBrakeController.CurrentValue, TrainBrakeController.CommandStartTime, from);
        }

        /// <summary>
        /// Used by commands to start a continuous adjustment.
        /// </summary>
        /// <param name="increase"></param>
        /// <param name="target"></param>
        public void TrainBrakeChangeTo(bool increase, float? target, int from)
        {  // Need a better way to express brake as a single number?
            if (increase)
            {
                if (target > TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeIncrease(target, from);
                }
            }
            else
            {
                if (target < TrainBrakeController.CurrentValue)
                {
                    StartTrainBrakeDecrease(target);
                }
            }
        }

        //Debrief Eval
        public static int DbfEvalFullTrainBrakeUnder8kmh = 0;
        public bool ldbfevalfulltrainbrakeunder8kmh = false;

        public override string GetTrainBrakeStatus()
        {
            var train = Simulator.PlayerLocomotive.Train;//Debrief Eval
            string s = TrainBrakeController.GetStatus();

            // Icik
            // Vyjímka pro BS2 ovladač
            if (s == Simulator.Catalog.GetString("Release position") && TrainBrakeController.BS2ControllerOnStation)
            {
                s = Simulator.Catalog.GetString("Driving position");
            }

            if (s == "Emergency" && train.LeadLocomotive != null && !ldbfevalfulltrainbrakeunder8kmh && train.LeadLocomotive.IsPlayerTrain && Math.Abs(train.SpeedMpS) < 2.22222)
            {

                DbfEvalFullTrainBrakeUnder8kmh++;
                ldbfevalfulltrainbrakeunder8kmh = true;
                train.DbfEvalValueChanged = true;//Debrief eval
            }
            if (s != "Emergency" && ldbfevalfulltrainbrakeunder8kmh)
                ldbfevalfulltrainbrakeunder8kmh = false;

            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetFullStatus(lastCar.BrakeSystem, BrakeSystemPressureUnits);
            return s;
        }
        // Icik
        public string GetTrainBrakeStatusSimple()
        {
            var train = Simulator.PlayerLocomotive.Train;//Debrief Eval
            string s = TrainBrakeController.GetStatus();

            // Icik
            // Vyjímka pro BS2 ovladač
            if (s == Simulator.Catalog.GetString("Release position") && TrainBrakeController.BS2ControllerOnStation)
            {
                s = Simulator.Catalog.GetString("Driving position");
            }

            TrainCar lastCar = Train.Cars[Train.Cars.Count - 1];
            if (lastCar == this)
                lastCar = Train.Cars[0];
            s += BrakeSystem.GetSimpleStatus(lastCar.BrakeSystem, BrakeSystemPressureUnits);
            return s;
        }

        public void SetTrainBrakeValue(float value, int from)
        {
            var controller = TrainBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            bool alertChange = true;

            if (CruiseControl != null)
                if (CruiseControl.arrIsBraking)
                    alertChange = false;

            if (change != 0)
            {
                new TrainBrakeCommand(Simulator.Log, change > 0, value, Simulator.ClockTime, from);
                if (alertChange)
                {
                    SignalEvent(Event.TrainBrakeChange);
                    AlerterReset(TCSEvent.TrainBrakeChanged);
                }
            }
            if (oldValue != controller.IntermediateValue && alertChange)
                Simulator.Confirmer.Update(CabControl.TrainBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetTrainBrakeStatus());
        }

        public void SetTrainBrakePercent(float percent)
        {
            // Insure we have TrainBrakeController ; some vehicles do not
            // such as Hy-rail truck
            // if (HasTrainBrake)
            if (TrainBrakeController.IsValid())
                TrainBrakeController.SetPercent(percent);
        }
        #endregion

        #region EngineBrakeController        
        public void StartEngineBrakeIncrease(float? target)
        {
            CanCheckEngineBrake = false;
            EngineBrakePriority = true;
            AlerterReset(TCSEvent.EngineBrakeChanged);
            if (EngineBrakeController == null)
                return;

            EngineBrakeController.StartIncrease(target);
            Simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopEngineBrakeIncrease()
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StopIncrease();
            new EngineBrakeCommand(Simulator.Log, true, EngineBrakeController.CurrentValue, EngineBrakeController.CommandStartTime);
        }

        public void StartEngineBrakeDecrease(float? target)
        {
            if (LocoType == LocoTypes.Vectron)
            {
                if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                {
                    ManualParkingBrakeReleaseRequired = false;
                }
            }

            if (EngineBrakeController == null)
                return;
            
            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StartDecrease(target);
            EngineBrakeController.CommandStartTime = Simulator.ClockTime; // Remember when the command was issued
            Simulator.Confirmer.Confirm(CabControl.EngineBrake, CabSetting.Increase, GetEngineBrakeStatus());            
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopEngineBrakeDecrease()
        {
            if (EngineBrakeController == null)
                return;

            AlerterReset(TCSEvent.EngineBrakeChanged);
            EngineBrakeController.StopDecrease();
            new EngineBrakeCommand(Simulator.Log, false, EngineBrakeController.CurrentValue, EngineBrakeController.CommandStartTime);
        }

        public void EngineBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeIncrease(target);
                }
            }
            else
            {
                if (target < EngineBrakeController.CurrentValue)
                {
                    StartEngineBrakeDecrease(target);
                }
            }
        }

        public void SetEngineBrakeValue(float value)
        {
            var controller = EngineBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new EngineBrakeCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                //SignalEvent(Event.EngineBrakeChange);
                AlerterReset(TCSEvent.EngineBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.Update(CabControl.EngineBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetEngineBrakeStatus());
        }

        public void SetEngineBrakePercent(float percent)
        {
            if (EngineBrakeController == null)
                return;
            EngineBrakeController.SetPercent(percent);
        }

        public override string GetEngineBrakeStatus()
        {
            if (EngineBrakeController == null)
                return null;
            // If brake type is only a state, and no numerical fraction application is displayed in the HUD, then display Brake Cylinder (BC) pressure
            if (String.IsNullOrEmpty(EngineBrakeController.GetStateFractionScripted())) // Test to see if a brake state only is present without a fraction of application, if no fraction display BC pressure
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    if (SteamEngineBrakeFitted)
                    {
                        const float percentageConversion = 100;
                        return string.Format("{0} {1}%", EngineBrakeController.GetStatus(), percentageConversion * EngineBrakeController.CurrentValue);  // Display for steam brake
                    }
                    else
                    {
                        return string.Format("{0} BC {1}", EngineBrakeController.GetStatus(), FormatStrings.FormatPressure(Vac.FromPress(Train.HUDLocomotiveBrakeCylinderPSI), PressureUnit.InHg, PressureUnit.InHg, true)); // display for vacuum brakes
                    }
                }
                else
                {
                    return string.Format("{0} BC {1} {2}", EngineBrakeController.GetStatus(), FormatStrings.FormatPressure(Train.HUDLocomotiveBrakeCylinderPSI, PressureUnit.PSI, MainPressureUnit, true), BailOff ? " BailOff" : "");
                }

                // Fraction not found so display BC                
            }
            else
            {
                if ((BrakeSystem is VacuumSinglePipe))
                {
                    return string.Format("{0}", EngineBrakeController.GetStatus());  // Fraction found so don't display BC
                }
                else
                {
                    return string.Format("{0}{1}", EngineBrakeController.GetStatus(), BailOff ? " BailOff" : "");  // Fraction found so don't display BC
                }
            }
        }
        #endregion

        #region BrakemanBrakeController

        public void StartBrakemanBrakeIncrease(float? target)
        {
            AlerterReset(TCSEvent.BrakemanBrakeChanged);
            if (BrakemanBrakeController == null)
                return;

            BrakemanBrakeController.StartIncrease(target);
            Simulator.Confirmer.Confirm(CabControl.BrakemanBrake, CabSetting.Increase, GetBrakemanBrakeStatus());
            //            SignalEvent(Event.EngineBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopBrakemanBrakeIncrease()
        {
            if (BrakemanBrakeController == null)
                return;

            //   AlerterReset(TCSEvent.BrakemanBrakeChanged);
            BrakemanBrakeController.StopIncrease();
            new BrakemanBrakeCommand(Simulator.Log, true, BrakemanBrakeController.CurrentValue, BrakemanBrakeController.CommandStartTime);
        }

        public void StartBrakemanBrakeDecrease(float? target)
        {
            if (BrakemanBrakeController == null)
                return;

            AlerterReset(TCSEvent.BrakemanBrakeChanged);
            BrakemanBrakeController.StartDecrease(target);
            BrakemanBrakeController.CommandStartTime = Simulator.ClockTime; // Remember when the command was issued
            Simulator.Confirmer.Confirm(CabControl.BrakemanBrake, CabSetting.Increase, GetBrakemanBrakeStatus());
            //   SignalEvent(Event.BrakemanBrakeChange);
        }

        /// <summary>
        /// Ends change of brake value.
        /// </summary>
        public void StopBrakemanBrakeDecrease()
        {
            if (BrakemanBrakeController == null)
                return;

            AlerterReset(TCSEvent.BrakemanBrakeChanged);
            BrakemanBrakeController.StopDecrease();
            new BrakemanBrakeCommand(Simulator.Log, false, BrakemanBrakeController.CurrentValue, BrakemanBrakeController.CommandStartTime);
        }

        public void BrakemanBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (increase)
            {
                if (target > BrakemanBrakeController.CurrentValue)
                {
                    StartBrakemanBrakeIncrease(target);
                }
            }
            else
            {
                if (target < BrakemanBrakeController.CurrentValue)
                {
                    StartBrakemanBrakeDecrease(target);
                }
            }
        }

        public void SetBrakemanBrakeValue(float value)
        {
            var controller = BrakemanBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new BrakemanBrakeCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                //   SignalEvent(Event.BrakemanBrakeChange);
                AlerterReset(TCSEvent.BrakemanBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.Update(CabControl.BrakemanBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, GetBrakemanBrakeStatus());
        }

        public void SetBrakemanBrakePercent(float percent)
        {
            if (BrakemanBrakeController == null)
                return;
            BrakemanBrakeController.SetPercent(percent);
        }

        public override string GetBrakemanBrakeStatus()
        {
            if (BrakemanBrakeController == null)
                return null;
            return string.Format("{0}", BrakemanBrakeController.GetStatus());
        }

        #endregion

        #region DynamicBrakeController
        public void StartDynamicBrakeIncrease(float? target)
        {
            if (MirelRSControllerEnable)
                return;

            if (DynamicBrakeController == null)
                return;
            AlerterReset(TCSEvent.DynamicBrakeChanged);

            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.DynamicBrake)
                    {
                        if (!mpc.StateChanged)
                        {
                            mpc.StateChanged = true;
                            mpc.DoMovement(MultiPositionController.Movement.Aft);
                        }
                        return;
                    }
                }
            }
            if (CruiseControl != null)
            {
                SetThrottlePercent(0);
                CruiseControl.DynamicBrakePriority = true;
            }

            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent < 0)
            {
                DynamicBrakeChangeActiveState(true);
            }
            else if (DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartIncrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeIncrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public float RequiredDeceleration = 0;
        public float RequiredDecelerationPercent = 0;
        public float MaxRequiredDeceleration = -0.75f;
        public float RequiredDecelerationPercentDisplay = 0;
        public void StartAnyBrakeIncrease(float elapsedClockSeconds)
        {
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            float step = 100 / DynamicBrakeFullRangeIncreaseTimeSeconds;
            step *= elapsedClockSeconds;
            RequiredDecelerationPercent += step * 2;
            if (RequiredDecelerationPercent > 100)
                RequiredDecelerationPercent = 100;
            RequiredDecelerationPercentDisplay = RequiredDecelerationPercent;
            RequiredDeceleration = MaxRequiredDeceleration * RequiredDecelerationPercent / 100;
        }

        public void TryKeepDeceleration(float elapsedClockSeconds)
        {
            if ((!CruiseControl.doNotForceDynamicBrake || RequiredDecelerationPercent < DynamicBrakePercent || DynamicBrakePercent == -1) && AbsSpeedMpS > 0)
            {
                RequiredDecelerationPercentDisplay = RequiredDecelerationPercent;
            }
            if (RequiredDeceleration == 0 || AbsSpeedMpS == 0)
            {
                return;
            }
            if (AbsSpeedMpS == 0 && DynamicBrakePercent > -1)
                DynamicBrakeChangeActiveState(false);
            if (ControllerVolts > 0)
            {
                ControllerVolts = 0;
            }
            else if (true)
            {
                if (DynamicBrakeAvailable && PowerOn && DynamicBrakePercent < 99)
                {
                    if (true)
                    {
                        ThrottleController.SetPercent(0);
                        if (AccelerationMpSS > RequiredDeceleration)
                        {
                            if (DynamicBrakePercent == -1)
                                DynamicBrakeChangeActiveState(true);
                            StopDynamicBrakeDecrease();
                            float step = 100 / DynamicBrakeFullRangeIncreaseTimeSeconds;
                            step *= elapsedClockSeconds * 10;
                            StartDynamicBrakeIncrease(1);
                        }
                        else
                        {
                            StopDynamicBrakeIncrease();
                            float step = 100 / DynamicBrakeFullRangeDecreaseTimeSeconds;
                            step *= elapsedClockSeconds;
                            StartDynamicBrakeDecrease(0);
                        }
                    }
                }
                else // use TrainBrake
                {
                    if (AccelerationMpSS > RequiredDeceleration && AbsSpeedMpS > 0)
                    {
                        if (Train.EqualReservoirPressurePSIorInHg > 0)
                            Train.EqualReservoirPressurePSIorInHg -= TrainBrakeController.ApplyRatePSIpS * elapsedClockSeconds / 2;
                        if (Train.EqualReservoirPressurePSIorInHg < 0)
                            Train.EqualReservoirPressurePSIorInHg = 0;
                    }
                    else if (AccelerationMpSS +0.02 < RequiredDeceleration)
                    {
                        if (Train.EqualReservoirPressurePSIorInHg < TrainBrakeController.MaxPressurePSI)
                            Train.EqualReservoirPressurePSIorInHg += TrainBrakeController.ReleaseRatePSIpS * elapsedClockSeconds / 2;
                        if (Train.EqualReservoirPressurePSIorInHg > TrainBrakeController.MaxPressurePSI)
                            Train.EqualReservoirPressurePSIorInHg = TrainBrakeController.MaxPressurePSI;
                    }
                }

                if (AccelerationMpSS > RequiredDeceleration && DynamicBrakePercent == -1)
                {
                    if (Train.EqualReservoirPressurePSIorInHg > 0)
                        Train.EqualReservoirPressurePSIorInHg -= TrainBrakeController.ApplyRatePSIpS * elapsedClockSeconds / 10;
                    if (Train.EqualReservoirPressurePSIorInHg < 0)
                        Train.EqualReservoirPressurePSIorInHg = 0;
                }
            }
        }
        public void StopDynamicBrakeIncrease()
        {
            StopDynamicBrakeIncrease(false);
        }
        public void StopDynamicBrakeIncrease(bool byKeyBoard)
        {
            if (DynamicBrakeController == null)
                return;
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.DynamicBrake)
                    {
                        if (mpc.StateChanged && byKeyBoard)
                        {
                            mpc.StateChanged = false;
                            mpc.DoMovement(MultiPositionController.Movement.Neutral);
                        }
                        return;
                    }
                }
            }
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopIncrease();
                new DynamicBrakeCommand(Simulator.Log, true, DynamicBrakeController.CurrentValue, DynamicBrakeController.CommandStartTime);
            }
        }

        public void StartDynamicBrakeDecrease(float? target)
        {
            if (DynamicBrakeController == null)
                return;
            AlerterReset(TCSEvent.DynamicBrakeChanged);

            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.DynamicBrake)
                    {
                        if (!mpc.StateChanged)
                        {
                            mpc.StateChanged = true;
                            mpc.DoMovement(MultiPositionController.Movement.Forward);
                        }
                        return;
                    }
                }
            }

            if (!CanUseDynamicBrake())
                return;

            if (DynamicBrakePercent <= 0)
            {
                DynamicBrakeChangeActiveState(false);
            }
            else if (DynamicBrake)
            {
                SignalEvent(Event.DynamicBrakeChange);
                DynamicBrakeController.StartDecrease(target);
                if (!HasSmoothStruc)
                {
                    StopDynamicBrakeDecrease();
                    Simulator.Confirmer.ConfirmWithPerCent(CabControl.DynamicBrake, DynamicBrakeController.CurrentValue * 100);
                }
            }
        }

        public void StopDynamicBrakeDecrease()
        {
            if (DynamicBrakeController == null)
                return;
            AlerterReset(TCSEvent.DynamicBrakeChanged);
            if (MultiPositionControllers != null)
            {
                foreach (MultiPositionController mpc in MultiPositionControllers)
                {
                    if (mpc.controllerBinding == MultiPositionController.ControllerBinding.DynamicBrake)
                    {
                        if (mpc.StateChanged)
                        {
                            mpc.StateChanged = false;
                            mpc.DoMovement(MultiPositionController.Movement.Neutral);
                        }
                        return;
                    }
                }
            }
            if (CanUseDynamicBrake())
            {
                DynamicBrakeController.StopDecrease();
                new DynamicBrakeCommand(Simulator.Log, false, DynamicBrakeController.CurrentValue, DynamicBrakeController.CommandStartTime);
                if (CruiseControl != null)
                {
                    if (DynamicBrakePercent < 1)
                        CruiseControl.DynamicBrakePriority = false;
                }
            }
        }

        public void DynamicBrakeChangeTo(bool increase, float? target)
        {  // Need a better way to express brake as a single number.
            if (DynamicBrakeController == null)
                return;

            if (increase)
            {
                if (target > DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeIncrease(target);
                }
            }
            else
            {
                if (target < DynamicBrakeController.CurrentValue)
                {
                    StartDynamicBrakeDecrease(target);
                }
            }
        }

        public void SetDynamicBrakeValue(float value)
        {
            if (DynamicBrakeController == null)
                return;
            if (!DynamicBrake && ThrottleController.CurrentValue == 0 && value > 0.05f)
                DynamicBrakeChangeActiveState(true);
            if (DynamicBrake && DynamicBrakeController.CurrentValue == 0 && value < -0.05f)
            {
                DynamicBrakeChangeActiveState(false);
                return;
            }
            if (!DynamicBrake)
                return;

            var controller = DynamicBrakeController;
            var oldValue = controller.IntermediateValue;
            var change = controller.SetValue(value);
            if (change != 0)
            {
                new DynamicBrakeCommand(Simulator.Log, change > 0, controller.CurrentValue, Simulator.ClockTime);
                SignalEvent(Event.DynamicBrakeChange);
                AlerterReset(TCSEvent.DynamicBrakeChanged);
            }
            if (oldValue != controller.IntermediateValue)
                Simulator.Confirmer.UpdateWithPerCent(CabControl.DynamicBrake, oldValue < controller.IntermediateValue ? CabSetting.Increase : CabSetting.Decrease, DynamicBrakeController.CurrentValue * 100);
        }

        public void SetDynamicBrakePercent(float percent)
        {
            if (DynamicBrakeController == null)
                return;
            if (!CanUseDynamicBrake())
                return;
            DynamicBrakeController.SetPercent(percent);
            DynamicBrakeChangeActiveState(percent >= 0);
        }

        public void SetDynamicBrakePercentWithSound(float percent)
        {
            if (DynamicBrakeController == null)
                return;
            if (!CanUseDynamicBrake())
                return;
            var oldDynamicBrakePercent = DynamicBrakeController.CurrentValue * 100;
            SetDynamicBrakePercent(percent);
            if (Math.Abs(oldDynamicBrakePercent - DynamicBrakeController.CurrentValue * 100) > 2)
                SignalEvent(Event.DynamicBrakeChange);
        }

        public void DynamicBrakeChangeActiveState(bool toState)
        {
            if (DynamicBrakeController == null)
                return;
            if (toState && !DynamicBrake && DynamicBrakePercent < 0)
            {
                DynamicBrakePercent = 0;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
            else if (!toState && DynamicBrake && DynamicBrakePercent > -1 && DynamicBrakeIntervention < 0)
            {
                SignalEvent(Event.DynamicBrakeOff);
                DynamicBrakePercent = -1;
                DynamicBrakeController.CommandStartTime = Simulator.ClockTime;
                StopDynamicBrakeIncrease();
            }
        }

        public bool CanUseDynamicBrake()
        {
            return (DynamicBrakeController != null
                && ThrottlePercent == 0);
        }

        public override string GetDynamicBrakeStatus()
        {
            if (DynamicBrakeController == null)
                return null;
            if (DynamicBrakePercent < 0)
                return string.Empty;
            if (TrainControlSystem.FullDynamicBrakingOrder)
                return string.Format("{0:F0}%", DynamicBrakePercent);
            return string.Format("{0}", DynamicBrakeController.GetStatus());
        }
        #endregion


        public float CanAccelerateTime = 0;
        public bool CanAccelerate(float elapsedClockTime, float controllerVolts)
        {
            bool ret = false;
            if (CurrentDirection == CurrentDirectionEnum.Braking && CanAccelerateTime < AcceleratingToBrakingChangeTime + 0.01f)
            {
                CanAccelerateTime += elapsedClockTime;
            }
            if (CanAccelerateTime > AcceleratingToBrakingChangeTime)
            {
                CanBrakeTime = 0;
                CurrentDirection = CurrentDirectionEnum.Accelerating;
                ret = true;
            }
            return ret;
        }

        public float CanBrakeTime = 0;
        public bool CanBrake(float elapsedClockTime, float controllerVolts)
        {
            bool ret = false;
            if (CurrentDirection == CurrentDirectionEnum.Accelerating && CanBrakeTime < AcceleratingToBrakingChangeTime + 0.01f)
            {
                CanBrakeTime += elapsedClockTime;
            }
            if (CanBrakeTime > AcceleratingToBrakingChangeTime)
            {
                CanAccelerateTime = 0;
                CurrentDirection = CurrentDirectionEnum.Braking;
                ret = true;
            }
            return ret;
        }

        public virtual void SetPower(bool ToState)
        {

        }

        internal void ToggleMUCommand(bool ToState)
        {
            //AcceptMUSignals = ToState;
            //AcceptPowerSignals = ToState;
            if (Simulator.LocoCount > 1)
                AcceptCableSignals = ToState;
        }

        // Icik
        internal void ToggleHelperCommand(bool ToState)
        {
            AcceptHelperSignals = ToState;
        }

        public void SetTrainHandbrake(bool apply)
        {
            if (apply)
            {
                Train.SetHandbrakePercent(100);
                Simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.On);
            }
            else
            {
                Train.SetHandbrakePercent(0);
                Simulator.Confirmer.Confirm(CabControl.Handbrake, CabSetting.Off);
            }
        }

        public void SetTrainRetainers(bool apply)
        {
            Train.SetRetainers(apply);
            Simulator.Confirmer.ConfirmWithPerCent(CabControl.Retainers, CabSetting.Increase, Train.RetainerPercent, (int)CabSetting.Range1 + (int)Train.RetainerSetting);
        }

        public void BrakeHoseConnect(bool apply)
        {
            if (apply)
            {
                Train.ConnectBrakeHoses();
                Simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.On);
            }
            else
            {
                Train.DisconnectBrakes();
                Simulator.Confirmer.Confirm(CabControl.BrakeHose, CabSetting.Off);
            }
        }

        public bool[] wasCabLightSetOn = new bool[3];
        public void ToggleCabLight()
        {
            if (this is MSTSSteamLocomotive)
                return;
            CabLightOn[LocoStation] = !CabLightOn[LocoStation];
            wasCabLightSetOn[LocoStation] = CabLightOn[LocoStation];
            if (CabFloodLightOn[LocoStation])
                CabLightOn[LocoStation] = false;
            SignalEvent(Event.CabLightSwitchToggle);
            Simulator.Confirmer.Confirm(CabControl.CabLight, CabLightOn[LocoStation] ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleCabFloodLight()
        {
            if (this is MSTSSteamLocomotive)
                return;
            CabFloodLightOn[LocoStation] = !CabFloodLightOn[LocoStation];
            if (CabFloodLightOn[LocoStation])
                CabLightOn[LocoStation] = false;
            else
                CabLightOn[LocoStation] = wasCabLightSetOn[LocoStation];
            SignalEvent(Event.CabLightSwitchToggle);
            Simulator.Confirmer.Confirm(CabControl.CabFloodLight, CabFloodLightOn[LocoStation] ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleBattery()
        {
            if (CabStationForBatterySwitchOn == 1 && UsingRearCab) return;
            if (CabStationForBatterySwitchOn == 2 && !UsingRearCab) return;
            if (CabStationForBatterySwitchOn > 2) return;

            Battery = !Battery;
            if (Battery)
            {
                BatterySetOn = true;
                SignalEvent(Event.BatteryOn);
                if (PowerKey) SignalEvent(Event.PowerKeyOn);
            }
            else
            {
                SignalEvent(Event.BatteryOff);
                SignalEvent(Event.PowerKeyOff);
            }
            if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.Battery, Battery ? CabSetting.On : CabSetting.Off);
        }


        public void TogglePowerKeyUp()
        {
            if (DieselDirectionController || DieselDirectionController2)
            {
                if (!AcceptMUSignals)
                    return;
                if (!Simulator.PowerKeyInPocket && PowerKeyPosition[LocoStation] == 0 && AcceptMUSignals)
                    Simulator.Confirmer.MSG(Simulator.Catalog.GetString("You have no Powerkey in pocket!"));
                if (!DieselDirectionControllerInOut)
                    return;
            }
            if ((DieselDirectionController && DieselDirectionControllerPosition[LocoStation] != 2)
                || (DieselDirectionController2 && DieselDirectionController2Position[LocoStation] != 0)
                || (DieselDirectionController4 && DieselDirectionController2Position[LocoStation] != 1))
                return;

            if (Simulator.PowerKeyInPocket && PowerKeyPosition[LocoStation] == 0)
            {
                PowerKeyPosition[LocoStation] = 1;
                if (PowerKeyPosition[LocoStation] == 1)
                {
                    this.CarPowerKey = false;
                    PowerKey = false;
                    SignalEvent(Event.PowerKeyIn);
                    Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Powerkey in station!"));
                }
                if ((DieselDirectionController || DieselDirectionController2))
                    PowerKeyPosition[LocoStation] = 2;
                return;
            }

            if (PowerKeyPosition[LocoStation] > 0 && PowerKeyPosition[LocoStation] < 2)
            {
                PowerKeyPosition[LocoStation]++;
                
                if (!CarHavePocketPowerKey)
                {
                    if (PowerKeyPosition[1] == PowerKeyPosition[2] || !Simulator.PowerKeyNoPocketBlocked)
                    {
                        PowerKeyPosition[LocoStation]--;
                        Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Powerkey blocked!"));
                        return;
                    }
                }
                
                if (PowerKeyPosition[LocoStation] == 2)
                {
                    this.CarPowerKey = true;
                    PowerKey = true;
                    SignalEvent(Event.PantographToggle);
                    if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.PowerKey, PowerKey ? CabSetting.On : CabSetting.Off);
                }
                return;
            }

            if (!Simulator.PowerKeyInPocket && PowerKeyPosition[LocoStation] == 0)
                Simulator.Confirmer.MSG(Simulator.Catalog.GetString("You have no Powerkey in pocket!"));
        }
        public void TogglePowerKeyDown()
        {
            if (DieselDirectionController || DieselDirectionController2)
                return;

            if ((DieselDirectionController && DieselDirectionControllerPosition[LocoStation] != 2)
                || (DieselDirectionController2 && DieselDirectionController2Position[LocoStation] != 0)
                || (DieselDirectionController4 && DieselDirectionController2Position[LocoStation] != 1))
                return;            

            if (PowerKeyPosition[LocoStation] > 0)
            {
                PowerKeyPosition[LocoStation]--;

                if (!CarHavePocketPowerKey)
                {
                    if (PowerKeyPosition[LocoStation] == 0)
                    {
                        PowerKeyPosition[LocoStation]++;
                        return;
                    }                    
                }

                if (PowerKeyPosition[LocoStation] == 1)
                {
                    this.CarPowerKey = false;
                    PowerKey = false;
                    SignalEvent(Event.PowerKeyOff);
                    if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.PowerKey, PowerKey ? CabSetting.On : CabSetting.Off);
                }
            }
        }

        bool SetPowerKeySound;
        int TogglePowerKeyCycle = 0;
        public void TogglePowerKey()
        {
            LocoStation = 1;
            if (UsingRearCab)
                LocoStation = 2;            

            if (PowerKeyPosition[LocoStation] == 2)
                StationIsActivated[LocoStation] = true;
            else
                StationIsActivated[LocoStation] = false;

            if ((DieselDirectionController && DieselDirectionControllerPosition[LocoStation] != 2)
                || (DieselDirectionController2 && DieselDirectionController2Position[LocoStation] != 0)
                || (DieselDirectionController4 && DieselDirectionController2Position[LocoStation] != 1))
                return;

            if (!CarHavePocketPowerKey)
            {
                if (PowerKeyPosition[LocoStation] == 0)
                {
                    PowerKeyPosition[LocoStation]++;
                    return;
                }
            }            

            if (IsLeadLocomotive() && AcceptMUSignals)
            {
                if ((DieselDirectionController || DieselDirectionController2) && TogglePowerKeyCycle == 0)
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive && car.AcceptMUSignals)
                        {
                            car.PowerKeyPosition[1] = 0;
                            car.PowerKeyPosition[2] = 0;
                        }
                    }                    
                }

                Simulator.PowerKeyInPocket = true;                
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && car.AcceptMUSignals)
                    {
                        if (car.PowerKeyPosition[1] > 0 || car.PowerKeyPosition[2] > 0)
                            Simulator.PowerKeyInPocket = false;                                                
                    }
                }

                if (CarHavePocketPowerKey)
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive && car.AcceptMUSignals)
                        {
                            car.CarHavePocketPowerKey = true;
                        }
                    }
            }

            if (IsLeadLocomotive())
            {
                //Simulator.Confirmer.MSG("PowerKeyPosition[1] = " + PowerKeyPosition[1] + "   PowerKeyPosition[2] = " + PowerKeyPosition[2]);

                Simulator.PowerKeyNoPocketBlocked = true;
                if (PowerKeyPosition[1] > 1 || PowerKeyPosition[2] > 1)
                    Simulator.PowerKeyNoPocketBlocked = false;
            }

            if (IsLeadLocomotive() && !AcceptMUSignals)
            {                
                if ((DieselDirectionController || DieselDirectionController2) && TogglePowerKeyCycle == 0)
                {
                    this.PowerKeyPosition[1] = 0;
                    this.PowerKeyPosition[2] = 0;
                    Simulator.PowerKeyInPocket = true;
                }

                if (CarHavePocketPowerKey)
                {
                    Simulator.PowerKeyInPocket = true;
                    if (PowerKeyPosition[1] > 0 || PowerKeyPosition[2] > 0)
                        Simulator.PowerKeyInPocket = false;
                }                
            }            

            if (PowerKeyPosition[LocoStation] != prevPowerKeyPosition[LocoStation])
            {
                prevPowerKeyPosition[LocoStation] = PowerKeyPosition[LocoStation];
                switch (PowerKeyPosition[LocoStation])
                {
                    case 0:                        
                        SignalEvent(Event.PowerKeyOut);
                        Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Powerkey in pocket!"));
                        if (TrainBrakeController.BS2ControllerOnStation)
                            Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Trainbrake controller locked!"));
                        break;
                    case 1:                        
                        break;
                    case 2:
                        if (TrainBrakeController.BS2ControllerOnStation)
                            Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Trainbrake controller unlocked!"));
                        break;
                }
                if (!PowerKey)
                    SetPowerKeySound = false;

                if (Battery)
                {
                    if (PowerKey && !SetPowerKeySound)
                    {
                        SignalEvent(Event.PowerKeyOn);
                        SetPowerKeySound = true;
                    }
                    if (ActiveStation == DriverStation.None && PowerKey)
                    {
                        ActiveStation = UsingRearCab ? DriverStation.Station2 : DriverStation.Station1;
                    }
                    if ((ActiveStation == DriverStation.Station1 || ActiveStation == DriverStation.Station2) && !PowerKey)
                    {
                        ActiveStation = DriverStation.None;
                    }
                }
            }
            TogglePowerKeyCycle++;
            if (TogglePowerKeyCycle > 10)
                TogglePowerKeyCycle = 10;
        }

        // Icik
        public bool CabRadioTriggerOn = false;
        public void CabRadioOnOff()
        {            
            if (!CabRadio[LocoStation] || !Battery)
            {
                //if (CabRadioTriggerOn)
                    SignalEvent(Event.CabRadioOff);
                CabRadioTriggerOn = false;
                CabRadio[LocoStation] = false;
            }
            if (CabRadio[LocoStation] && Battery)
            {
                if (!CabRadioTriggerOn)
                    SignalEvent(Event.CabRadioOn);
                CabRadioTriggerOn = true;
            }            
        }
        
        public void ToggleCabRadio(bool newState)
        {
            //CabRadioOn = newState;
            CabRadio[LocoStation] = !CabRadio[LocoStation];
            if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CabRadio, CabRadio[LocoStation] ? CabSetting.On : CabSetting.Off);
        }

        public void ToggleWipers(bool newState)
        {
            SignalEvent(Event.PantographToggle);
            LocoWiper[LocoStation] = !LocoWiper[LocoStation];                        
        }

        public void SetBailOff(bool bailOff)
        {
            BailOff = bailOff;
            if (BailOff && !BailOffPressed)
            {
                SignalEvent(Event.ORTS_BailOff);
                BailOffPressed = true;
            }
            if (!BailOff && BailOffPressed)
            {
                SignalEvent(Event.ORTS_BailOffRelease);
                BailOffPressed = false;
            }
            Simulator.Confirmer.Confirm(CabControl.BailOff, bailOff ? CabSetting.On : CabSetting.Off);
        }

        public virtual void Refuel()
        {
            // Electric locos do nothing. Diesel and steam override this.
        }

        public void OdometerToggle()
        {
            OdometerVisible = !OdometerVisible;
        }

        /// <summary>
        /// Set odometer reference distance to actual travelled distance,
        /// and set measuring direction to the actual direction
        /// </summary>
        public void OdometerReset()
        {
            if (Train == null)
                return;

            if (OdometerCountingForwards != OdometerCountingUp ^ (Direction == Direction.Reverse))
            {
                OdometerCountingForwards = !OdometerCountingForwards;
            }

            if (Direction == Direction.Reverse)
            {
                if (OdometerCountingForwards)
                    OdometerResetPositionM = Train.DistanceTravelledM - Train.Length;
                else
                    OdometerResetPositionM = Train.DistanceTravelledM;
            }
            else
            {
                if (OdometerCountingForwards)
                    OdometerResetPositionM = Train.DistanceTravelledM;
                else
                    OdometerResetPositionM = Train.DistanceTravelledM + Train.Length;
            }

            Simulator.Confirmer.Confirm(CabControl.Odometer, CabSetting.On);
        }

        public void OdometerToggleDirection()
        {
            if (Train == null)
                return;

            OdometerCountingUp = !OdometerCountingUp;

            Simulator.Confirmer.Confirm(CabControl.Odometer, OdometerCountingUp ? CabSetting.Increase : CabSetting.Decrease);
        }

        public override bool GetCabFlipped()
        {
            return UsingRearCab;
        }

        public void SetEmergency(bool emergency)
        {
            if (this.Train != null && this.Train.TrainType == Train.TRAINTYPE.REMOTE) return; //not apply emergency for remote trains.
            TrainControlSystem.SetEmergency(emergency);
        }

        public void AlerterReset()
        {
            TrainControlSystem.HandleEvent(TCSEvent.AlerterReset);
        }

        public void AlerterReset(TCSEvent evt)
        {
            AlerterReset();
            TrainControlSystem.HandleEvent(evt);
        }

        public void AlerterPressed(bool pressed)
        {
            TrainControlSystem.AlerterPressed(pressed);
            Mirel.AlerterPressed(pressed);
        }

        // Icik
        #region Icik`s code
        public void ToggleHeadLightsUp()
        {
            if (HeadLightPosition[LocoStation] < 3)
            {
                HeadLightPosition[LocoStation]++;
                SignalEvent(Event.LightSwitchToggle);
                HeadLights();
            }
        }
        public void ToggleHeadLightsDown()
        {
            if (HeadLightPosition[LocoStation] > 0)                
            {
                HeadLightPosition[LocoStation]--;
                SignalEvent(Event.LightSwitchToggle);
                HeadLights();
            }
        }
        public void HeadLights()
        {            
            switch (HeadLightPosition[LocoStation])
            {
                case 0:
                    Headlight[LocoStation] = 0;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Position Light: ") + Simulator.Catalog.GetString("Off"));
                    break;
                case 1:
                    Headlight[LocoStation] = 7;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Position Light: ") + Simulator.Catalog.GetString("On"));
                    break;
                case 2:
                    Headlight[LocoStation] = 1;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Dim Headlight: ") + Simulator.Catalog.GetString("On"));
                    break;
                case 3:
                    Headlight[LocoStation] = 2;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Bright Headlight: ") + Simulator.Catalog.GetString("On"));
                    break;                
            }
        }
        
        public void CarFrameUpdate(float elapsedClockSeconds)
        {
            this.CarFrameUpdateState++;
            if (this.CarFrameUpdateState > 100)
                this.CarFrameUpdateState = 100;

            // První průběh - inicializace hodnot
            if (this.CarFrameUpdateState == 1)
            {
                EngineBrakeValueLogic(elapsedClockSeconds);
                TrainBrakeValueLogic();
                
                if (IsPlayerTrain)
                {                    
                    TM_Temperature(elapsedClockSeconds);
                    DriveResistance_Temperature(elapsedClockSeconds);

                    if (BrakeSystem.StartOn && !Simulator.Settings.AirEmpty)
                    {
                        foreach (TrainCar car in Train.Cars)
                        {
                            // Nastaví automaticky lokomotivu jako postrk, pokud se jedná o nákladní vlak
                            if (car is MSTSWagon && car.WagonType == WagonTypes.Freight)
                            {
                                LocoBecomeHelper = true;
                                Simulator.TrainIsPassenger = false;
                            }
                            if (car is MSTSLocomotive && LocoBecomeHelper)
                            {
                                car.AcceptHelperSignals = true;
                                Simulator.Confirmer.Information(Simulator.Catalog.GetString("Car ID") + " " + car.CarID + ": " + Simulator.Catalog.GetString("Helper connected"));
                            }

                            if (car.WagonType == WagonTypes.Passenger || car.HasPassengerCapacity)
                            {
                                if (!LocoBecomeHelper)
                                    Simulator.TrainIsPassenger = true;
                            }
                        }

                        if (IsLeadLocomotive())
                            Simulator.LeadAuxResVolumeM3 = AuxResVolumeM3;

                        // Osobní vlak s elektrickou lokomotivou                                                            
                        if (Simulator.TrainIsPassenger)
                            foreach (TrainCar car in Train.Cars)
                            {
                                if (car is MSTSElectricLocomotive && !car.AcceptCableSignals && (car as MSTSElectricLocomotive).AuxResVolumeM3 == Simulator.LeadAuxResVolumeM3)
                                    car.AcceptCableSignals = true;
                            }

                        // Elektrické lokomotivy nebo oddíly spojené za sebou
                        if (this.MUCableCanBeUsed)
                            if (this is MSTSElectricLocomotive && !AcceptCableSignals && (this as MSTSElectricLocomotive).AuxResVolumeM3 == Simulator.LeadAuxResVolumeM3)
                                AcceptCableSignals = true;

                        // Řídící vůz v soupravě                    
                        foreach (TrainCar car in Train.Cars)
                        {
                            if (car is MSTSLocomotive)
                            {
                                if ((car as MSTSLocomotive).MaxPowerWBase > 10 * 1000 || (car as MSTSDieselLocomotive != null && (car as MSTSDieselLocomotive).MaximumDieselEnginePowerW > 10 * 1000))
                                    car.PowerUnit = true;
                                else
                                    car.ControlUnit = true;
                            }
                        }
                        if (ControlUnit)
                        {
                            AcceptCableSignals = true;
                            foreach (TrainCar car in Train.Cars)
                            {
                                if (car is MSTSLocomotive && car.PowerUnit)
                                {
                                    car.AcceptCableSignals = true;
                                    break;
                                }
                            }
                        }
                    }
                }                
            }

            // Druhý průběh má všechny kabinové prvky načteny
            if (this.CarFrameUpdateState == 2)
            {                
                if (FirstCabLoaded)
                {
                    if (CompressorCombined)
                        CompressorSwitch[1] = CompressorSwitch[2] = 1;
                    if (CompressorCombined2)
                        CompressorSwitch2[1] = CompressorSwitch2[2] = 0;

                    if (CompressorOffAutoOn)
                        CompressorSwitch[1] = CompressorSwitch[2] = 0;
                    if (CompressorOffAutoOn2)
                        CompressorSwitch2[1] = CompressorSwitch2[2] = 0;
                }
                FirstCabLoaded = false;
            }

            // Desátý průběh - nastaví hodnoty po nahrání uložené pozice
            if (this.CarFrameUpdateState == 10)
            {
                
            }

            // EDB Hack
            if (LocoHasNoDynamicController) DynamicBrakeController = null;
        }
        
        public void MUCableLogic()
        {
            if (IsLeadLocomotive())
            {                
                Simulator.LocoCount = 0;
                Simulator.MUCableLocoCount = 0;
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive)
                        Simulator.LocoCount++;
                    if (car is MSTSLocomotive && car.AcceptCableSignals)                    
                        Simulator.MUCableLocoCount++;                                                            
                }                
                if (Simulator.LocoCount == 1 || Simulator.MUCableLocoCount < 1)
                    AcceptCableSignals = false;
                //else
                //    AcceptCableSignals = true;
            }
        }

        public bool MUCylPressureMirelOk;
        public void TrainAlerterLogic()
        {            
            if (IsLeadLocomotive() && AcceptCableSignals)
            {
                MUCylPressureMirelOk = false;
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && AcceptCableSignals)
                    {
                        if (car.BrakeSystem.GetCylPressurePSI() > 1.5f * 14.50377f)
                            MUCylPressureMirelOk = true;
                    }
                }
                if (Mirel.initTest == SubSystems.Mirel.InitTest.Passed)
                {
                    Simulator.TrainAlerterPassed = true;
                    Simulator.selectedDriveMode = Mirel.selectedDriveMode;
                    Simulator.driveMode = Mirel.driveMode;
                    Simulator.MaxSelectedSpeed = Mirel.MaxSelectedSpeed;
                }                
                if (!Battery)
                    Simulator.TrainAlerterPassed = false;                          
            }   
            else
            {
                // Přenos Mirelu do propojené lokomotivy
                if (!IsLeadLocomotive() && !LocoHelperOn && Simulator.TrainAlerterPassed && AcceptCableSignals)
                {
                    if (Battery)
                    {
                        Mirel.Test1 = true;
                        Mirel.Test2 = true;
                        Mirel.Test3 = true;
                        Mirel.Test4 = true;
                        Mirel.Test5 = true;
                        Mirel.Test6 = true;
                        Mirel.Test7 = true;
                        Mirel.initTest = SubSystems.Mirel.InitTest.Passed;
                        Mirel.BlueLight = true;
                        Mirel.selectedDriveMode = Simulator.selectedDriveMode;
                        Mirel.driveMode = Simulator.driveMode;
                        Mirel.MaxSelectedSpeed = Simulator.MaxSelectedSpeed;
                    }                    
                }
            }
        }

        public void WipersLogic()
        {
            if (!LocoWiper[LocoStation] && Wiper)
                SignalEvent(Event.WiperOff);

            if (LocoWiper[LocoStation] && !Wiper && Battery)
                SignalEvent(Event.WiperOn);

            if (Wiper && !Battery)
                SignalEvent(Event.WiperOff);

            if (LocoWiper[LocoStation] && Battery)
                Wiper = true;
            else
                Wiper = false;
        }

        float EngineBrakeValueR;
        float EngineBrakeValueN;
        float EngineBrakeValueA;
        public bool EngineBrakeHas1Notch;
        float prevAutoCylPressurePSI1;
        bool EngineBrakeSoundChange;
        public void EngineBrakeValueLogic(float elapsedClockSeconds)
        {
            if (IsLeadLocomotive())
            {                
                //Simulator.Confirmer.MSG("EngineBrakeValue[0] = " + EngineBrakeValue[0] + "        EngineBrakeValue[1] = " + EngineBrakeValue[1] + "   EngineBrakeValue[2] = " + EngineBrakeValue[2]);
                if (EngineBrakeController.Notches.Count <= 1 || EngineBrakeHas1Notch)
                {
                    EngineBrakeHas1Notch = true;
                    EngineBrakeValue[0] = Math.Max(EngineBrakeValue[1], EngineBrakeValue[2]);
                    SetEngineBrakePercent(EngineBrakeValue[0] * 100f);
                    if (BrakeSystem.AutoCylPressurePSI1 != prevAutoCylPressurePSI1 && EngineBrakeValue[LocoStation] != prevEngineBrakeValue[LocoStation])
                    {
                        if (!EngineBrakeSoundChange)
                        {
                            SignalEvent(Event.EngineBrakeChange);
                            EngineBrakeSoundChange = true;
                            prevAutoCylPressurePSI1 = BrakeSystem.AutoCylPressurePSI1;
                            prevEngineBrakeValue[LocoStation] = EngineBrakeValue[LocoStation];
                        }
                    }
                    else
                        EngineBrakeSoundChange = false;
                }
                else
                {
                    LocoStation = 1;
                    if (UsingRearCab)
                        LocoStation = 2;
                    if (Simulator.LocoStationChange)
                    {                        
                        SetEngineBrakePercent(EngineBrakeValue[LocoStation] * 100f);                        
                    }
                    #region EngineBrakeCheckPosition
                    foreach (MSTSNotch notch in EngineBrakeController.Notches)
                    {
                        switch (notch.Type)
                        {
                            case ControllerState.Dummy:
                                EngineBrakeHas1Notch = true;
                                break;
                            case ControllerState.Release:
                                EngineBrakeValueR = notch.Value;
                                break;
                            case ControllerState.Neutral:
                            case ControllerState.Lap:
                                EngineBrakeValueN = notch.Value;
                                break;
                            case ControllerState.FullServ:
                            case ControllerState.Apply:
                            case ControllerState.EPApply:
                            case ControllerState.ContServ:
                                EngineBrakeValueA = notch.Value;
                                break;                                                                                       
                        }
                    }

                    if (LocoStation == 1)
                    {
                        if (EngineBrakeValue[2] == EngineBrakeValueR && !LapActive[2])
                            if (BrakeSystem.AutoCylPressurePSI1 > 0)
                                BrakeSystem.AutoCylPressurePSI1 -= 3f * EngineBrakeReleaseRatePSIpS * elapsedClockSeconds;
                        
                        if (EngineBrakeValue[2] == EngineBrakeValueA && !LapActive[2])
                            if (BrakeSystem.AutoCylPressurePSI1 < BrakeSystem.MCP)
                                BrakeSystem.AutoCylPressurePSI1 += 3f * EngineBrakeApplyRatePSIpS * elapsedClockSeconds;
                    }
                    if (LocoStation == 2)
                    {
                        if (EngineBrakeValue[1] == EngineBrakeValueR && !LapActive[1])
                            if (BrakeSystem.AutoCylPressurePSI1 > 0)
                                BrakeSystem.AutoCylPressurePSI1 -= 3f * EngineBrakeReleaseRatePSIpS * elapsedClockSeconds;

                        if (EngineBrakeValue[1] == EngineBrakeValueA && !LapActive[1])
                            if (BrakeSystem.AutoCylPressurePSI1 < BrakeSystem.MCP)
                                BrakeSystem.AutoCylPressurePSI1 += 3f * EngineBrakeApplyRatePSIpS * elapsedClockSeconds;
                    }
                    
                    if (EngineBrakeValue[LocoStation] != prevEngineBrakeValue[LocoStation])
                    {
                        if (!EngineBrakeSoundChange)
                        {
                            SignalEvent(Event.EngineBrakeChange);
                            EngineBrakeSoundChange = true;
                            prevEngineBrakeValue[LocoStation] = EngineBrakeValue[LocoStation];
                        }
                    }
                    else
                        EngineBrakeSoundChange = false;
                    #endregion
                    EngineBrakeValue[LocoStation] = EngineBrakeController.CurrentValue;
                }                
            }                        
            #region Výchozí nastavení přímočinky na vícestupňových ovladačích           
            // Nastaví pozici Neutral na vícestupňových ovladačích
            if (CarFrameUpdateState == 1 && FirstCabLoaded)
            {
                if (EngineBrakeController.Notches.Count > 1 && !EngineBrakeHas1Notch)
                {
                    foreach (MSTSNotch notch in EngineBrakeController.Notches)
                    {
                        switch (notch.Type)
                        {
                            case ControllerState.Dummy:
                                EngineBrakeHas1Notch = true;
                                break;
                            case ControllerState.Neutral:
                            case ControllerState.Lap:
                                EngineBrakeValueN = notch.Value;
                                break;
                            case ControllerState.FullServ:
                            case ControllerState.Apply:
                            case ControllerState.EPApply:
                            case ControllerState.ContServ:
                                EngineBrakeValueA = notch.Value;
                                break;
                        }
                    }
                    if (IsLeadLocomotive())
                    {
                        if (LocoStation == 1)
                        {
                            EngineBrakeValue[1] = EngineBrakeValueA;
                            EngineBrakeValue[2] = EngineBrakeValueN;
                        }
                        else
                        {
                            EngineBrakeValue[1] = EngineBrakeValueN;
                            EngineBrakeValue[2] = EngineBrakeValueA;
                        }
                    }
                    else
                    {
                        EngineBrakeValue[1] = EngineBrakeValueN;
                        EngineBrakeValue[2] = EngineBrakeValueN;                        
                    }
                }
            }
            #endregion

            // Páry mají jen jedno stanoviště
            if (this is MSTSSteamLocomotive)
            {
                if (LocoStation == 1)
                    EngineBrakeValue[2] = EngineBrakeValue[1];
                else
                    EngineBrakeValue[1] = EngineBrakeValue[2];
            }
        }

        float TrainBrakeValueFQR;
        float TrainBrakeValueO;
        float TrainBrakeValueL;
        public float TrainBrakeValueL_2 = -1;
        float TrainBrakeValueR;
        float TrainBrakeValueN;
        float TrainBrakeValueA;
        float TrainBrakeValueE;
        float TrainBrakeValueEPA;
        float TrainBrakeValueAGA;
        float TrainBrakeValueSA; // SlowApply
        float TrainBrakeValueRUN; // Running        

        public void TrainBrakeValueLogic()
        {
            if (IsLeadLocomotive())
            {
                //Simulator.Confirmer.MSG("TrainBrakeValue[0] = " + TrainBrakeValue[0] + "        TrainBrakeValue[1] = " + TrainBrakeValue[1] + "   TrainBrakeValue[2] = " + TrainBrakeValue[2]);                            
                LocoStation = 1;
                if (UsingRearCab)
                    LocoStation = 2;
                if (Simulator.LocoStationChange)
                {
                    SetTrainBrakePercent(TrainBrakeValue[LocoStation] * 100f);
                    Simulator.LocoStationChange = false;
                }
                #region TrainBrakeCheckPosition
                TrainBrakeValueL = -1;
                TrainBrakeValueL_2 = -1;
                foreach (MSTSNotch notch in TrainBrakeController.Notches)
                {
                    switch (notch.Type)
                    {
                        case ControllerState.MatrosovRelease:
                        case ControllerState.WestingHouseRelease:
                        case ControllerState.FullQuickRelease:
                            TrainBrakeValueFQR = notch.Value;
                            break;
                        case ControllerState.OverchargeStart:
                            TrainBrakeValueO = notch.Value;
                            break;
                        case ControllerState.Lap:                            
                            if (TrainBrakeValueL != -1)
                                TrainBrakeValueL_2 = notch.Value;
                            else
                                TrainBrakeValueL = notch.Value;
                            break;
                        case ControllerState.Release:
                            TrainBrakeValueR = notch.Value;
                             break;
                        case ControllerState.Neutral:
                            TrainBrakeValueN = notch.Value;
                            break;
                        case ControllerState.Apply:
                            TrainBrakeValueA = notch.Value;
                            break;
                        case ControllerState.Emergency:
                            TrainBrakeValueE = notch.Value;
                            break;
                        case ControllerState.EPApply:
                            TrainBrakeValueEPA = notch.Value;
                            break;
                        case ControllerState.GSelfLapH:
                        case ControllerState.GSelfLap:
                            TrainBrakeValueAGA = notch.Value;
                            break;
                        case ControllerState.SlowApplyStart:
                            TrainBrakeValueSA = notch.Value;
                            break;
                        case ControllerState.Running:
                            TrainBrakeValueRUN = notch.Value;
                            break;
                    }
                }

                if ((TrainBrakeValue[1] == TrainBrakeValueL && TrainBrakeValue[2] == TrainBrakeValueL) 
                    || (LapActive[1] && LapActive[2])
                    || (TrainBrakeValue[1] == TrainBrakeValueL_2 && TrainBrakeValue[2] == TrainBrakeValueL)
                    || (TrainBrakeValue[1] == TrainBrakeValueL && TrainBrakeValue[2] == TrainBrakeValueL_2)
                    || (TrainBrakeValue[1] == TrainBrakeValueL_2 && TrainBrakeValue[2] == TrainBrakeValueL_2))
                    BrakeSystem.BrakeControllerLap = true;
                else
                    BrakeSystem.BrakeControllerLap = false;

                // Páry mají jen jedno stanoviště
                if (this is MSTSSteamLocomotive)
                {
                    if (LocoStation == 1)
                        LapActive[2] = LapActive[1];
                    else
                        LapActive[1] = LapActive[2];
                }

                if (LocoStation == 1)
                {                    
                    if (TrainBrakeValue[2] == TrainBrakeValueFQR && !LapActive[2])
                        BrakeSystem.QuickRelease = true;                    
                    else
                        BrakeSystem.QuickRelease = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueO && !LapActive[2])
                        BrakeSystem.Overcharge = true;
                    else
                        BrakeSystem.Overcharge = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueL && !LapActive[2])
                        BrakeSystem.Lap = true;
                    else
                        BrakeSystem.Lap = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueR && !LapActive[2])
                        BrakeSystem.Release = true;
                    else
                        BrakeSystem.Release = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueN && !LapActive[2])
                        BrakeSystem.Neutral = true;
                    else
                        BrakeSystem.Neutral = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueA && !LapActive[2])
                        BrakeSystem.Apply = true;
                    else
                        BrakeSystem.Apply = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueE && !LapActive[2])
                        BrakeSystem.Emergency = true;
                    else
                        BrakeSystem.Emergency = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueEPA && !LapActive[2])
                        BrakeSystem.EPApply = true;
                    else
                        BrakeSystem.EPApply = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueAGA && !LapActive[2])
                        BrakeSystem.ApplyGA = true;
                    else
                        BrakeSystem.ApplyGA = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueSA && !LapActive[2])
                        BrakeSystem.SlowApplyStart = true;
                    else
                        BrakeSystem.SlowApplyStart = false;
                    if (TrainBrakeValue[2] == TrainBrakeValueRUN && !LapActive[2])
                        BrakeSystem.Running = true;
                    else
                        BrakeSystem.Running = false;
                }
                if (LocoStation == 2)
                {
                    if (TrainBrakeValue[1] == TrainBrakeValueFQR && !LapActive[1])
                        BrakeSystem.QuickRelease = true;
                    else
                        BrakeSystem.QuickRelease = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueO && !LapActive[1])
                        BrakeSystem.Overcharge = true;
                    else
                        BrakeSystem.Overcharge = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueL && !LapActive[1])
                        BrakeSystem.Lap = true;
                    else
                        BrakeSystem.Lap = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueR && !LapActive[1])
                        BrakeSystem.Release = true;
                    else
                        BrakeSystem.Release = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueN && !LapActive[1])
                        BrakeSystem.Neutral = true;
                    else
                        BrakeSystem.Neutral = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueA && !LapActive[1])
                        BrakeSystem.Apply = true;
                    else
                        BrakeSystem.Apply = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueE && !LapActive[1])
                        BrakeSystem.Emergency = true;
                    else
                        BrakeSystem.Emergency = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueEPA && !LapActive[1])
                        BrakeSystem.EPApply = true;
                    else
                        BrakeSystem.EPApply = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueAGA && !LapActive[1])
                        BrakeSystem.ApplyGA = true;
                    else
                        BrakeSystem.ApplyGA = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueSA && !LapActive[1])
                        BrakeSystem.SlowApplyStart = true;
                    else
                        BrakeSystem.SlowApplyStart = false;
                    if (TrainBrakeValue[1] == TrainBrakeValueRUN && !LapActive[1])
                        BrakeSystem.Running = true;
                    else
                        BrakeSystem.Running = false;
                }
                #endregion
                TrainBrakeValue[LocoStation] = TrainBrakeController.CurrentValue;

                // Páry mají jen jedno stanoviště
                if (this is MSTSSteamLocomotive)
                {
                    if (LocoStation == 1)
                        TrainBrakeValue[2] = TrainBrakeValue[1];
                    else
                        TrainBrakeValue[1] = TrainBrakeValue[2];
                }
            }
        }

        public void DirectionControllerLogic()
        {
            if (IsLeadLocomotive())
            {
                if (PowerKeyPosition[LocoStation] != 2 || !Battery)
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive)
                        {
                            Direction = Direction.N;
                            car.DirectionControllerBlocked = true;
                        }
                    }
                }
                else
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (car is MSTSLocomotive)
                        {
                            if (DirectionPosition[LocoStation] == 0 && car.DirectionControllerBlocked)
                                car.DirectionControllerBlocked = false;
                        }
                    }
                }
            }
        }

        public void PowerKeyLogic()
        {
            if (IsLeadLocomotive() && AcceptMUSignals)
            {
                Simulator.TrainPowerKey = false;
                foreach (TrainCar car in Train.Cars)
                {
                    if (car is MSTSLocomotive && AcceptMUSignals)
                    {
                        if (car.PowerKeyPosition[1] == 2 || car.PowerKeyPosition[2] == 2)
                        {
                            car.CarPowerKey = true;
                            Simulator.TrainPowerKey = true;
                        }
                        else                        
                        {
                            car.CarPowerKey = false;                        
                        }
                    }
                }             
            }
            if (IsLeadLocomotive() && !AcceptMUSignals)            
                Simulator.TrainPowerKey = true;

            if (this is MSTSSteamLocomotive)
            {
                this.CarPowerKey = true;
                Simulator.TrainPowerKey = true;
                StationIsActivated[1] = true;
                StationIsActivated[2] = true;
            }
        }

        public void ToggleHV2SwitchUp()
        {
            if (HV2Enable)
            {
                if (HV2Switch < 1)
                    HV2Switch++;
                if (HV2Switch < 1)
                {
                    ToggleHV2Switch();
                }
                HV2Switch = MathHelper.Clamp(HV2Switch, 0, 1);
            }
        }

        public void ToggleHV2Switch()
        {
            if (!IsLeadLocomotive())
                return;
            if (HV2Enable)
            {
                if (HV2ButtonEnable)
                {
                    if (LastStateHV2 != HV2Switch && HV2Switch == 1)
                        SignalEvent(Event.HVButtonPress); // Zvuk přepínače                
                    else
                    if (LastStateHV2 != HV2Switch && HV2Switch == 0)
                        SignalEvent(Event.HVButtonRelease); // Zvuk přepínače                
                }
                else
                if (LastStateHV2 != HV2Switch)
                    SignalEvent(Event.PantographToggle); // Zvuk přepínače         

                if (HVCanOn && Battery && StationIsActivated[LocoStation])
                    HVOn = true;
                //Simulator.Confirmer.Information("HV can On");

                switch (HV2Switch)
                {
                    case 0:
                        //Simulator.Confirmer.Information("Switch 0");
                        break;
                    case 1:
                        //Simulator.Confirmer.Information("Switch 1");
                        break;
                }
                LastStateHV2 = HV2Switch;
            }
        }

        public void ToggleHV3SwitchUp()
        {
            if (HV3Enable)
            {
                if (HV3Switch[LocoStation] < 3)
                    HV3Switch[LocoStation]++;
                if (HV3Switch[LocoStation] < 3)
                {
                    ToggleHV3Switch();
                }
                HV3Switch[LocoStation] = MathHelper.Clamp(HV3Switch[LocoStation], 0, 2);
            }
        }
        public void ToggleHV3SwitchDown()
        {
            if (HV3Enable)
            {
                if (HV3Switch[LocoStation] > 0)
                    HV3Switch[LocoStation]--;
                if (HV3Switch[LocoStation] > -1)
                {
                    ToggleHV3Switch();
                }
                HV3Switch[LocoStation] = MathHelper.Clamp(HV3Switch[LocoStation], 0, 2);
            }
        }
        public void ToggleHV3Switch()
        {
            if (!IsLeadLocomotive())
                return;
            if (HV3Enable)
            {
                if (HVCanOn && Battery && StationIsActivated[LocoStation])
                    HVOn = true;
                // Výběr napájecího systému při HV3 (zde bude výběr dle obrazovky)
                if (Battery && StationIsActivated[LocoStation])
                {
                    switch (RouteVoltageV)
                    {
                        case 3000:
                            SwitchingVoltageMode = 0;
                            SwitchingVoltageMode_OffDC = true;
                            SwitchingVoltageMode_OffAC = false;
                            break;
                        case 15000:
                        case 25000:
                            SwitchingVoltageMode = 2;
                            SwitchingVoltageMode_OffDC = false;
                            SwitchingVoltageMode_OffAC = true;
                            break;
                    }
                }
                if (LastStateHV3[LocoStation] != HV3Switch[LocoStation])
                    SignalEvent(Event.PantographToggle); // Zvuk přepínače                

                switch (HV3Switch[LocoStation])
                {
                    case 0: // HV vypnout
                        //Simulator.Confirmer.Information("Switch 0");
                        break;
                    case 1: // střed
                        //Simulator.Confirmer.Information("Switch 1");
                        break;
                    case 2: // HV zapnout
                        //Simulator.Confirmer.Information("Switch 2");
                        break;
                }
                LastStateHV3[LocoStation] = HV3Switch[LocoStation];
            }
        }

        public void ToggleHV4SwitchUp()
        {
            if (HV4Enable)
            {
                if (HV4Switch[LocoStation] < 3)
                    HV4Switch[LocoStation]++;
                if (HV4Switch[LocoStation] < 3)
                {
                    ToggleHV4Switch();
                }
                HV4Switch[LocoStation] = MathHelper.Clamp(HV4Switch[LocoStation], -1, 2);
            }
        }
        public void ToggleHV4SwitchDown()
        {
            if (HV4Enable)
            {
                if (HV4Switch[LocoStation] > 0)
                    HV4Switch[LocoStation]--;
                if (HV4Switch[LocoStation] > -1)
                {
                    ToggleHV4Switch();
                }
                HV4Switch[LocoStation] = MathHelper.Clamp(HV4Switch[LocoStation], -1, 2);
            }
        }
        public void ToggleHV4Switch()
        {
            if (!IsLeadLocomotive())
                return;
            if (HV4Enable)
            {
                if (HV4Switch[LocoStation] == 0 && HV4SwitchFullDown)
                {
                    HV4SwitchFullDownCycle++;
                    if (HV4SwitchFullDownCycle > 5)
                    {
                        ToggleHV4SwitchUp();
                        HV4SwitchFullDown = false;
                        HV4SwitchFullDownCycle = 0;
                        HVOffPressedTest = false;
                    }
                }

                if (BreakPowerButton || Pantograph3Switch[LocoStation] == -1)
                    Pantograph3Switch[LocoStation] = 1;

                if (HVCanOn && Battery && StationIsActivated[LocoStation])
                    HVOn = true;
                // Výběr napájecího systému při HV4 (zde bude výběr dle obrazovky)
                switch (RouteVoltageV)
                {
                    case 3000:
                        SwitchingVoltageMode = 0;
                        SwitchingVoltageMode_OffDC = true;
                        SwitchingVoltageMode_OffAC = false;
                        break;
                    case 15000:
                    case 25000:
                        SwitchingVoltageMode = 2;
                        SwitchingVoltageMode_OffDC = false;
                        SwitchingVoltageMode_OffAC = true;
                        break;
                }

                if (LastStateHV4[LocoStation] != HV4Switch[LocoStation])
                    SignalEvent(Event.PantographToggle); // Zvuk přepínače                                

                if (Battery && StationIsActivated[LocoStation])
                {
                    switch (HV4Switch[LocoStation])
                    {
                        case -1: // panto dolu
                                 //Simulator.Confirmer.Information("Switch -1");
                            Pantograph3Switch[LocoStation] = -1;
                            break;
                        case 0: // vypni proud
                                //Simulator.Confirmer.Information("Switch 0");                        
                            AuxPowerStartOff();
                            break;
                        case 1: // střed X
                                //Simulator.Confirmer.Information("Switch 1");                        
                            break;
                        case 2: // HV zapnout, panto nahoru
                            AuxPowerStartOn();
                            if (AirForPantograph)
                                Pantograph3Switch[LocoStation] = 2;
                            //Simulator.Confirmer.Information("Switch 2");                        
                            break;
                    }
                }
                LastStateHV4[LocoStation] = HV4Switch[LocoStation];
            }
        }

        public void ToggleHV5SwitchUp()
        {
            if (HV5Enable)
            {
                if (HV5Switch[LocoStation] < 5)
                    HV5Switch[LocoStation]++;
                if (HV5Switch[LocoStation] < 5)
                {
                    ToggleHV5Switch();
                    Simulator.Confirmer.Confirm(CabControl.SwitchingVoltageMode_OffAC, SwitchingVoltageMode_OffAC ? CabSetting.On : CabSetting.Off);
                }
                HV5Switch[LocoStation] = MathHelper.Clamp(HV5Switch[LocoStation], 0, 4);
            }
        }
        public void ToggleHV5SwitchDown()
        {
            if (HV5Enable)
            {
                if (HV5Switch[LocoStation] > 0)
                    HV5Switch[LocoStation]--;
                if (HV5Switch[LocoStation] > -1)
                {
                    ToggleHV5Switch();
                    Simulator.Confirmer.Confirm(CabControl.SwitchingVoltageMode_OffDC, SwitchingVoltageMode_OffDC ? CabSetting.On : CabSetting.Off);
                }
                HV5Switch[LocoStation] = MathHelper.Clamp(HV5Switch[LocoStation], 0, 4);
            }
        }
        public void ToggleHV5Switch()
        {
            if (!IsLeadLocomotive())
                return;
            if (HV5Enable)
            {
                if (LastStateHV5[LocoStation] != HV5Switch[LocoStation])
                    SignalEvent(Event.PantographToggle); // Zvuk přepínače                

                if (HVCanOn && Battery && StationIsActivated[LocoStation] && Pantograph4Switch[LocoStation] != 0)
                    HVOn = true;
                //Simulator.Confirmer.Information("HV can On");
                if (Battery && StationIsActivated[LocoStation])
                {
                    switch (HV5Switch[LocoStation])
                    {
                        case 0:
                            //Simulator.Confirmer.Information("Switch 1");
                            break;
                        case 1: // DC
                            SwitchingVoltageMode = 0;
                            SwitchingVoltageMode_OffDC = true;
                            SwitchingVoltageMode_OffAC = false;
                            //Simulator.Confirmer.Information("Switch 2");
                            break;
                        case 2: // střed
                            SwitchingVoltageMode = 1;
                            SwitchingVoltageMode_OffDC = false;
                            SwitchingVoltageMode_OffAC = false;
                            //Simulator.Confirmer.Information("Switch 3");
                            break;
                        case 3: // AC
                            SwitchingVoltageMode = 2;
                            SwitchingVoltageMode_OffAC = true;
                            SwitchingVoltageMode_OffDC = false;
                            //Simulator.Confirmer.Information("Switch 4");
                            break;
                        case 4:
                            //Simulator.Confirmer.Information("Switch 5");
                            break;
                    }
                }
                LastStateHV5[LocoStation] = HV5Switch[LocoStation];
            }
        }


        public void TogglePantograph3SwitchUp()
        {
            if (Pantograph3Enable)
            {
                if (Pantograph3Switch[LocoStation] < 3)
                    Pantograph3Switch[LocoStation]++;                
                Pantograph3Switch[LocoStation] = MathHelper.Clamp(Pantograph3Switch[LocoStation], -1, 2);
            }
        }
        public void TogglePantograph3SwitchDown()
        {
            if (Pantograph3Enable)
            {
                if (Pantograph3Switch[LocoStation] > 0)
                    Pantograph3Switch[LocoStation]--;
                Pantograph3Switch[LocoStation] = MathHelper.Clamp(Pantograph3Switch[LocoStation], -1, 2);
            }
        }
        public void TogglePantograph3Switch()
        {
            if (Pantograph3Enable)
            {
                //Simulator.Confirmer.Information("Pantograph3Switch " + Pantograph3Switch);
                if (Pantograph3Switch[LocoStation] == 0 && Pantograph3SwitchFullDown)
                {
                    Pantograph3SwitchFullDownCycle++;
                    if (Pantograph3SwitchFullDownCycle > 5)
                    {
                        TogglePantograph3SwitchUp();
                        Pantograph3SwitchFullDown = false;
                        Pantograph3SwitchFullDownCycle = 0;
                        PantographOffPressedTest = false;
                    }
                }

                if (LastStatePantograph3 != Pantograph3Switch[LocoStation])
                    SignalEvent(Event.PantographToggle); // Zvuk přepínače                

                if (!MultiSystemEngine && !CircuitBreakerOn)
                    return;

                // Zabrání zvednutí pantografu po stlačení tlačítka přerušení napájení
                if (BreakPowerButton)
                    BreakPowerButton_Activated = true;
                if (BreakPowerButton_Activated && Pantograph3Switch[LocoStation] == 1)
                    BreakPowerButton_Activated = false;

                if ((Pantograph3CanOn || HV4Enable) && Battery && StationIsActivated[LocoStation] && !BreakPowerButton_Activated && Simulator.GameTime > 1)
                {
                    PantoStatus = Pantograph3Switch[LocoStation];
                    int p1 = 1; int p2 = 2;
                    string ps1 = "PANTO1"; string ps2 = "PANTO2";
                    if (UsingRearCab) { p1 = 2; p2 = 1; ps1 = "PANTO2"; ps2 = "PANTO1"; }
                    if (PantoStatus != PrePantoStatus[LocoStation])
                    {
                        switch (Pantograph3Switch[LocoStation])
                        {
                            case -1: // SOS
                                PantoCommandDown = true;
                                Pantograph3CanOn = false;
                                if (HV3Enable) HVOff = true;
                                if (Pantographs[p1].State != PantographState.Down)
                                {
                                    SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                    if (MPManager.IsMultiPlayer())
                                        MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                }
                                if (Pantographs[p2].State != PantographState.Down)
                                {
                                    SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                    if (MPManager.IsMultiPlayer())
                                        MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                }

                                if (AcceptMUSignals)
                                    foreach (TrainCar car in Train.Cars)
                                    {
                                        if (car.AcceptMUSignals)
                                        {
                                            car.SignalEvent(PowerSupplyEvent.LowerPantograph);
                                            if (MPManager.IsMultiPlayer())
                                            {
                                                MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                                MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                            }
                                        }
                                    }
                                break;
                            case 0: // Panto vypnout
                                PantoCommandDown = true;
                                if (Pantographs[p1].State != PantographState.Down)
                                {
                                    SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                    if (MPManager.IsMultiPlayer())
                                        MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                }
                                if (Pantographs[p2].State != PantographState.Down)
                                {
                                    SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                    if (MPManager.IsMultiPlayer())
                                        MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                }

                                if (AcceptMUSignals)
                                    foreach (TrainCar car in Train.Cars)
                                    {
                                        if (car.AcceptMUSignals)
                                        {
                                            car.SignalEvent(PowerSupplyEvent.LowerPantograph);
                                            if (MPManager.IsMultiPlayer())
                                            {
                                                MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                                MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                            }
                                        }
                                    }
                                break;
                            case 1: // střed                                    
                                break;
                            case 2: // Panto zapnout
                                PantoCommandDown = false;
                                if (PantoMode == PantoModes.Auto || PantoMode == PantoModes.Aft)
                                {
                                    if (AirForPantograph && Pantographs[p1].State != PantographState.Up)
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                    }
                                    if (Pantographs[p2].State != PantographState.Down)
                                    {
                                        SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                    }

                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                                car.SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                                }
                                            }
                                        }
                                }
                                if (PantoMode == PantoModes.Both)
                                {
                                    if (AirForPantograph && Pantographs[p1].State != PantographState.Up)
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                    }
                                    if (AirForPantograph && Pantographs[p2].State != PantographState.Up)
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                    }
                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                                }
                                            }
                                        }
                                }
                                if (PantoMode == PantoModes.Forward)
                                {
                                    if (AirForPantograph && Pantographs[p2].State != PantographState.Up)
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                    }
                                    if (Pantographs[p1].State != PantographState.Down)
                                    {
                                        SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                    }

                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                                car.SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                                }
                                            }
                                        }
                                }
                                break;
                        }
                        PrePantoStatus[LocoStation] = Pantograph3Switch[LocoStation];
                    }
                }
                LastStatePantograph3 = Pantograph3Switch[LocoStation];
            }
        }

        public void TogglePantograph4SwitchUp()
        {
            if (Pantograph4Enable)
            {
                if (Pantograph4Switch[LocoStation] < 4)
                    Pantograph4Switch[LocoStation]++;
                if (Pantograph4Switch[LocoStation] == 4)
                    Pantograph4Switch[LocoStation] = 0;
                SignalEvent(Event.PantographToggle);                
            }
        }
        public void TogglePantograph4SwitchDown()
        {
            if (Pantograph4Enable)
            {
                if (Pantograph4Switch[LocoStation] > -1)
                    Pantograph4Switch[LocoStation]--;
                if (Pantograph4Switch[LocoStation] == -1)
                    Pantograph4Switch[LocoStation] = 3;
                SignalEvent(Event.PantographToggle);                
            }
        }
        public void TogglePantograph4Switch()
        {
            if (!MultiSystemEngine && !CircuitBreakerOn)
                return;
            if (Pantograph4Enable)
            {
                // Zabrání zvednutí pantografu po stlačení tlačítka přerušení napájení
                if (BreakPowerButton)
                    BreakPowerButton_Activated = true;
                if (BreakPowerButton_Activated && Pantograph4Switch[LocoStation] == 0)
                    BreakPowerButton_Activated = false;

                if (Battery && StationIsActivated[LocoStation] && !BreakPowerButton_Activated && Simulator.GameTime > 1)
                {
                    PantoStatus = Pantograph4Switch[LocoStation];
                    int p1 = 1; int p2 = 2;
                    string ps1 = "PANTO1"; string ps2 = "PANTO2";
                    if (UsingRearCab) { p1 = 2; p2 = 1; ps1 = "PANTO2"; ps2 = "PANTO1"; }
                    if (PantoStatus != PrePantoStatus[LocoStation])
                    {
                        switch (Pantograph4Switch[LocoStation])
                        {
                            case 0:
                                {
                                    if (Pantographs[p1].State == PantographState.Up || Pantographs[p1].State == PantographState.Raising) // Zadní panto                            
                                    {
                                        SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                    }
                                    if (Pantographs[p2].State == PantographState.Up || Pantographs[p2].State == PantographState.Raising) // Přední panto
                                    {
                                        SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                    }

                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.LowerPantograph);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                                }
                                            }
                                        }
                                }
                                break;
                            case 1:
                                {
                                    if (AirForPantograph && Pantographs[p1].State == PantographState.Down || AirForPantograph && Pantographs[p1].State == PantographState.Lowering) // Zadní panto
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                    }
                                    if (Pantographs[p2].State == PantographState.Up || Pantographs[p2].State == PantographState.Raising) // Přední panto
                                    {
                                        SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                    }

                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                                car.SignalEvent(PowerSupplyEvent.LowerPantograph, p2);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 0).ToString());
                                                }
                                            }
                                        }
                                }
                                break;
                            case 2:
                                {
                                    if (AirForPantograph && Pantographs[p1].State == PantographState.Down || AirForPantograph && Pantographs[p1].State == PantographState.Lowering) // Zadní panto
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                    }
                                    if (AirForPantograph && Pantographs[p2].State == PantographState.Down || AirForPantograph && Pantographs[p2].State == PantographState.Lowering) // Přední panto
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                    }

                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 1).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                                }
                                            }
                                        }
                                }
                                break;
                            case 3:
                                {
                                    if (Pantographs[p1].State == PantographState.Up || Pantographs[p1].State == PantographState.Raising) // Zadní panto                            
                                    {
                                        SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                    }
                                    if (AirForPantograph && Pantographs[p2].State == PantographState.Down || AirForPantograph && Pantographs[p2].State == PantographState.Lowering) // Přední panto
                                    {
                                        SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                        if (MPManager.IsMultiPlayer())
                                            MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                    }

                                    if (AcceptMUSignals)
                                        foreach (TrainCar car in Train.Cars)
                                        {
                                            if (car.AcceptMUSignals)
                                            {
                                                car.SignalEvent(PowerSupplyEvent.LowerPantograph, p1);
                                                car.SignalEvent(PowerSupplyEvent.RaisePantograph, p2);
                                                if (MPManager.IsMultiPlayer())
                                                {
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps1, 0).ToString());
                                                    MPManager.Notify(new MSGEvent(MPManager.GetUserName(), ps2, 1).ToString());
                                                }
                                            }
                                        }
                                }
                                break;
                        }
                    }
                    PrePantoStatus[LocoStation] = Pantograph4Switch[LocoStation];
                }
            }
        }

        public bool ChangingPowerSystem = false;
        public void ChangePowerSystem()
        {
            if (SelectingPowerSystem == SelectedPowerSystem)
                return;

            ChangingPowerSystem = true;
            switch (SelectingPowerSystem)
            {
                case PowerSystem.AT15kV:
                case PowerSystem.DE15kV:
                    SwitchingVoltageMode = 2;
                    Loco15kV = true;
                    break;
                case PowerSystem.CZ25kV:
                case PowerSystem.SK25kV:
                    SwitchingVoltageMode = 2;
                    Loco15kV = false;
                    break;
                case PowerSystem.CZ3kV:
                case PowerSystem.SK3kV:
                    SwitchingVoltageMode = 0;
                    Loco15kV = false;
                    break;
            }
            SelectedPowerSystem = SelectingPowerSystem;
        }

        protected float timeChangingPowerSystem = 0;
        public bool WaitingForLvzConfirmation = false;
        public bool pantoCommandSent = false;
        protected float continuingTimeChangingSystem = 0;
        protected bool inverterChecked = false;

        public void PowerChangeRoutine(float elapsedSeconds)
        {
            timeChangingPowerSystem += elapsedSeconds;
            if (timeChangingPowerSystem > 3)
            {
                if (SelectedPowerSystem.ToString().ToLower().Contains("25kv") && (RouteVoltageV == 3000 || RouteVoltageV == 15000))
                {
                    SystemAnnunciator = 3;
                    return;
                }
                if (SelectedPowerSystem.ToString().ToLower().Contains("15kv") && (RouteVoltageV == 3000 || RouteVoltageV == 25000))
                {
                    SystemAnnunciator = 3;
                    return;
                }
                if (SelectedPowerSystem.ToString().ToLower().Contains("3kv") && (RouteVoltageV == 15000 || RouteVoltageV == 25000))
                {
                    SystemAnnunciator = 3;
                    return;
                }
            }
            if (timeChangingPowerSystem > 0.3)
            {
                HVOff = true;
            }
            if (timeChangingPowerSystem > 0.5 && !pantoCommandSent)
            {
                SignalEvent(PowerSupplyEvent.LowerPantograph);
                pantoCommandSent = true;
                WaitingForLvzConfirmation = true;
            }

            bool PantoBlocked = true;

            bool canContinue = true;
            foreach (Pantograph panto in Pantographs.List)
            {
                if (panto.State != PantographState.Down)
                    canContinue = false;
            }
            if (!canContinue) // || WaitingForLvzConfirmation)
            {
                //                return;
            }

            if (SwitchingVoltageMode == 0)
            {
                SwitchingVoltageMode_OffDC = true;
                SwitchingVoltageMode_OffAC = false;
            }
            if (SwitchingVoltageMode == 2)
            {
                SwitchingVoltageMode_OffDC = false;
                SwitchingVoltageMode_OffAC = true;
            }
            continuingTimeChangingSystem += elapsedSeconds;

            PantoBlocked = false;
            if ((SelectedPowerSystem == PowerSystem.AT15kV                
                || SelectedPowerSystem == PowerSystem.DE15kV)
                && (RouteVoltageV == 3000 || RouteVoltageV == 25000))
            {
                PantoBlocked = true;
                HVOff = true;
                SystemAnnunciator = 3;
                return;
            }
            if ((SelectedPowerSystem == PowerSystem.CZ25kV
                || SelectedPowerSystem == PowerSystem.SK25kV)
                && (RouteVoltageV == 3000 || RouteVoltageV == 15000))
            {
                PantoBlocked = true;
                HVOff = true;
                SystemAnnunciator = 3;
                return;
            }
            if ((SelectedPowerSystem == PowerSystem.CZ3kV
                || SelectedPowerSystem == PowerSystem.SK3kV)
                && (RouteVoltageV == 25000 || RouteVoltageV == 15000))
            {
                PantoBlocked = true;
                HVOff = true;
                SystemAnnunciator = 3;
                return;
            }
            HVOff = false;
            if (!CircuitBreakerOn && Pantographs.List[0].State == PantographState.Up)
            {
                HvPantoTimer += elapsedSeconds;
                if (SystemAnnunciator == 0)
                {
                    SystemAnnunciator = 6;
                }
                else if (SystemAnnunciator == 6 && HvPantoTimer > 2)
                {
                    SystemAnnunciator = 4;
                }
                else if (SystemAnnunciator == 4 && HvPantoTimer > 4)
                {
                    SystemAnnunciator = 5;
                    HvPantoTimer = 0;
                }
            }
            if (!CircuitBreakerOn && (Pantographs.List[0].State == PantographState.Lowering || Pantographs.List[0].State == PantographState.Raising))
            {
                SystemAnnunciator = 4;
            }
            if (!CircuitBreakerOn && Pantographs.List[0].State == PantographState.Down && HvPantoTimer < 5)
            {
                HvPantoTimer += elapsedSeconds;
                SystemAnnunciator = 4;
            }
            if (CircuitBreakerOn && (Pantographs.List[0].State == PantographState.Lowering || Pantographs.List[0].State == PantographState.Raising))
            {
                SystemAnnunciator = 4;
            }
            if (CircuitBreakerOn && Pantographs.List[0].State == PantographState.Down && HvPantoTimer < 5)
            {
                HvPantoTimer += elapsedSeconds;
                SystemAnnunciator = 4;
            }
            if (!CircuitBreakerOn && Pantographs.List[0].State == PantographState.Down && HvPantoTimer >= 5)
            {
                SystemAnnunciator = 1;
            }

            if (CircuitBreakerOn && Pantographs.List[0].State == PantographState.Up)
            {
                HvPantoTimer = 0;
                SystemAnnunciator = 0;
            }

            if ((SystemAnnunciator == 3 || SystemAnnunciator == 4) && !CircuitBreakerOn && Pantographs.List[0].State == PantographState.Up && HvPantoTimer > 10)
            {
                SystemAnnunciator = 5;
            }

            if (SystemAnnunciator == 0 && BrakeSystem.GetCylPressurePSI() > 0)
            {
                SystemAnnunciator = 6;
            }
            if (!PowerOn && SystemAnnunciator == 0)
            {
                SystemAnnunciator = 5;
                continuingTimeChangingSystem -= elapsedSeconds;
                return;
            }
            if (!PowerOn)
            {
                continuingTimeChangingSystem -= elapsedSeconds;
                return;
            }
            SystemAnnunciator = 6;
            InverterTest = RouteVoltageV == 3000 ? 0 : 1;
            if (continuingTimeChangingSystem > 23)
            {
                ChangingPowerSystem = false;
                timeChangingPowerSystem = 0;
                continuingTimeChangingSystem = 0;
                pantoCommandSent = false;
                if (SwitchingVoltageMode == 0)
                {
                    SwitchingVoltageMode_OffDC = true;
                    SwitchingVoltageMode_OffAC = false;
                }
                if (SwitchingVoltageMode == 2)
                {
                    SwitchingVoltageMode_OffDC = false;
                    SwitchingVoltageMode_OffAC = true;
                }
                HVOff = false;
                InverterTest = 2;
            }
            if (PantoBlocked)
                SystemAnnunciator = 3;
        }

        public void ToggleCompressorCombinedSwitchUp()
        {
            if (!CompressorCombined) return;
            if (CompressorSwitch[LocoStation] < 4)
                CompressorSwitch[LocoStation]++;
            if (CompressorSwitch[LocoStation] <= 3)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorCombined();
            }
            CompressorSwitch[LocoStation] = MathHelper.Clamp(CompressorSwitch[LocoStation], 0, 3);
        }
        public void ToggleCompressorCombinedSwitchDown()
        {
            if (!CompressorCombined) return;
            if (CompressorSwitch[LocoStation] > -1)
                CompressorSwitch[LocoStation]--;
            if (CompressorSwitch[LocoStation] >= 0)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorCombined();
            }
            CompressorSwitch[LocoStation] = MathHelper.Clamp(CompressorSwitch[LocoStation], 0, 3);
        }
        public void ToggleCompressorCombined()
        {
            if (CompressorCombined)
            {
                Compressor_I_HandMode[LocoStation] = false;
                if (StationIsActivated[LocoStation])
                {
                    switch (CompressorSwitch[LocoStation])
                    {
                        case 0:
                            {
                                AuxCompressorMode_OffOn = true;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.AuxCompressorMode_OffOn, AuxCompressorMode_OffOn ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 1:
                            {
                                AuxCompressorMode_OffOn = false;
                                CompressorMode_OffAuto[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode_OffAuto, CompressorMode_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 2:
                            {
                                CompressorMode_OffAuto[LocoStation] = true;
                                Compressor_I_HandMode[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode_OffAuto, CompressorMode_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 3:
                            {
                                CompressorMode_OffAuto[LocoStation] = false;
                                Compressor_I_HandMode[LocoStation] = true;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.Compressor_I_HandMode, Compressor_I_HandMode[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                    }
                }
            }
        }

        public void ToggleCompressorCombinedSwitch2Up()
        {
            if (!CompressorCombined2) return;
            if (CompressorSwitch2[LocoStation] < 3)
                CompressorSwitch2[LocoStation]++;
            if (CompressorSwitch2[LocoStation] <= 2)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorCombined2();
            }
            CompressorSwitch2[LocoStation] = MathHelper.Clamp(CompressorSwitch2[LocoStation], 0, 2);
        }
        public void ToggleCompressorCombinedSwitch2Down()
        {
            if (!CompressorCombined2) return;
            if (CompressorSwitch2[LocoStation] > -1)
                CompressorSwitch2[LocoStation]--;
            if (CompressorSwitch2[LocoStation] >= 0)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorCombined2();
            }
            CompressorSwitch2[LocoStation] = MathHelper.Clamp(CompressorSwitch2[LocoStation], 0, 2);
        }
        public void ToggleCompressorCombined2()
        {
            if (CompressorCombined2)
            {
                Compressor_II_HandMode[LocoStation] = false;
                if (StationIsActivated[LocoStation])
                {
                    switch (CompressorSwitch2[LocoStation])
                    {
                        case 0:
                            {
                                CompressorMode2_OffAuto[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode2_OffAuto, CompressorMode2_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 1:
                            {
                                CompressorMode2_OffAuto[LocoStation] = true;
                                Compressor_II_HandMode[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode2_OffAuto, CompressorMode2_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 2:
                            {
                                CompressorMode2_OffAuto[LocoStation] = false;
                                Compressor_II_HandMode[LocoStation] = true;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.Compressor_II_HandMode, Compressor_II_HandMode[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                    }
                }
            }
        }

        public void ToggleCompressorOffAutoOnSwitchUp()
        {
            if (!CompressorOffAutoOn) return;
            if (CompressorSwitch[LocoStation] < 3)
                CompressorSwitch[LocoStation]++;
            if (CompressorSwitch[LocoStation] <= 2)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorOffAutoOnSwitch(); 
            }
            CompressorSwitch[LocoStation] = MathHelper.Clamp(CompressorSwitch[LocoStation], 0, 2);
        }
        public void ToggleCompressorOffAutoOnSwitchDown()
        {
            if (!CompressorOffAutoOn) return;
            if (CompressorSwitch[LocoStation] > -1)
                CompressorSwitch[LocoStation]--;
            if (CompressorSwitch[LocoStation] >= 0)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorOffAutoOnSwitch();
            }
            CompressorSwitch[LocoStation] = MathHelper.Clamp(CompressorSwitch[LocoStation], 0, 2);
        }
        public void ToggleCompressorOffAutoOnSwitch()
        {
            if (CompressorOffAutoOn)
            {
                Compressor_I_HandMode[LocoStation] = false;
                if (StationIsActivated[LocoStation])
                {
                    switch (CompressorSwitch[LocoStation])
                    {
                        case 0:
                            {
                                CompressorMode_OffAuto[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode_OffAuto, CompressorMode_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 1:
                            {
                                CompressorMode_OffAuto[LocoStation] = true;
                                Compressor_I_HandMode[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode_OffAuto, CompressorMode_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 2:
                            {
                                CompressorMode_OffAuto[LocoStation] = false;
                                Compressor_I_HandMode[LocoStation] = true;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.Compressor_I_HandMode, Compressor_I_HandMode[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                    }
                }
            }
        }

        public void ToggleCompressorOffAutoOnSwitch2Up()
        {
            if (!CompressorOffAutoOn2) return;
            if (CompressorSwitch2[LocoStation] < 3)
                CompressorSwitch2[LocoStation]++;
            if (CompressorSwitch2[LocoStation] <= 2)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorOffAutoOnSwitch2();
            }
            CompressorSwitch2[LocoStation] = MathHelper.Clamp(CompressorSwitch2[LocoStation], 0, 2);
        }
        public void ToggleCompressorOffAutoOnSwitch2Down()
        {
            if (!CompressorOffAutoOn2) return;
            if (CompressorSwitch2[LocoStation] > -1)
                CompressorSwitch2[LocoStation]--;
            if (CompressorSwitch2[LocoStation] >= 0)
            {
                SignalEvent(Event.CompressorMode_OffAutoOn);
                ToggleCompressorOffAutoOnSwitch2();
            }
            CompressorSwitch2[LocoStation] = MathHelper.Clamp(CompressorSwitch2[LocoStation], 0, 2);
        }
        public void ToggleCompressorOffAutoOnSwitch2()
        {
            if (CompressorOffAutoOn2)
            {
                Compressor_II_HandMode[LocoStation] = false;
                if (StationIsActivated[LocoStation])
                {
                    switch (CompressorSwitch2[LocoStation])
                    {
                        case 0:
                            {
                                CompressorMode2_OffAuto[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode2_OffAuto, CompressorMode2_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 1:
                            {
                                CompressorMode2_OffAuto[LocoStation] = true;
                                Compressor_II_HandMode[LocoStation] = false;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode2_OffAuto, CompressorMode2_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                        case 2:
                            {
                                CompressorMode2_OffAuto[LocoStation] = false;
                                Compressor_II_HandMode[LocoStation] = true;
                                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.Compressor_II_HandMode, Compressor_II_HandMode[LocoStation] ? CabSetting.On : CabSetting.Off);
                            }
                            break;
                    }
                }
            }
        }

        public void ToggleAuxCompressorMode_OffOn()
        {
            if (AuxCompressor && !CompressorCombined)
            {
                AuxCompressorMode_OffOn = !AuxCompressorMode_OffOn;
                if (AuxCompressorMode_OffOn) SignalEvent(Event.AuxCompressorMode_OffOnOn);
                else SignalEvent(Event.AuxCompressorMode_OffOnOff);
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.AuxCompressorMode_OffOn, AuxCompressorMode_OffOn ? CabSetting.On : CabSetting.Off);
            }
        }
        public void ToggleCompressorMode_OffAuto()
        {
            if (Compressor_I && !CompressorCombined && !CompressorCombined2 && !CompressorOffAutoOn && !CompressorOffAutoOn2)
            {
                CompressorMode_OffAuto[LocoStation] = !CompressorMode_OffAuto[LocoStation];
                if (CompressorMode_OffAuto[LocoStation]) SignalEvent(Event.CompressorMode_OffAutoOn);
                else SignalEvent(Event.CompressorMode_OffAutoOff);
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode_OffAuto, CompressorMode_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
            }
        }
        public void ToggleCompressorMode2_OffAuto()
        {
            if (Compressor_II && !CompressorCombined && !CompressorCombined2 && !CompressorOffAutoOn && !CompressorOffAutoOn2)
            {
                CompressorMode2_OffAuto[LocoStation] = !CompressorMode2_OffAuto[LocoStation];
                if (CompressorMode2_OffAuto[LocoStation]) SignalEvent(Event.CompressorMode_OffAutoOn);
                else SignalEvent(Event.CompressorMode_OffAutoOff);
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CompressorMode2_OffAuto, CompressorMode2_OffAuto[LocoStation] ? CabSetting.On : CabSetting.Off);
            }
        }
        public void ToggleHeating_OffOn()
        {
            if (HeatingEnable)
            {                
                Heating_OffOn[LocoStation] = !Heating_OffOn[LocoStation];
                if (Heating_OffOn[LocoStation]) SignalEvent(Event.Heating_OffOnOn);
                else SignalEvent(Event.Heating_OffOnOff);
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.Heating_OffOn, Heating_OffOn[LocoStation] ? CabSetting.On : CabSetting.Off);
            }
        }
        public void ToggleCabHeating_OffOn()
        {
            CabHeatingEnable = true;
            if (CabHeatingEnable && BrakeSystem.HeatingIsOn)
            {
                CabHeating_OffOn[LocoStation] = !CabHeating_OffOn[LocoStation];
                if (CabHeating_OffOn[LocoStation]) SignalEvent(Event.CabHeating_OffOnOn);
                else SignalEvent(Event.CabHeating_OffOnOff);
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.CabHeating_OffOn, CabHeating_OffOn[LocoStation] ? CabSetting.On : CabSetting.Off);
            }
        }
        public void ToggleQuickReleaseButton(bool quickReleaseButton)
        {
            if (QuickReleaseButtonEnable)
            {
                QuickReleaseButton = quickReleaseButton;
                if (QuickReleaseButton && !QuickReleaseButtonPressed)
                {
                    SignalEvent(Event.QuickReleaseButton);
                    QuickReleaseButtonPressed = true;
                }
                if (!QuickReleaseButton && QuickReleaseButtonPressed)
                {
                    SignalEvent(Event.QuickReleaseButtonRelease);
                    QuickReleaseButtonPressed = false;
                }
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.QuickReleaseButton, quickReleaseButton ? CabSetting.On : CabSetting.Off);
            }
        }

        public void ToggleLowPressureReleaseButton(bool lowPressureReleaseButton)
        {
            if (LowPressureReleaseButtonEnable)
            {
                LowPressureReleaseButton = lowPressureReleaseButton;
                if (LowPressureReleaseButton && !LowPressureReleaseButtonPressed)
                {
                    SignalEvent(Event.LowPressureReleaseButton);
                    LowPressureReleaseButtonPressed = true;
                }
                if (!LowPressureReleaseButton && LowPressureReleaseButtonPressed)
                {
                    SignalEvent(Event.LowPressureReleaseButtonRelease);
                    LowPressureReleaseButtonPressed = false;
                }
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LowPressureReleaseButton, lowPressureReleaseButton ? CabSetting.On : CabSetting.Off);
            }
        }

        public void ToggleBreakPowerButton(bool breakPowerButton)
        {
            if (BreakPowerButtonEnable)
            {
                BreakPowerButton = breakPowerButton;
                if (BreakPowerButton && !BreakPowerButtonPressed)
                {
                    SignalEvent(Event.BreakPowerButton);
                    BreakPowerButtonPressed = true;
                }
                if (!BreakPowerButton && BreakPowerButtonPressed)
                {
                    SignalEvent(Event.BreakPowerButtonRelease);
                    BreakPowerButtonPressed = false;
                }
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.BreakPowerButton, breakPowerButton ? CabSetting.On : CabSetting.Off);
            }
        }

        public void ToggleLapButton(bool lapButton)
        {
            if (LapButtonEnable)
            {
                LapButton = lapButton;
                if (LapButton && !LapButtonPressed)
                {
                    SignalEvent(Event.LapButton);
                    LapButtonPressed = true;
                    LapActive[LocoStation] = !LapActive[LocoStation];
                }
                if (!LapButton && LapButtonPressed)
                {
                    SignalEvent(Event.LapButtonRelease);
                    LapButtonPressed = false;
                }
                if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LapActive, LapActive[LocoStation] ? CabSetting.On : CabSetting.Off);
            }
        }

        public void ToggleBreakEDBButton(bool breakEDBButton)
        {
            BreakEDBButton = breakEDBButton;
            // Stav a zvuk pro tlačítko
            if (!BreakEDBSwitchEnable)
            {                                
                if (BreakEDBButton && !BreakEDBButtonPressed)
                {
                    SignalEvent(Event.BreakEDBButton);
                    BreakEDBButtonPressed = true;
                    BreakEDBButton_Activated = !BreakEDBButton_Activated;
                }
                if (!BreakEDBButton && BreakEDBButtonPressed)
                {
                    SignalEvent(Event.BreakEDBButtonRelease);
                    BreakEDBButtonPressed = false;
                }                
            }
            // Stav a zvuk pro přepínač
            if (BreakEDBSwitchEnable)
            {
                BreakEDBButton_Activated = !BreakEDBButton_Activated;                
                SignalEvent(Event.BreakEDBButton);                    
            }
            if (Simulator.PlayerLocomotive == this)
            {
                if (BreakEDBButton_Activated)
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Disabling EDB: ") + Simulator.Catalog.GetString("On"));
                else
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Disabling EDB: ") + Simulator.Catalog.GetString("Off"));
            }
        }

        public void SetLapButton()
        {
            if (!IsPlayerTrain)
                return;
            if (BrakeSystem.StartOn && Simulator.Settings.AirEmpty)
                SetLapButtonStart = true;
            if (SetLapButtonStart && LapButtonEnable && Battery)
            {
                SetLapButtonStart = false;
                LapActive[LocoStation] = true;
            }
        }

        public void ToggleDirectionButtonDown()
        {
            if (DirectionButton)
            {
                if (DirectionButtonPosition == 3)
                {
                    DirectionButtonPosition = 2;
                    ToggleDirectionButton();
                    return;
                }
                if (DirectionButtonPosition == 2)
                {
                    DirectionButtonPosition = 4;
                    ToggleDirectionButton();
                    return;
                }
                if (DirectionButtonPosition == 0)
                {
                    DirectionButtonPosition = 3;
                }
                else
                {
                    if (DirectionButtonPosition == 5)
                    {
                        DirectionButtonPosition = 4;
                    }
                    else
                    {
                        if (DirectionButtonPosition < 5)
                            DirectionButtonPosition++;
                    }
                }
                ToggleDirectionButton();
            }            
        }
        public void ToggleDirectionButtonUp()
        {
            if (DirectionButton)
            {
                if (DirectionButtonPosition == 5)
                {
                    DirectionButtonPosition = 3;
                    ToggleDirectionButton();
                    return;
                }
                if (DirectionButtonPosition == 3)
                {
                    DirectionButtonPosition = 2;
                    ToggleDirectionButton();
                    return;
                }
                if (DirectionButtonPosition == 0)
                {
                    DirectionButtonPosition = 1;
                }
                else
                {
                    if (DirectionButtonPosition > 0)
                        DirectionButtonPosition--;
                }
                ToggleDirectionButton();
            }
        }
        public void DirectionButtonSetup()
        {            
            if (!DirectionButton) return;
            if (!Battery)
            {
                DirectionButtonPositionOffset = 6;
                Direction = Direction.N;
            }
            else
            {
                if (BatterySetOn)
                    DirectionButtonPosition = 2;
                DirectionButtonPositionOffset = 0;
                if (MemDirectionButtonPosition != -1)
                {
                    DirectionButtonPosition = MemDirectionButtonPosition;
                    ToggleDirectionButton();
                }
            }            
        }
        public void ToggleDirectionButton()
        {            
            //Simulator.Confirmer.MSG("Nastaveno: " + DirectionButtonPosition);
            if (AbsSpeedMpS > 0)
            {
                MemDirectionButtonPosition = DirectionButtonPosition;
                return;
            }
            if (AbsSpeedMpS == 0 && ThrottlePercent != 0)
            {
                MemDirectionButtonPosition = DirectionButtonPosition;
                return;
            }
            MemDirectionButtonPosition = -1;

            switch (DirectionButtonPosition)
            {
                case 0: // Vpřed
                    {
                        Direction = Direction.Forward;
                    }
                    break;
                case 1: // Vpřed
                    {
                        Direction = Direction.Forward;
                    }
                    break;
                case 2: // N
                    {
                        Direction = Direction.N;
                    }
                    break;
                case 3: // N
                    {
                        Direction = Direction.N;
                    }
                    break;                
                case 4: // Vzad
                    {
                        Direction = Direction.Reverse;
                    }
                    break;                
                case 5: // Vzad
                    {
                        Direction = Direction.Reverse;
                    }
                    break;
            }
        }


        public void ToggleDieselDirectionControllerDown()
        {
            if (StationIsActivated[LocoStation])
            {
                if (DieselDirectionController || DieselDirectionController3)
                {
                    if (DieselDirectionControllerPosition[LocoStation] < 4)
                        DieselDirectionControllerPosition[LocoStation]++;
                    if (DieselDirectionControllerPosition[LocoStation] <= 4)
                    {
                        if ((DieselDirectionControllerPosition[LocoStation] > 2 && DieselDirectionControllerPosition[LocoStation] > prevDieselDirectionControllerPosition[LocoStation])
                            || (DieselDirectionControllerPosition[LocoStation] < 2 && DieselDirectionControllerPosition[LocoStation] < prevDieselDirectionControllerPosition[LocoStation]))
                            SignalEvent(Event.ReverserToForwardBackward);
                        else
                        if ((DieselDirectionControllerPosition[LocoStation] >= 2 && DieselDirectionControllerPosition[LocoStation] < prevDieselDirectionControllerPosition[LocoStation])
                            || (DieselDirectionControllerPosition[LocoStation] <= 2 && DieselDirectionControllerPosition[LocoStation] > prevDieselDirectionControllerPosition[LocoStation]))
                            SignalEvent(Event.ReverserToNeutral);
                    }
                }
                else
                if (DieselDirectionController2 || DieselDirectionController4)
                {
                    if (DieselDirectionController2Position[LocoStation] > 0)
                        DieselDirectionController2Position[LocoStation]--;
                    if (DieselDirectionController2Position[LocoStation] >= 0)
                    {
                        if ((DieselDirectionController2Position[LocoStation] > 0 && DieselDirectionController2Position[LocoStation] > prevDieselDirectionController2Position[LocoStation])
                            || (DieselDirectionController2Position[LocoStation] < 0 && DieselDirectionController2Position[LocoStation] < prevDieselDirectionController2Position[LocoStation]))
                            SignalEvent(Event.ReverserToForwardBackward);
                        else
                        if ((DieselDirectionController2Position[LocoStation] >= 0 && DieselDirectionController2Position[LocoStation] < prevDieselDirectionController2Position[LocoStation])
                            || (DieselDirectionController2Position[LocoStation] < 0 && DieselDirectionController2Position[LocoStation] > prevDieselDirectionController2Position[LocoStation]))
                            SignalEvent(Event.ReverserToNeutral);
                    }
                }
            }
        }
        public void ToggleDieselDirectionControllerUp()
        {
            if (StationIsActivated[LocoStation])
            {
                if (DieselDirectionController || DieselDirectionController3)
                {
                    if (DieselDirectionControllerPosition[LocoStation] > 0)
                        DieselDirectionControllerPosition[LocoStation]--;
                    if (DieselDirectionControllerPosition[LocoStation] >= 0)
                    {
                        if ((DieselDirectionControllerPosition[LocoStation] > 2 && DieselDirectionControllerPosition[LocoStation] > prevDieselDirectionControllerPosition[LocoStation])
                            || (DieselDirectionControllerPosition[LocoStation] < 2 && DieselDirectionControllerPosition[LocoStation] < prevDieselDirectionControllerPosition[LocoStation]))
                            SignalEvent(Event.ReverserToForwardBackward);
                        else
                        if ((DieselDirectionControllerPosition[LocoStation] >= 2 && DieselDirectionControllerPosition[LocoStation] < prevDieselDirectionControllerPosition[LocoStation])
                            || (DieselDirectionControllerPosition[LocoStation] <= 2 && DieselDirectionControllerPosition[LocoStation] > prevDieselDirectionControllerPosition[LocoStation]))
                            SignalEvent(Event.ReverserToNeutral);
                    }
                }
                else
                if (DieselDirectionController2 || DieselDirectionController4)
                {
                    if (DieselDirectionController2Position[LocoStation] < 3)
                        DieselDirectionController2Position[LocoStation]++;
                    if (DieselDirectionController2Position[LocoStation] <= 3)
                    {
                        if ((DieselDirectionController2Position[LocoStation] > 0 && DieselDirectionController2Position[LocoStation] > prevDieselDirectionController2Position[LocoStation])
                            || (DieselDirectionController2Position[LocoStation] < 0 && DieselDirectionController2Position[LocoStation] < prevDieselDirectionController2Position[LocoStation]))
                            SignalEvent(Event.ReverserToForwardBackward);
                        else
                        if ((DieselDirectionController2Position[LocoStation] > 0 && DieselDirectionController2Position[LocoStation] < prevDieselDirectionController2Position[LocoStation])
                            || (DieselDirectionController2Position[LocoStation] < 0 && DieselDirectionController2Position[LocoStation] > prevDieselDirectionController2Position[LocoStation]))
                            SignalEvent(Event.ReverserToNeutral);
                    }
                }
            }
        }
        public void ToggleDieselDirectionController()
        {
            if (!IsLeadLocomotive())
                return;
            if (DieselDirectionController || DieselDirectionController3)
            {
                if (DieselDirectionControllerPosition[LocoStation] == -1)
                {                 
                    DieselDirectionControllerPosition[LocoStation] = 2;
                    this.CarPowerKey = false;
                }
                switch (DieselDirectionControllerPosition[LocoStation])
                {
                    case 0: // Vpřed
                        {
                            DieselDirection_Forward = true;
                            DieselDirection_Start = false;
                            DieselDirection_0 = false;
                            DieselDirection_Reverse = false;
                            Direction = Direction.Forward;
                        }
                        break;
                    case 1: // D
                        {
                            DieselDirection_Forward = false;
                            DieselDirection_Start = true;
                            DieselDirection_0 = false;
                            DieselDirection_Reverse = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 2: // N
                        {
                            DieselDirection_Forward = false;
                            DieselDirection_Start = false;
                            DieselDirection_0 = true;
                            DieselDirection_Reverse = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 3: // D
                        {
                            DieselDirection_Forward = false;
                            DieselDirection_Start = true;
                            DieselDirection_0 = false;
                            DieselDirection_Reverse = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 4: // Vzad
                        {
                            DieselDirection_Forward = false;
                            DieselDirection_Start = false;
                            DieselDirection_0 = false;
                            DieselDirection_Reverse = true;
                            Direction = Direction.Reverse;
                        }
                        break;
                }
                if (prevDieselDirectionControllerPosition[LocoStation] != DieselDirectionControllerPosition[LocoStation])
                {
                    switch (DieselDirectionControllerPosition[LocoStation])
                    {
                        case 0: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Forward, Simulator.Catalog.GetString("Position Forward")); break;
                        case 1: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Start, Simulator.Catalog.GetString("Position D")); break;
                        case 2: Simulator.Confirmer.Confirm(CabControl.DieselDirection_0, Simulator.Catalog.GetString("Position 0")); break;
                        case 3: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Start, Simulator.Catalog.GetString("Position D")); break;
                        case 4: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Reverse, Simulator.Catalog.GetString("Position Backward")); break;
                    }
                    prevDieselDirectionControllerPosition[LocoStation] = DieselDirectionControllerPosition[LocoStation];
                    //Simulator.Confirmer.MSG("Nastaveno: " + DieselDirectionControllerPosition);                                        
                }
            }
        }

        public void ToggleDieselDirectionController2()
        {
            if (!IsLeadLocomotive())
                return;
            if (DieselDirectionController2)
            {
                if (DieselDirectionController2Position[LocoStation] == -1)
                {
                    DieselDirectionController2Position[LocoStation] = 0;
                    this.CarPowerKey = false;                    
                }
                switch (DieselDirectionController2Position[LocoStation])
                {
                    case 0: // 0
                        {
                            DieselDirection_Start = false;
                            DieselDirection_Reverse = false;
                            DieselDirection_0 = true;
                            DieselDirection_Forward = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 1: // Vzad
                        {
                            DieselDirection_Start = false;
                            DieselDirection_Reverse = true;
                            DieselDirection_0 = false;
                            DieselDirection_Forward = false;
                            Direction = Direction.Reverse;
                        }
                        break;
                    case 2: // D
                        {
                            DieselDirection_Start = true;
                            DieselDirection_Reverse = false;
                            DieselDirection_0 = false;
                            DieselDirection_Forward = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 3: // Vpřed
                        {
                            DieselDirection_Start = false;
                            DieselDirection_Reverse = false;
                            DieselDirection_0 = false;
                            DieselDirection_Forward = true;
                            Direction = Direction.Forward;
                        }
                        break;
                }
                if (prevDieselDirectionController2Position[LocoStation] != DieselDirectionController2Position[LocoStation])
                {
                    switch (DieselDirectionController2Position[LocoStation])
                    {
                        case 0: Simulator.Confirmer.Confirm(CabControl.DieselDirection_0, Simulator.Catalog.GetString("Position 0")); break;
                        case 1: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Reverse, Simulator.Catalog.GetString("Position Backward")); break;
                        case 2: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Start, Simulator.Catalog.GetString("Position D")); break;
                        case 3: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Forward, Simulator.Catalog.GetString("Position Forward")); break;
                    }
                    prevDieselDirectionController2Position[LocoStation] = DieselDirectionController2Position[LocoStation];
                    //Simulator.Confirmer.MSG("Nastaveno: " + DieselDirectionController2Position);                    
                }
            }
            if (DieselDirectionController4)
            {                                                
                if (DieselDirectionController2Position[LocoStation] == -1) DieselDirectionController2Position[LocoStation] = 1;
                switch (DieselDirectionController2Position[LocoStation])
                {
                    case 0: // Vzad
                        {
                            DieselDirection_Start = false;
                            DieselDirection_Reverse = true;
                            DieselDirection_0 = false;
                            DieselDirection_Forward = false;
                            Direction = Direction.Reverse;
                        }
                        break;
                    case 1: // 0
                        {
                            DieselDirection_Start = false;
                            DieselDirection_Reverse = false;
                            DieselDirection_0 = true;
                            DieselDirection_Forward = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 2: // D
                        {
                            DieselDirection_Start = true;
                            DieselDirection_Reverse = false;
                            DieselDirection_0 = false;
                            DieselDirection_Forward = false;
                            Direction = Direction.N;
                        }
                        break;
                    case 3: // Vpřed
                        {
                            DieselDirection_Start = false;
                            DieselDirection_Reverse = false;
                            DieselDirection_0 = false;
                            DieselDirection_Forward = true;
                            Direction = Direction.Forward;
                        }
                        break;
                }
                if (prevDieselDirectionController2Position[LocoStation] != DieselDirectionController2Position[LocoStation])
                {
                    switch (DieselDirectionController2Position[LocoStation])
                    {
                        case 0: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Reverse, Simulator.Catalog.GetString("Position Backward")); break;
                        case 1: Simulator.Confirmer.Confirm(CabControl.DieselDirection_0, Simulator.Catalog.GetString("Position 0")); break;
                        case 2: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Start, Simulator.Catalog.GetString("Position D")); break;
                        case 3: Simulator.Confirmer.Confirm(CabControl.DieselDirection_Forward, Simulator.Catalog.GetString("Position Forward")); break;
                    }
                    prevDieselDirectionController2Position[LocoStation] = DieselDirectionController2Position[LocoStation];
                    //Simulator.Confirmer.MSG("Nastaveno: " + DieselDirectionController2Position);                    
                }
            }            
        }
        public void ToggleDieselDirectionControllerInOut()
        {
            // Zasunutí a odebrání směrové páky u dieselu            
            if ((DieselDirectionController && DieselDirection_0) || (DieselDirectionController2 && DieselDirection_0))
            {                
                string DieselDirectionControllerInfo;
                if (!DieselDirectionControllerInOut && !AcceptMUSignals)
                {
                    DieselDirectionControllerInOut = true;
                    PowerKeyPosition[LocoStation] = 2;
                    this.CarPowerKey = true;
                    DieselDirectionControllerInfo = Simulator.Catalog.GetString("Directional lever retracted");
                    if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Information(DieselDirectionControllerInfo);
                }
                else
                if (!DieselDirectionControllerInOut && Simulator.PowerKeyInPocket && AcceptMUSignals)
                {
                    DieselDirectionControllerInOut = true;
                    PowerKeyPosition[LocoStation] = 2;
                    this.CarPowerKey = true;
                    DieselDirectionControllerInfo = Simulator.Catalog.GetString("Directional lever retracted");
                    if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Information(DieselDirectionControllerInfo);
                }
                else
                if (DieselDirectionControllerInOut && StationIsActivated[LocoStation])
                {
                    DieselDirectionControllerInOut = false;
                    PowerKeyPosition[LocoStation] = 0;
                    this.CarPowerKey = false;
                    DieselDirectionControllerInfo = Simulator.Catalog.GetString("Directional lever extended");
                    if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Information(DieselDirectionControllerInfo);
                }
            }
            if (DieselDirectionControllerInOut
                && ((DieselDirectionController && DieselDirection_0) || (DieselDirectionController2 && DieselDirection_0))
                && DieselDirectionController_Out
                )
            {
                DieselDirectionController_In = true;
                DieselDirectionController_Out = false;
                SignalEvent(Event.DieselDirectionControllerIn);
            }
            if (!DieselDirectionControllerInOut
                && ((DieselDirectionController && DieselDirection_0) || (DieselDirectionController2 && DieselDirection_0))
                && DieselDirectionController_In)
            {
                DieselDirectionController_In = false;
                DieselDirectionController_Out = true;
                SignalEvent(Event.DieselDirectionControllerOut);
            }            
        }
        // Ovládání jističe RDST
        public void ToggleRDSTBreaker()
        {
            RDSTBreaker[LocoStation] = !RDSTBreaker[LocoStation];
            if (RDSTBreaker[LocoStation])
                SignalEvent(Event.RDSTOn);
            else
                SignalEvent(Event.RDSTOff);
            if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.RDSTBreaker, RDSTBreaker[LocoStation] ? CabSetting.On : CabSetting.Off);
        }
        // Znovu načte objekty světa
        public void ToggleRefreshWorld(bool refreshWorld)
        {
            Simulator.RefreshWorld = refreshWorld;
            Simulator.Confirmer.Information(Simulator.Catalog.GetString("World Object reloaded!"));
        }
        // Znovu načte objekty kabiny
        public int CabRefreshCycle;
        public void ToggleRefreshCab(bool refreshCab)
        {
            Simulator.RefreshCab = refreshCab;
            Simulator.Confirmer.Information(Simulator.Catalog.GetString("Cab Object reloaded!"));
            if (CVFFileName != null && CabRefreshCycle == 0)
            {
                var cabView = BuildCabView(WagFilePath, CVFFileName);
                if (cabView != null)
                {
                    CabViewList.Clear();
                    CabViewList.Add(cabView);
                    var reverseCVFFileName = Path.Combine(
                        Path.GetDirectoryName(CVFFileName), // Some CVF paths begin with "..\..\", so Path.GetDirectoryName() is needed.
                        Path.GetFileNameWithoutExtension(CVFFileName) + "_rv.cvf"
                    );

                    {
                        cabView = BuildCabView(WagFilePath, reverseCVFFileName);
                        if (cabView != null)
                            CabViewList.Add(cabView);
                    }
                    // practically never happens, but never say never
                    if (CabViewList.Count == 2 && CabViewList[1].CabViewType == CabViewType.Front && CabViewList[0].CabViewType == CabViewType.Rear)
                    {
                        cabView = CabViewList[1];
                        CabViewList.Insert(0, cabView);
                        CabViewList.RemoveAt(2);
                    }
                    // only one cabview, and it looks rear; insert a void one at first place to maintain fast indexing
                    else if (CabViewList.Count == 1 && CabViewList[0].CabViewType == CabViewType.Rear)
                    {
                        UsingRearCab = true;
                        CabViewList.Add(CabViewList[0]);
                        CabViewList[0].CabViewType = CabViewType.Void;
                    }
                }
                CabView3D = BuildCab3DView();
                if (CabViewList.Count == 0 & CabView3D == null)
                    Trace.TraceWarning("{0} locomotive's CabView references non-existent {1}", WagFilePath, CVFFileName);                
            }
            CabRefreshCycle++;
        }

        public int LightsFrameUpdate = 0;
        public void LightPositionHandle()
        {            
            if (LightsFrameUpdate < 3)
                LightsFrameUpdate++;

            FrontHeadLight = HeadLightPosition[1] > 0 ? true : false;
            RearHeadLight = HeadLightPosition[2] > 0 ? true : false;

            if (CircularSwitchEnable)
            {
                // Lights setup
                if (LightsFrameUpdate == 2 && LocoReadyToGo)
                {
                    if (IsLeadLocomotive())
                    {
                        if (Train.Cars.Count == 1)
                        {
                            if (LocoStation == 1)
                            {
                                CircularSwitchWhitePosition[1] = 2;
                                CircularSwitchRedPosition[2] = 2;
                            }
                            if (LocoStation == 2)
                            {
                                CircularSwitchWhitePosition[2] = 2;
                                CircularSwitchRedPosition[1] = 2;
                            }
                        }
                        else
                        {
                            if (LocoStation == 1)
                            {
                                CircularSwitchWhitePosition[1] = 2;                                
                            }
                            if (LocoStation == 2)
                            {
                                CircularSwitchWhitePosition[2] = 2;                                
                            }
                        }
                    }                    
                }

                switch (CircularSwitchWhitePosition[1])
                {
                    case 0: LightFrontLW = false; LightFrontRW = false; break;
                    case 1: LightFrontLW = false; LightFrontRW = true; break;
                    case 2: LightFrontLW = true; LightFrontRW = true; break;
                    case 3: LightFrontLW = true; LightFrontRW = false; break;
                }
                switch (CircularSwitchRedPosition[1])
                {
                    case 0: LightFrontLR = false; LightFrontRR = false; break;
                    case 1: LightFrontLR = false; LightFrontRR = true; break;
                    case 2: LightFrontLR = true; LightFrontRR = true; break;
                    case 3: LightFrontLR = true; LightFrontRR = false; break;
                }

                switch (CircularSwitchWhitePosition[2])
                {
                    case 0: LightRearLW = false; LightRearRW = false; break;
                    case 1: LightRearLW = false; LightRearRW = true; break;
                    case 2: LightRearLW = true; LightRearRW = true; break;
                    case 3: LightRearLW = true; LightRearRW = false; break;
                }
                switch (CircularSwitchRedPosition[2])
                {
                    case 0: LightRearLR = false; LightRearRR = false; break;
                    case 1: LightRearLR = false; LightRearRR = true; break;
                    case 2: LightRearLR = true; LightRearRR = true; break;
                    case 3: LightRearLR = true; LightRearRR = false; break;
                }

            }
            else
            {
                // Lights setup
                if (LightsFrameUpdate == 2 && LocoReadyToGo)
                {
                    if (IsLeadLocomotive() && !AcceptMUSignals)
                    {
                        if (Train.Cars.Count == 1)
                        {
                            LightFrontLPosition = -1;
                            LightFrontRPosition = -1;
                            LightRearLPosition = 1;
                            LightRearRPosition = 1;
                        }
                        else
                        {
                            LightFrontLPosition = -1;
                            LightFrontRPosition = -1;
                        }
                    }
                    if (IsLeadLocomotive() && AcceptMUSignals)
                    {
                        LightFrontLPosition = -1;
                        LightFrontRPosition = -1;
                        LightRearLPosition = 1;
                        LightRearRPosition = 1;
                    }
                }

                switch (LightFrontLPosition)
                {
                    case -1: LightFrontLW = true; LightFrontLR = false; break;
                    case 0: LightFrontLW = false; LightFrontLR = false; break;
                    case 1: LightFrontLW = false; LightFrontLR = true; break;
                }
                switch (LightFrontRPosition)
                {
                    case -1: LightFrontRW = true; LightFrontRR = false; break;
                    case 0: LightFrontRW = false; LightFrontRR = false; break;
                    case 1: LightFrontRW = false; LightFrontRR = true; break;
                }
                switch (LightRearLPosition)
                {
                    case -1: LightRearLW = true; LightRearLR = false; break;
                    case 0: LightRearLW = false; LightRearLR = false; break;
                    case 1: LightRearLW = false; LightRearLR = true; break;
                }
                switch (LightRearRPosition)
                {
                    case -1: LightRearRW = true; LightRearRR = false; break;
                    case 0: LightRearRW = false; LightRearRR = false; break;
                    case 1: LightRearRW = false; LightRearRR = true; break;
                }

                // Světla řízená přes kabel MU
                if (IsLeadLocomotive() && AcceptMUSignals)
                {
                    foreach (TrainCar car in Train.Cars)
                    {
                        if (UsingRearCab)
                        {
                            if (car is MSTSLocomotive && car.AcceptMUSignals && car == Train.FirstCar)
                            {
                                car.LightFrontLPosition = LightFrontLPosition;
                                car.LightFrontRPosition = LightFrontRPosition;
                                car.LightRearLPosition = 0;
                                car.LightRearRPosition = 0;
                                car.LightRearLW = false;
                                car.LightRearLR = false;
                                car.LightRearRW = false;
                                car.LightRearRR = false;
                            }
                            if (car is MSTSLocomotive && car.AcceptMUSignals && car == Train.LastCar)
                            {
                                car.LightFrontLW = false;
                                car.LightFrontLR = false;
                                car.LightFrontRW = false;
                                car.LightFrontRR = false;
                            }
                        }
                        else
                        {
                            if (car is MSTSLocomotive && car.AcceptMUSignals && car == Train.FirstCar)
                            {
                                if (!Flipped)
                                {
                                    car.LightRearLW = false;
                                    car.LightRearLR = false;
                                    car.LightRearRW = false;
                                    car.LightRearRR = false;
                                }
                                if (Flipped)
                                {
                                    car.LightFrontLPosition = LightRearRPosition;
                                    car.LightFrontRPosition = LightRearLPosition;
                                }
                            }

                            if (car is MSTSLocomotive && car.AcceptMUSignals && car == Train.LastCar && !car.CarIsPlayerLoco)
                            {
                                if (!car.Flipped)
                                {
                                    car.LightRearLPosition = LightRearLPosition;
                                    car.LightRearRPosition = LightRearRPosition;
                                    //car.LightFrontLPosition = 0;
                                    //car.LightFrontRPosition = 0;
                                    car.LightFrontLW = false;
                                    car.LightFrontLR = false;
                                    car.LightFrontRW = false;
                                    car.LightFrontRR = false;
                                }
                                else
                                {
                                    car.LightFrontLPosition = LightRearRPosition;
                                    car.LightFrontRPosition = LightRearLPosition;
                                    car.LightRearLPosition = 0;
                                    car.LightRearRPosition = 0;
                                    car.LightRearLW = false;
                                    car.LightRearLR = false;
                                    car.LightRearRW = false;
                                    car.LightRearRR = false;
                                }
                            }

                            if (car is MSTSLocomotive && car.AcceptMUSignals && car == Train.LastCar && car.CarIsPlayerLoco)
                            {
                                if (!car.Flipped)
                                {
                                    car.LightRearLPosition = LightRearLPosition;
                                    car.LightRearRPosition = LightRearRPosition;
                                    //car.LightFrontLPosition = 0;
                                    //car.LightFrontRPosition = 0;
                                    car.LightFrontLW = false;
                                    car.LightFrontLR = false;
                                    car.LightFrontRW = false;
                                    car.LightFrontRR = false;
                                }
                                else
                                {
                                    car.LightRearLW = false;
                                    car.LightRearLR = false;
                                    car.LightRearRW = false;
                                    car.LightRearRR = false;
                                }
                            }
                        }
                    }
                }
            }
            // Nastavení světel pro postrk
            if (!IsLeadLocomotive() && this is MSTSLocomotive && this.LocoHelperOn)
            {
                LightFrontLW = false; LightFrontLR = false; LightFrontRW = false; LightFrontRR = false; LightRearLW = false; LightRearLR = false; LightRearRW = false; LightRearRR = false;
                if (Flipped)
                {
                    if (this == Train.FirstCar)
                    {
                        if (Direction == Direction.Forward)
                            { LightFrontLW = false; LightFrontLR = false; LightFrontRW = false; LightFrontRR = false; LightRearLW = true; LightRearLR = false; LightRearRW = true; LightRearRR = false; }
                        if (Direction == Direction.Reverse)
                            { LightFrontLW = false; LightFrontLR = false; LightFrontRW = false; LightFrontRR = false; LightRearLW = false; LightRearLR = true; LightRearRW = false; LightRearRR = true; }
                    }
                    else
                    if (this == Train.LastCar)
                    {
                        if (Direction == Direction.Forward)
                            { LightFrontLW = false; LightFrontLR = true; LightFrontRW = false; LightFrontRR = true; LightRearLW = false; LightRearLR = false; LightRearRW = false; LightRearRR = false; }
                        if (Direction == Direction.Reverse)
                            { LightFrontLW = true; LightFrontLR = false; LightFrontRW = true; LightFrontRR = false; LightRearLW = false; LightRearLR = false; LightRearRW = false; LightRearRR = false; }
                    }
                }
                else
                {
                    if (this == Train.FirstCar)
                    {
                        if (Direction == Direction.Forward)
                            { LightFrontLW = true; LightFrontLR = false; LightFrontRW = true; LightFrontRR = false; LightRearLW = false; LightRearLR = false; LightRearRW = false; LightRearRR = false; }
                        if (Direction == Direction.Reverse)
                            { LightFrontLW = false; LightFrontLR = true; LightFrontRW = false; LightFrontRR = true; LightRearLW = false; LightRearLR = false; LightRearRW = false; LightRearRR = false; }
                    }
                    else
                    if (this == Train.LastCar)
                    {
                        if (Direction == Direction.Forward)
                            { LightFrontLW = false; LightFrontLR = false; LightFrontRW = false; LightFrontRR = false; LightRearLW = false; LightRearLR = true; LightRearRW = false; LightRearRR = true; }
                        if (Direction == Direction.Reverse)
                            { LightFrontLW = false; LightFrontLR = false; LightFrontRW = false; LightFrontRR = false; LightRearLW = true; LightRearLR = false; LightRearRW = true; LightRearRR = false; }
                    }                    
                }
            }
        }
        
        // Přední levé světlo
        // Červené        
        public void ToggleLightFrontLUp()
        {
            if (CircularSwitchEnable)
            {
                if (CircularSwitchWhitePosition[LocoStation] > 0)
                    CircularSwitchWhitePosition[LocoStation]--;
                else
                    CircularSwitchWhitePosition[LocoStation] = 3;

                SignalEvent(Event.LightSwitchToggle);

                switch (CircularSwitchWhitePosition[LocoStation])
                {
                    case 0: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Lights off")); break;
                    case 1: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Right white light")); break;
                    case 2: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Both white lights")); break;
                    case 3: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Left white light")); break;
                }
            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightFrontLPosition < 1)
                    {
                        LightFrontLPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontLPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontLR, CabSetting.On);
                }
                else
                {
                    if (LightRearRPosition < 1)
                    {
                        LightRearRPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearRPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontLR, CabSetting.On);
                }
            }
        }
        // Bílé
        public void ToggleLightFrontLDown()
        {
            if (CircularSwitchEnable)
            {
                if (CircularSwitchWhitePosition[LocoStation] < 3)
                    CircularSwitchWhitePosition[LocoStation]++;
                else
                    CircularSwitchWhitePosition[LocoStation] = 0;

                SignalEvent(Event.LightSwitchToggle);

                switch (CircularSwitchWhitePosition[LocoStation])
                {
                    case 0: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Lights off")); break;
                    case 1: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Right white light")); break;
                    case 2: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Both white lights")); break;
                    case 3: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Left white light")); break;
                }
            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightFrontLPosition > -1)
                    {
                        LightFrontLPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontLPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontLW, CabSetting.On);
                }
                else
                {
                    if (LightRearRPosition > -1)
                    {
                        LightRearRPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearRPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontLW, CabSetting.On);
                }
            }
        }

        // Přední pravé světlo
        // Červené        
        public void ToggleLightFrontRUp()
        {
            if (CircularSwitchEnable)
            {
                if (CircularSwitchRedPosition[LocoStation] > 0)
                    CircularSwitchRedPosition[LocoStation]--;
                else
                    CircularSwitchRedPosition[LocoStation] = 3;

                SignalEvent(Event.LightSwitchToggle);

                switch (CircularSwitchRedPosition[LocoStation])
                {
                    case 0: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Lights off")); break;
                    case 1: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Right red light")); break;
                    case 2: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Both red lights")); break;
                    case 3: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Left red light")); break;
                }
            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightFrontRPosition < 1)
                    {
                        LightFrontRPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontRPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontRR, CabSetting.On);
                }
                else
                {
                    if (LightRearLPosition < 1)
                    {
                        LightRearLPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearLPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontRR, CabSetting.On);
                }
            }
        }
        // Bílé
        public void ToggleLightFrontRDown()
        {
            if (CircularSwitchEnable)
            {
                if (CircularSwitchRedPosition[LocoStation] < 3)
                    CircularSwitchRedPosition[LocoStation]++;
                else
                    CircularSwitchRedPosition[LocoStation] = 0;

                SignalEvent(Event.LightSwitchToggle);

                switch (CircularSwitchRedPosition[LocoStation])
                {
                    case 0: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Lights off")); break;
                    case 1: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Right red light")); break;
                    case 2: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Both red lights")); break;
                    case 3: Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Left red light")); break;
                }
            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightFrontRPosition > -1)
                    {
                        LightFrontRPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontRPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontRW, CabSetting.On);
                }
                else
                {
                    if (LightRearLPosition > -1)
                    {
                        LightRearLPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearLPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightFrontRW, CabSetting.On);
                }
            }
        }

        // Zadní levé světlo
        // Červené        
        public void ToggleLightRearLUp()
        {
            if (CircularSwitchEnable)
            {

            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightRearLPosition < 1)
                    {
                        LightRearLPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearLPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearLR, CabSetting.On);
                }
                else
                {
                    if (LightFrontRPosition < 1)
                    {
                        LightFrontRPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontRPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearLR, CabSetting.On);
                }
            }
        }
        // Bílé
        public void ToggleLightRearLDown()
        {
            if (CircularSwitchEnable)
            {

            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightRearLPosition > -1)
                    {
                        LightRearLPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearLPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearLW, CabSetting.On);
                }
                else
                {
                    if (LightFrontRPosition > -1)
                    {
                        LightFrontRPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontRPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearLW, CabSetting.On);
                }
            }
        }
        // Zadní pravé světlo
        // Červené        
        public void ToggleLightRearRUp()
        {
            if (CircularSwitchEnable)
            {

            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightRearRPosition < 1)
                    {
                        LightRearRPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearRPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearRR, CabSetting.On);
                }
                else
                {
                    if (LightFrontLPosition < 1)
                    {
                        LightFrontLPosition++;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontLPosition == 1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearRR, CabSetting.On);
                }
            }
        }
        // Bílé
        public void ToggleLightRearRDown()
        {
            if (CircularSwitchEnable)
            {

            }
            else
            {
                if (!UsingRearCab)
                {
                    if (LightRearRPosition > -1)
                    {
                        LightRearRPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightRearRPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearRW, CabSetting.On);
                }
                else
                {
                    if (LightFrontLPosition > -1)
                    {
                        LightFrontLPosition--;
                        SignalEvent(Event.LightSwitchToggle);
                    }
                    LightPositionHandle();
                    if (LightFrontLPosition == -1)
                        if (Simulator.PlayerLocomotive == this) Simulator.Confirmer.Confirm(CabControl.LightRearRW, CabSetting.On);
                }
            }
        }

        // Kapky na oknech - oblast oken
        int RainWindowPosition;
        int RainWindowMaxPosition;
        float RainWindowTimer;        
        float RainWindowTimeDirt;
        float RainWindowTimerNoRain;
        float RainWindowTimeBeginNoRain = 20;
        float RainWindowPower;        
        public void RainWindow(float elapsedSeconds)
        {            
            RainWindowPower = RainWindowMaxPosition * Simulator.Weather.PricipitationIntensityPPSPM2;
            RainWindowTimeDirt = 1 / Simulator.Weather.PricipitationIntensityPPSPM2;            
            // Kapky vysychají za sucha
            if (Simulator.Weather.PricipitationIntensityPPSPM2 < 0.02f)
            {
                RainWindowTimerNoRain += elapsedSeconds;
                if (RainWindowTimerNoRain > RainWindowTimeBeginNoRain)
                {
                    if (RainWindowPosition > 0)
                    {
                        RainWindowPosition--;
                        RainWindowTimerNoRain = 0;                        
                    }
                }
            }
            // Kapky narůstají
            if (Simulator.Weather.PricipitationIntensityPPSPM2 > 0.02f && Simulator.Weather.PrecipitationLiquidity > -0.50f)
            {
                RainWindowTimer += elapsedSeconds;
                if (RainWindowTimer > RainWindowTimeDirt && RainWindowPosition < RainWindowPower)
                {
                    RainWindowPosition++;
                    RainWindowTimer = 0;
                }
            }                        
        }

        // Kapky na oknech - oblast stěračů
        int WipersWindowPosition;
        int WipersWindowMaxPosition;
        float WipersWindowTimer;
        float WipersWindowTimeBegin;
        float WipersWindowTimeDirt;
        float WipersWindowTimerNoRain;
        float WipersWindowTimeBeginNoRain = 20;
        bool WiperStatusChange;
        float WipersWindowPower;
        public float WipersWindowTimeClean;
        public void WipersWindow(float elapsedSeconds)
        {
            WipersWindowPower = WipersWindowMaxPosition * Simulator.Weather.PricipitationIntensityPPSPM2;
            WipersWindowTimeDirt = 1 / Simulator.Weather.PricipitationIntensityPPSPM2;
            WipersWindowTimer += elapsedSeconds;

            // Kapky vysychají za sucha
            if (Simulator.Weather.PricipitationIntensityPPSPM2 < 0.02f)
            {
                WipersWindowTimerNoRain += elapsedSeconds;
                if (WipersWindowTimerNoRain > WipersWindowTimeBeginNoRain)
                {
                    if (WipersWindowPosition > 0)
                    {
                        WipersWindowPosition--;
                        WipersWindowTimerNoRain = 0;
                    }
                }
                WipersWindowTimeBegin = 0;
            }
            if (WipersWindowTimer > WipersWindowTimeBegin)
            {
                // Stěrače vypnuty
                if (!LocoWiper[LocoStation])
                {
                    if (WiperStatusChange)
                    {
                        WiperStatusChange = false;
                        WipersWindowTimeBegin = WipersWindowTimeDirt * 2.0f;
                        WipersWindowTimer = 0;
                        return;
                    }
                    if (Simulator.Weather.PricipitationIntensityPPSPM2 > 0.02f && Simulator.Weather.PrecipitationLiquidity > -0.50f)
                    {
                        // Kapky narůstají
                        if (WipersWindowTimer > WipersWindowTimeDirt && WipersWindowPosition < WipersWindowPower)
                        {
                            WipersWindowPosition++;
                            WipersWindowTimer = 0;
                            WipersWindowTimeBegin = 0;
                        }
                    }
                }
                else
                {
                    // Stěrače zapnuty
                    if (!WiperStatusChange)
                    {
                        WiperStatusChange = true;
                        WipersWindowTimeBegin = WipersWindowTimeClean / 2;
                        WipersWindowTimer = 0;
                        return;
                    }
                    // 
                    if (Simulator.Weather.PricipitationIntensityPPSPM2 > 0.02f && Simulator.Weather.PrecipitationLiquidity > -0.50f
                        && WipersWindowTimer > WipersWindowTimeClean && WipersWindowPosition <= 0)
                    {
                        WipersWindowPosition = 3;
                    }
                    // Kapky se stírají
                    if (WipersWindowTimer > WipersWindowTimeClean && WipersWindowPosition > 0)
                    {
                        WipersWindowPosition = WipersWindowPosition - 2;
                        WipersWindowTimer = 0;
                        WipersWindowTimeBegin = 0;
                    }
                }
            }
        }

        // Přepínač sezóny topení
        bool PreSeasonSwitchPosition;
        public void ToggleSeasonSwitch()
        {            
            if (SeasonSwitchPosition[LocoStation] != PreSeasonSwitchPosition)
            {
                SignalEvent(Event.SeasonSwitch);
                switch (SeasonSwitchPosition[LocoStation])
                {
                    case false:
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("Season heating switched to Summer!"));                        
                        break;
                    case true:
                        Simulator.Confirmer.Information(Simulator.Catalog.GetString("Season heating switched to Winter!"));                        
                        break;
                }
            }
            PreSeasonSwitchPosition = SeasonSwitchPosition[LocoStation];
        }

        // Mirer ovladač        
        public void ToggleMirerControllerUp()
        {
            if (MirerControllerPosition > 0) 
                return;
            if (MirerControllerPosition > -1)
                MirerControllerPosition--;
            MirerTimer3 += elapsedTime;
            if (MirerTimer3 > 0.5f)
                if (MirerControllerPosition > -2)
                    MirerControllerPosition--;
            
            if (PowerOn)
            {
                MirerTimer += elapsedTime;
                if (MirerControllerOneTouch && MirerControllerValue1 == MirerControllerValue2 && LTS410Active == 0)
                {
                    if (MirerControllerValue < MirerMaxValue)
                        MirerControllerValue++;
                    MirerControllerOneTouch = false;
                    //Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue);
                }
                else
                {
                    if (MirerTimer > MirerSmoothPeriod && MirerControllerValue1 == MirerControllerValue2 && LTS410Active == 0)
                    {
                        if (MirerControllerValue < MirerMaxValue)
                            MirerControllerValue++;
                        MirerControllerSmooth = true;
                        MirerTimer = 0.0f;
                        //Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue);
                    }
                }
            }
        }

        public void ToggleMirerControllerDown()
        {
            if (MirerControllerPosition < 0)
                return;
            if (MirerControllerPosition < 1)
                MirerControllerPosition++;
            MirerTimer3 += elapsedTime;
            if (MirerTimer3 > 0.5f)
                if (MirerControllerPosition < 2)
                    MirerControllerPosition++;
            
            if (PowerOn)
            {
                MirerTimer += elapsedTime;
                if (MirerControllerOneTouch && MirerControllerValue1 == MirerControllerValue2)
                {
                    if (MirerControllerValue > -1)
                        MirerControllerValue--;
                    MirerControllerOneTouch = false;
                    //Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue);
                }
                else
                {
                    if (MirerTimer > MirerSmoothPeriod && MirerControllerValue1 == MirerControllerValue2)
                    {
                        if (MirerControllerValue > -1)
                            MirerControllerValue--;
                        MirerControllerSmooth = true;
                        MirerTimer = 0.0f;
                        //Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue);
                    }
                }
            }
        }

        public int MirerControllerValue = -1;
        public int MirerControllerValue1;
        public int MirerControllerValue2;
        public float prevMirerControllerValue = -1;
        public float MirerTimer;
        public float MirerTimer2;
        public float MirerTimer3;
        public float MirerTimer4;
        public bool MirerControllerOneTouch;
        public bool MirerControllerSmooth;
        public float MirerSmoothPeriod = 0.5f;
        public int MirerMinValue = -1;
        public int MirerMaxValue = 42;
        public bool MirerUp;
        public bool MirerDown;
        public bool MirerNoCutPower = true;
        public bool MirerToZero;
        float MirerFastDownPeriod = 0.25f;
        float MirerStepDownPeriod = 0.5f;
        public bool MirerControllerBlocked;
        int LTS410Active = 0;
        int LTS510Active = 0;
        public void MirerController()
        {
            if (!IsLeadLocomotive())
                return;
            
            Simulator.StepControllerMinValue = MirerMinValue;
            Simulator.StepControllerMaxValue = MirerMaxValue;            

            if (MirerControllerEnable)
            {
                // Obecná proměnná pro StepController
                Simulator.StepControllerValue = MirerControllerValue;

                if (MirerControllerPosition != prevMirerControllerPosition)
                {
                    if ((MirerControllerPosition < 0 && MirerControllerPosition < prevMirerControllerPosition)
                        || (MirerControllerPosition > 0 && MirerControllerPosition > prevMirerControllerPosition))                    
                        SignalEvent(Event.MirerPush);
                    else
                    if ((MirerControllerPosition == 0 && MirerControllerPosition > prevMirerControllerPosition)
                        || (MirerControllerPosition == 0 && MirerControllerPosition < prevMirerControllerPosition))
                        SignalEvent(Event.MirerLoosen);

                    prevMirerControllerPosition = MirerControllerPosition;                          
                    switch (MirerControllerPosition)
                    {
                        case -2:
                            break;
                        case -1:                            
                            break;
                        case 0:
                            break;
                        case 1:
                            break;
                        case 2:
                            break;
                    }                    
                }
                // Pokud nastane CutPower, nastaví se kontrolér do 0                
                if (LocalThrottlePercent > 0 && MirerNoCutPower) 
                    MirerNoCutPower = false;
                else
                if (LocalThrottlePercent == 0 && !MirerNoCutPower)
                {
                    MirerControllerValue = -1;
                    MirerNoCutPower = true;
                }
                // Rychlé zkrokování dolů
                if (MirerToZero)
                {
                    MirerTimer2 += elapsedTime;
                    if (MirerTimer2 > MirerFastDownPeriod)
                    {
                        if (MirerControllerValue > -1)
                            MirerControllerValue--;                        
                        MirerTimer2 = 0.0f;
                        //Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue);
                    }
                }

                // LTS-410A
                if (PowerCurrent1 > 410 && LTS510Active == 0)
                {
                    if (LTS410Active != 1)
                        SignalEvent(Event.LTS410On);
                    LTS410Active = 1;                    
                }
                else
                if (PowerCurrent1 < 410 || LTS510Active == 1)
                {
                    if (LTS410Active != 0)
                        SignalEvent(Event.LTS410Off);
                    LTS410Active = 0;
                }

                // LTS-510A
                if (PowerCurrent1 > 510)
                {
                    if (LTS510Active != 1)
                        SignalEvent(Event.LTS510On);
                    LTS510Active = 1;
                    MirerTimer4 += elapsedTime;
                    if (MirerTimer4 > MirerStepDownPeriod)
                    {
                        if (MirerControllerValue > -1)
                            MirerControllerValue--;
                        MirerTimer4 = 0.0f;
                    }
                }
                else
                {
                    if (LTS510Active != 0)
                        SignalEvent(Event.LTS510Off);
                    LTS510Active = 0;
                }

                if (LocalDynamicBrakePercent < 1.0f)
                    LocalDynamicBrakePercent = 0;                

                if (MirerControllerValue != prevMirerControllerValue)
                {
                    prevMirerControllerValue = MirerControllerValue;                                                                                ;
                    switch (MirerControllerValue)
                    {
                        // 0
                        case -1: SetThrottlePercent(0); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": 0"); break;
                        // Kontrolní X
                        case 0: SetThrottlePercent(0); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": X"); break;

                        // Stupně
                        case 1: SetThrottlePercent(1); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 2: SetThrottlePercent(2); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 3: SetThrottlePercent(3); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 4: SetThrottlePercent(4); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 5: SetThrottlePercent(5); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 6: SetThrottlePercent(6); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 7: SetThrottlePercent(7); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 8: SetThrottlePercent(8); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 9: SetThrottlePercent(9); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 10: SetThrottlePercent(12); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 11: SetThrottlePercent(15); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 12: SetThrottlePercent(18); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 13: SetThrottlePercent(21); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 14: SetThrottlePercent(24); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 15: SetThrottlePercent(27); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 16: SetThrottlePercent(30); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 17: SetThrottlePercent(33); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 18: SetThrottlePercent(36); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 19: SetThrottlePercent(39); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 20: SetThrottlePercent(42); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 21: SetThrottlePercent(45); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 22: SetThrottlePercent(48); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 23: SetThrottlePercent(51); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 24: SetThrottlePercent(54); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;

                        // Hospodárný Se
                        case 25: SetThrottlePercent(56); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": Se"); break;

                        case 26: SetThrottlePercent(66); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 27: SetThrottlePercent(68); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 28: SetThrottlePercent(70); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 29: SetThrottlePercent(72); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 30: SetThrottlePercent(74); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 31: SetThrottlePercent(76); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 32: SetThrottlePercent(78); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 33: SetThrottlePercent(80); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 34: SetThrottlePercent(82); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 35: SetThrottlePercent(84); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;
                        case 36: SetThrottlePercent(86); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirerControllerValue); break;

                        // Hospodárný Pa
                        case 37: SetThrottlePercent(88); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": Pa"); break;

                        // P1 - P5
                        case 38: SetThrottlePercent(92); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": P1"); break;
                        case 39: SetThrottlePercent(94); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": P2"); break;
                        case 40: SetThrottlePercent(96); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": P3"); break;
                        case 41: SetThrottlePercent(98); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": P4"); break;
                        case 42: SetThrottlePercent(100); Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": P5"); break;
                    }
                }
            }            
        }

        public bool MirelRSControllerEnable;
        public int[] MirelRSControllerPosition = new int[3];
        public int[] preMirelRSControllerPosition = new int[3];
        public float MirelRSControllerPressTimer;
        public float MirelRSControllerAutoPressTimer;
        public bool MirelRSControllerPressUp;
        public bool MirelRSControllerPressDown;
        public bool MirelRSControllerAutoPressDown;
        public string[] MirelRSControllerPositionName = new string[3];
        public float MirelRSControllerThrottleValue;
        public float preMirelRSControllerThrottleValue;
        public float MirelRSControllerThrottleDummyValue;
        public float MirelRSControllerEDBValue = -1;        
        public float MirelRSControllerMaxValue = 56;
        public float MirelRSControllerThrottleValueTimer;
        public float MirelRSControllerEDBValueTimer;
        bool MirelRSControllerCanThrottleChangeValue_0;
        bool MirelRSControllerCanThrottleChangeValue_1;
        bool MirelRSControllerCanThrottleChangeValue_2;
        bool MirelRSControllerCanThrottleChangeValue_3;
        bool MirelRSControllerCanEDBChangeValue_0;
        bool MirelRSControllerCanEDBChangeValue_1;
        bool MirelRSControllerCanEDBChangeValue_2;
        bool MirelRSControllerLongPressUp;
        bool MirelRSControllerShortPressUp;
        bool MirelRSControllerLongPressDown;
        bool MirelRSControllerShortPressDown;
        public bool MirelRSEDBBreak;
        public float MirelRSControllerDisplayValue;
        public float MirelRSControllerDisplay2Value;
        public bool ShModeActivated;
        public bool ShModeActivated2;
        public bool NoShMode;
        public bool Mode_To_34_Ready;
        public bool Mode_To_34_Start;                
        public bool Mode_To_27_Start1;
        public bool Mode_To_27_Start2;        
        public bool Mode_To_27_Start2_Enable;
        public int MirelRSSkipDiode;
        public bool MirelRSCanSkip;
        public bool MirelRSSkip_Start;
        public bool MirelRSPositionBlocked;

        public bool DirectionControllerMirelRSPositionSh;
        public bool preDirectionControllerMirelRSPositionSh;
        public bool MirelRSDirectionControllerPressUp;
        public bool MirelRSDirectionControllerPressDown;
        public int[] MirelRSDirectionControllerPosition = new int[3];
        public int[] preMirelRSDirectionControllerPosition = new int[3];
        public string[] MirelRSDirectionControllerPositionName = new string[3];

        public void MirelRSController(float elapsedClockSeconds)
        {
            if (!IsLeadLocomotive())
                return;

            if (!MirelRSControllerEnable)
                return;


            if (MirelRSDirectionControllerPressUp)
            {
                if (((MirelRSDirectionControllerPosition[LocoStation] == 0 || MirelRSDirectionControllerPosition[LocoStation] == 1) && AbsSpeedMpS < 0.1f) || MirelRSDirectionControllerPosition[LocoStation] == 2)
                {
                    if (MirelRSDirectionControllerPosition[LocoStation] < 3)
                    {
                        if (MirelRSDirectionControllerPosition[LocoStation] == 2)
                            SignalEvent(Event.ReverserToShOn);
                        if (MirelRSDirectionControllerPosition[LocoStation] == 1)
                            SignalEvent(Event.ReverserToForwardBackward);
                        if (MirelRSDirectionControllerPosition[LocoStation] == 0)
                            SignalEvent(Event.ReverserToNeutral);                        
                        MirelRSDirectionControllerPosition[LocoStation]++;                                                
                    }
                }
            }

            if (MirelRSDirectionControllerPressDown)
            {
                if (((MirelRSDirectionControllerPosition[LocoStation] == 1 || MirelRSDirectionControllerPosition[LocoStation] == 2) && AbsSpeedMpS < 0.1f) || MirelRSDirectionControllerPosition[LocoStation] == 3)
                {
                    if (MirelRSDirectionControllerPosition[LocoStation] > 0)
                    {
                        if (MirelRSDirectionControllerPosition[LocoStation] == 3)
                            SignalEvent(Event.ReverserToShOff);
                        if (MirelRSDirectionControllerPosition[LocoStation] == 2)
                            SignalEvent(Event.ReverserToNeutral);
                        if (MirelRSDirectionControllerPosition[LocoStation] == 1)
                            SignalEvent(Event.ReverserToForwardBackward);
                        MirelRSDirectionControllerPosition[LocoStation]--;                        
                    }
                }
            }

            // Pozice MireluRS směrpáky
            if (StationIsActivated[LocoStation])
            {
                if (MirelRSDirectionControllerPosition[LocoStation] != preMirelRSDirectionControllerPosition[LocoStation])
                {
                    preMirelRSDirectionControllerPosition[LocoStation] = MirelRSDirectionControllerPosition[LocoStation];
                    DirectionControllerMirelRSPositionSh = false;
                    switch (MirelRSDirectionControllerPosition[LocoStation])
                    {
                        case 0:
                            MirelRSDirectionControllerPositionName[LocoStation] = "Z"; // nearetovaná                        
                            Direction = Direction.Reverse;
                            break;
                        case 1:                            
                            MirelRSDirectionControllerPositionName[LocoStation] = "0";
                            Direction = Direction.N;
                            break;
                        case 2:
                            MirelRSDirectionControllerPositionName[LocoStation] = "P"; // nearetovaná
                            Direction = Direction.Forward;
                            break;
                        case 3:
                            MirelRSDirectionControllerPositionName[LocoStation] = "Sh";
                            DirectionControllerMirelRSPositionSh = true;
                            Direction = Direction.Forward;
                            break;
                    }
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("DirectionController") + ": " + MirelRSDirectionControllerPositionName[LocoStation]);
                }
            }            

            if (MirelRSControllerPressUp)
            {
                MirelRSControllerPressTimer += elapsedClockSeconds;

                // Delší stisk
                if (MirelRSControllerPressTimer > 0.5f)
                {
                    if (MirelRSControllerPosition[LocoStation] < 7 && (MirelRSControllerPosition[LocoStation] != 2 || (MirelRSEDBBreak && MirelRSControllerPosition[LocoStation] == 2)))
                    {
                        MirelRSControllerPosition[LocoStation]++;
                        SignalEvent(Event.MirerPush);
                        MirelRSEDBBreak = false;
                    }
                    MirelRSControllerPressTimer = 0;
                    MirelRSControllerLongPressUp = true;
                }
                // Krátký stisk
                else
                {
                    if (MirelRSControllerPosition[LocoStation] == 5)
                    {
                        MirelRSControllerPosition[LocoStation] = 6;
                        SignalEvent(Event.MirerPush);
                    }

                    if (MirelRSControllerPosition[LocoStation] == 1)
                    {
                        MirelRSControllerPosition[LocoStation] = 2;
                        SignalEvent(Event.MirerPush);
                    }
                    MirelRSControllerShortPressUp = true;
                }
            }

            if (MirelRSControllerPressDown)
            {
                MirelRSControllerPressTimer += elapsedClockSeconds;

                // Delší stisk
                if (MirelRSControllerPressTimer > 0.5f)
                {
                    if (MirelRSControllerPosition[LocoStation] > 0)
                    {
                        MirelRSControllerPosition[LocoStation]--;
                        SignalEvent(Event.MirerPush);
                    }
                    MirelRSControllerPressTimer = 0;
                    MirelRSControllerLongPressDown = true;
                }
                // Krátký stisk
                else
                {
                    if (MirelRSControllerPosition[LocoStation] == 5)
                    {
                        MirelRSControllerPosition[LocoStation] = 4;
                        SignalEvent(Event.MirerPush);
                    }

                    if (MirelRSControllerPosition[LocoStation] == 1)
                    {
                        MirelRSControllerPosition[LocoStation] = 0;
                        SignalEvent(Event.MirerPush);
                    }
                    MirelRSControllerShortPressDown = true;
                }
            }

            if (MirelRSControllerAutoPressDown)
            {
                MirelRSControllerAutoPressTimer += elapsedClockSeconds;

                if (MirelRSControllerAutoPressTimer > 0.25f)
                {
                    if (MirelRSControllerPosition[LocoStation] > 5 || MirelRSControllerPosition[LocoStation] == 2)
                    {
                        MirelRSControllerPosition[LocoStation]--;
                        SignalEvent(Event.MirerLoosen);
                    }
                    else
                        MirelRSControllerAutoPressDown = false;
                    MirelRSControllerAutoPressTimer = 0;
                }                
            }

            // Pozice MireluRS
            if (MirelRSControllerPosition[LocoStation] != preMirelRSControllerPosition[LocoStation])
            {
                preMirelRSControllerPosition[LocoStation] = MirelRSControllerPosition[LocoStation];
                switch (MirelRSControllerPosition[LocoStation])
                {
                    case 0:
                        MirelRSControllerPositionName[LocoStation] = "+B"; // nearetovaná                        
                        MirelRSControllerShortPressDown = false;                        
                        MirelRSControllerCanEDBChangeValue_2 = true;
                        break;
                    case 1:
                        MirelRSControllerPositionName[LocoStation] = "B";                        
                        MirelRSControllerLongPressDown = false;
                        MirelRSControllerCanEDBChangeValue_0 = MirelRSControllerCanEDBChangeValue_1 = MirelRSControllerCanEDBChangeValue_2 = false;
                        break;
                    case 2:
                        MirelRSControllerPositionName[LocoStation] = "-B"; // nearetovaná
                        MirelRSControllerShortPressUp = false;                        
                        MirelRSControllerCanEDBChangeValue_1 = true;
                        break;
                    case 3:
                        MirelRSControllerPositionName[LocoStation] = "0";
                        MirelRSControllerLongPressUp = false;
                        MirelRSControllerLongPressDown = false;                        
                        MirelRSControllerCanThrottleChangeValue_0 = true;
                        MirelRSControllerCanEDBChangeValue_0 = true;
                        break;
                    case 4:
                        MirelRSControllerPositionName[LocoStation] = "-1"; // nearetovaná
                        MirelRSControllerShortPressDown = false;                                             
                        MirelRSControllerCanThrottleChangeValue_1 = true;                        
                        break;
                    case 5:
                        MirelRSControllerPositionName[LocoStation] = "J";
                        MirelRSControllerLongPressUp = false;
                        MirelRSControllerLongPressDown = false;
                        MirelRSPositionBlocked = false;
                        break;
                    case 6:
                        MirelRSControllerPositionName[LocoStation] = "+1"; // nearetovaná
                        MirelRSControllerShortPressUp = false;                        
                        MirelRSControllerCanThrottleChangeValue_2 = true;                        
                        break;
                    case 7:
                        MirelRSControllerPositionName[LocoStation] = "++";
                        MirelRSControllerLongPressUp = false;                       
                        MirelRSControllerCanThrottleChangeValue_3 = true;                                                    
                        break;
                }
                Simulator.Confirmer.Information(Simulator.Catalog.GetString("Controller") + ": " + MirelRSControllerPositionName[LocoStation]);                               
            }

            MirelRSControllerDisplayValue = MirelRSControllerDisplay2Value = MirelRSControllerThrottleValue;
            
            // Hodnoty pro StepController
            if (MirelRSControllerCanThrottleChangeValue_0 || MirelRSControllerCanThrottleChangeValue_1 || MirelRSControllerCanThrottleChangeValue_2 || MirelRSControllerCanThrottleChangeValue_3
                || ShModeActivated || Mode_To_34_Start || ShModeActivated2 || Mode_To_27_Start1 || Mode_To_27_Start2
                || (NoShMode && MirelRSControllerThrottleValue > 27 && MirelRSControllerThrottleValue < 34 && !Mode_To_34_Start)
                || MirelRSSkip_Start) 
            {                
                MirelRSControllerThrottleValueTimer += elapsedClockSeconds;

                // Šuntování a blokování
                if (DirectionControllerMirelRSPositionSh && MirelRSControllerThrottleValue <= 32)
                    MirelRSControllerMaxValue = 32f;
                else
                if (DirectionControllerMirelRSPositionSh && MirelRSControllerThrottleValue <= 56)
                    MirelRSControllerMaxValue = 56f;
                else
                    MirelRSControllerMaxValue = 51f;

                if ((MirelRSControllerThrottleValue < 27 || (MirelRSControllerThrottleValue > 32 && MirelRSControllerThrottleValue < 51)))
                    NoShMode = true;
                else
                    NoShMode = false;

                if (DirectionControllerMirelRSPositionSh && MirelRSControllerThrottleValue >= 51)
                {                    
                    ShModeActivated2 = true;                    
                }
                // Auto skrokování do 51
                if (ShModeActivated2 && !DirectionControllerMirelRSPositionSh)
                {
                    MirelRSControllerMaxValue = 56f;
                    if (MirelRSControllerThrottleValueTimer > 0.25f)
                    {
                        if (MirelRSControllerThrottleValue > 51f)
                            MirelRSControllerThrottleValue--;
                        MirelRSControllerThrottleValueTimer = 0;
                        if (MirelRSControllerThrottleValue <= 51f)
                        {
                            ShModeActivated2 = false;                            
                        }
                    }
                }

                if (DirectionControllerMirelRSPositionSh && MirelRSControllerThrottleValue == 27 && !ShModeActivated)
                    ShModeActivated = true;

                // Auto 1.skrokování do 27
                if ((ShModeActivated && !DirectionControllerMirelRSPositionSh) || Mode_To_27_Start1)                    
                {
                    Mode_To_27_Start1 = true;
                    if (MirelRSControllerThrottleValueTimer > 0.25f)
                    {
                        if (MirelRSControllerThrottleValue > 27f)
                            MirelRSControllerThrottleValue--;                        
                        MirelRSControllerThrottleValueTimer = 0;
                        if (MirelRSControllerThrottleValue <= 27f)
                        {
                            Mode_To_27_Start1 = false;
                            ShModeActivated = false;                                                      
                        }
                    }
                }

                // Auto 2.skrokování do 27
                if (MirelRSControllerThrottleValue >= 34)
                {
                    Mode_To_27_Start2_Enable = true;
                    preDirectionControllerMirelRSPositionSh = DirectionControllerMirelRSPositionSh;
                }
                if (MirelRSControllerThrottleValue <= 27)
                    Mode_To_27_Start2_Enable = false;
                if ((NoShMode && MirelRSControllerThrottleValue > 27 && MirelRSControllerThrottleValue < 34 && !Mode_To_34_Start && Mode_To_27_Start2_Enable) || Mode_To_27_Start2)
                {
                    Mode_To_27_Start2 = true;
                    DirectionControllerMirelRSPositionSh = false;
                    if (MirelRSControllerThrottleValueTimer > 0.25f)
                    {
                        if (MirelRSControllerThrottleValue > 27f)
                            MirelRSControllerThrottleValue--;
                        MirelRSControllerThrottleValueTimer = 0;
                        if (MirelRSControllerThrottleValue <= 27f)
                        {
                            Mode_To_27_Start2 = false;
                            DirectionControllerMirelRSPositionSh = preDirectionControllerMirelRSPositionSh;
                        }
                    }
                }

                // Auto krokování do 34 
                if (((!DirectionControllerMirelRSPositionSh && MirelRSControllerThrottleValue > 26 && MirelRSControllerThrottleValue < 34 && MirelRSControllerPositionName[LocoStation] == "+1") || Mode_To_34_Start) && !MirelRSPositionBlocked)
                {
                    MirelRSControllerCanThrottleChangeValue_2 = false;
                    Mode_To_34_Start = true;
                    if (MirelRSControllerThrottleValueTimer > 0.25f)
                    {
                        if (MirelRSControllerThrottleValue < 34f)
                            MirelRSControllerThrottleValue++;
                        MirelRSControllerThrottleValueTimer = 0;
                        if (MirelRSControllerThrottleValue == 34f)
                        {
                            Mode_To_34_Start = false;                            
                        }
                    }
                }                

                if (MirelRSControllerThrottleValueTimer > 0.25f)
                {
                    // 0
                    if (MirelRSControllerCanThrottleChangeValue_0)
                    {
                        if (PowerCurrent1 < 300f && MirelRSControllerThrottleValue <= 27f)
                            MirelRSControllerThrottleValue = 0;
                        else
                        if (MirelRSControllerThrottleValue > 0f)
                            MirelRSControllerThrottleValue--;                        
                        MirelRSControllerThrottleValueTimer = 0;
                        if (MirelRSControllerThrottleValue == 0 || MirelRSControllerPositionName[LocoStation] == "+1" || MirelRSControllerPositionName[LocoStation] == "-1")
                            MirelRSControllerCanThrottleChangeValue_0 = false;
                    }
                }

                if ((MirelRSControllerThrottleValueTimer > 0.5f && !Mode_To_27_Start1 && !Mode_To_27_Start2 && !Mode_To_34_Start) || MirelRSSkip_Start)
                {
                    // -1
                    if (MirelRSControllerCanThrottleChangeValue_1 && MirelRSControllerShortPressDown)
                        if (MirelRSControllerThrottleValue > 0)                        
                            MirelRSControllerThrottleValue--;                                                    
                    
                    // +1
                    if (MirelRSControllerCanThrottleChangeValue_2 && MirelRSControllerShortPressUp)
                        if (MirelRSControllerThrottleValue < MirelRSControllerMaxValue)                        
                            MirelRSControllerThrottleValue++;                                                    

                    // ++
                    if (MirelRSControllerCanThrottleChangeValue_3 || MirelRSSkip_Start)
                    {
                        if (MirelRSCanSkip || MirelRSSkip_Start)
                        {
                            MirelRSSkip_Start = true;
                            if (PowerCurrent1 < 600f && Simulator.StepControllerValue <= 26)
                                Simulator.StepControllerValue++;
                            else
                            {
                                MirelRSControllerThrottleValue = Simulator.StepControllerValue;
                                MirelRSSkip_Start = false;
                                MirelRSPositionBlocked = true;
                            }
                        }
                    }

                    MirelRSControllerThrottleValueTimer = 0;
                    MirelRSControllerCanThrottleChangeValue_1 = MirelRSControllerCanThrottleChangeValue_2 = MirelRSControllerCanThrottleChangeValue_3 = false;
                }                
            }

            // Dioda pro přeskok stupňů
            if (PowerCurrent1 > 10f && PowerCurrent1 < 300f && MirelRSControllerThrottleValue < 27f)
            {
                MirelRSCanSkip = true;
                MirelRSSkipDiode = 1;
            }
            else
            {
                MirelRSCanSkip = false;
                MirelRSSkipDiode = 0;
            }

            // Obecná proměnná pro StepController
            MirelRSControllerThrottleDummyValue = 0;
            if (!DirectionControllerMirelRSPositionSh && MirelRSControllerThrottleValue > 27 && MirelRSControllerThrottleValue < 33)
            {
                MirelRSControllerThrottleDummyValue = 27;
                Simulator.StepControllerValue = MirelRSControllerThrottleDummyValue;
            }
            if (MirelRSControllerThrottleDummyValue == 0 && !MirelRSSkip_Start)
                Simulator.StepControllerValue = MirelRSControllerThrottleValue;


            // Hodnoty pro EDB
            if (MirelRSControllerCanEDBChangeValue_0 || MirelRSControllerCanEDBChangeValue_1 || MirelRSControllerCanEDBChangeValue_2)
            {
                MirelRSControllerEDBValueTimer += elapsedClockSeconds;

                if (MirelRSControllerEDBValueTimer > 0.05f)
                {
                    // 0
                    if (MirelRSControllerCanEDBChangeValue_0)
                    {
                        if (MirelRSControllerEDBValue > -1f)
                            MirelRSControllerEDBValue--;
                        if (MirelRSControllerEDBValue == -1)
                            MirelRSControllerCanEDBChangeValue_0 = MirelRSControllerCanEDBChangeValue_1 = MirelRSControllerCanEDBChangeValue_2 = false;
                    }

                    // -B
                    if (MirelRSControllerCanEDBChangeValue_1)
                    {
                        if (MirelRSControllerEDBValue == -1) MirelRSControllerEDBValue = 0;
                        if (MirelRSControllerEDBValue > 0)
                            MirelRSControllerEDBValue--;
                    }

                    // +B
                    if (MirelRSControllerCanEDBChangeValue_2)
                    {
                        if (MirelRSControllerEDBValue == -1) MirelRSControllerEDBValue = 0;
                        if (MirelRSControllerEDBValue < 100f)
                            MirelRSControllerEDBValue++;
                    }
                    
                    MirelRSControllerEDBValueTimer = 0;                    
                }
            }
            if (MirelRSControllerThrottleValue > preMirelRSControllerThrottleValue)
            {
                ThrottleController.StartIncrease();
                ThrottleController.StopIncrease();
                SignalEvent(Event.ThrottleChange);
                preMirelRSControllerThrottleValue = MirelRSControllerThrottleValue;
            }
            if (MirelRSControllerThrottleValue < preMirelRSControllerThrottleValue)
            {
                ThrottleController.StartDecrease();
                ThrottleController.StopDecrease();
                SignalEvent(Event.ThrottleChange);
                preMirelRSControllerThrottleValue = MirelRSControllerThrottleValue;
            }            
            SetDynamicBrakePercent(MirelRSControllerEDBValue);
            
            Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + MirelRSControllerThrottleValue);

            // Ochrany
            if (AbsSpeedMpS > 50f / 3.6f)
            {
                if (Pantographs[1].State == PantographState.Up && Pantographs[2].State == PantographState.Up)
                {
                    Simulator.StepControllerValue = 0;
                }
            }
            if (DRTemperature > 100f && MirelRSControllerThrottleValue > 27 && MirelRSControllerThrottleValue <= 56)
            {
                Mode_To_27_Start1 = true;
            }
        }


        public bool CommandCylinderEnable;
        public int CommandCylinderMaxPosition;
        public int[] preCommandCylinderPosition = new int[3];
        public int[] CommandCylinderPosition = new int[3];
        public float CommandCylinderTimerIsDownKey;
        public float CommandCylinderThrottleTimer;
        public float CommandCylinderTimer2;
        public float CommandCylinderTimer3;
        public float CommandCylinderThrottleDelay;
        public bool CommandCylinderToZero;
        float CommandCylinderToZeroPeriod;
        public float CommandCylinderPeriod;
        public float CommandCylinderTimerIsDownKeyPeriod = 0.5f;
        public bool CommandCylinderUp;
        public bool CommandCylinderDown;
        public bool CommandCylinderThrottleChangeUp;
        public bool CommandCylinderThrottleChangeDown;
        public int[] CommandCylinderThrottlePosition = new int[3];
        public void CommandCylinder(float elapsedClockSeconds)
        {
            if (!IsLeadLocomotive())
                return;

            if (!CommandCylinderEnable)
                return;

            CommandCylinderThrottleDelay = 0.25f;
            CommandCylinderToZeroPeriod = 0.05f;
            CommandCylinderPeriod = 0.05f;

            // Rychlé zkrokování do 0
            if (CommandCylinderToZero)
            {
                CommandCylinderTimer2 += elapsedClockSeconds;
                if (CommandCylinderTimer2 > CommandCylinderToZeroPeriod)
                {
                    if (CommandCylinderPosition[LocoStation] > 0)
                        CommandCylinderPosition[LocoStation]--;
                    CommandCylinderTimer2 = 0.0f;
                    CommandCylinderDown = true;
                    if (StationIsActivated[LocoStation])
                    {
                        CommandCylinderThrottleChangeUp = false;
                        CommandCylinderThrottleChangeDown = true;
                    }
                }
            }
            if (CommandCylinderPosition[LocoStation] == 0 && CommandCylinderToZero)
            {
                CommandCylinderToZero = false;                
                CommandCylinderThrottleChangeDown = false;                
            }

            // Krokování nahoru
            if (CommandCylinderUp)
            {
                CommandCylinderTimerIsDownKey += elapsedClockSeconds;
                if (CommandCylinderTimerIsDownKey > CommandCylinderTimerIsDownKeyPeriod)
                {
                    CommandCylinderTimer3 += elapsedClockSeconds;
                    if (CommandCylinderTimer3 > CommandCylinderPeriod)
                    {
                        if (CommandCylinderPosition[LocoStation] < CommandCylinderMaxPosition - 1)
                            CommandCylinderPosition[LocoStation]++;
                        CommandCylinderTimer3 = 0.0f;
                    }
                }
            }
            // Krokování dolu
            if (CommandCylinderDown && !CommandCylinderToZero)
            {
                CommandCylinderTimerIsDownKey += elapsedClockSeconds;
                if (CommandCylinderTimerIsDownKey > CommandCylinderTimerIsDownKeyPeriod)
                {
                    CommandCylinderTimer3 += elapsedClockSeconds;
                    if (CommandCylinderTimer3 > CommandCylinderPeriod)
                    {
                        if (CommandCylinderPosition[LocoStation] > 0)
                            CommandCylinderPosition[LocoStation]--;
                        CommandCylinderTimer3 = 0.0f;
                    }
                }
            }

            if (CommandCylinderPosition[LocoStation] != preCommandCylinderPosition[LocoStation])
            {
                preCommandCylinderPosition[LocoStation] = CommandCylinderPosition[LocoStation];

                if (StationIsActivated[LocoStation])
                {
                    if (CommandCylinderUp && CommandCylinderPosition[LocoStation] > CommandCylinderThrottlePosition[LocoStation])
                    {
                        CommandCylinderThrottleChangeUp = true;
                        CommandCylinderThrottleChangeDown = false;
                    }
                    if (CommandCylinderDown && CommandCylinderPosition[LocoStation] < CommandCylinderThrottlePosition[LocoStation])
                    {
                        CommandCylinderThrottleChangeUp = false;
                        CommandCylinderThrottleChangeDown = true;
                    }
                    if (CommandCylinderUp && CommandCylinderPosition[LocoStation] < CommandCylinderThrottlePosition[LocoStation])
                    {
                        CommandCylinderThrottleChangeUp = false;
                        CommandCylinderThrottleChangeDown = true;
                    }
                    if (CommandCylinderDown && CommandCylinderPosition[LocoStation] > CommandCylinderThrottlePosition[LocoStation])
                    {
                        CommandCylinderThrottleChangeUp = true;
                        CommandCylinderThrottleChangeDown = false;
                    }
                }
                
                if (CommandCylinderUp)
                    SignalEvent(Event.CommandCylinderPositionChangeUp);
                if (CommandCylinderDown)
                    SignalEvent(Event.CommandCylinderPositionChangeDown);

                Simulator.Confirmer.MSG(Simulator.Catalog.GetString("Controller") + ": " + CommandCylinderPosition[LocoStation]);
            }

            // Pozice throttle na válci
            if (CommandCylinderThrottleChangeUp)
            {
                CommandCylinderThrottleTimer += elapsedClockSeconds;
                if (CommandCylinderThrottleTimer > CommandCylinderThrottleDelay)
                {
                    ThrottleController.StartIncrease();
                    ThrottleController.StopIncrease();                    
                    CommandCylinderThrottleTimer = 0;
                    CommandCylinderThrottlePosition[LocoStation]++;
                    SignalEvent(Event.CommandCylinderThrottlePositionChangeUp);
                }
                if (CommandCylinderThrottlePosition[LocoStation] == CommandCylinderPosition[LocoStation])
                {
                    CommandCylinderThrottleChangeUp = false;
                    CommandCylinderThrottleTimer = 0;
                }
            }

            if (CommandCylinderThrottleChangeDown)
            {
                CommandCylinderThrottleTimer += elapsedClockSeconds;
                if (CommandCylinderThrottleTimer > CommandCylinderThrottleDelay)
                {
                    ThrottleController.StartDecrease();
                    ThrottleController.StopDecrease();
                    CommandCylinderThrottleTimer = 0;
                    CommandCylinderThrottlePosition[LocoStation]--;
                    SignalEvent(Event.CommandCylinderThrottlePositionChangeDown);
                }
                if (CommandCylinderThrottlePosition[LocoStation] == CommandCylinderPosition[LocoStation])
                {
                    CommandCylinderThrottleChangeDown = false;
                    CommandCylinderThrottleTimer = 0;
                }
            }
            //Simulator.Confirmer.Warning("CommandCylinderThrottlePosition: " + CommandCylinderThrottlePosition[LocoStation]);
        }

        #endregion


        // Zatím povoleno kvůli kompatibilitě
        int NumberChoice = 1;
        public void ToggleControlRouteVoltage()
        {
            if (!IsPlayerTrain)
                return;
            if (!EnableControlVoltageChange)
                return;
            NumberChoice++;
            if (NumberChoice > 3)
                NumberChoice = 1;
            SwitchingVoltageMode = 1;
            SwitchingVoltageMode_OffAC = false;
            SwitchingVoltageMode_OffDC = false;
            switch (NumberChoice)
            {
                case 1:
                    LocomotivePowerVoltage = 25000;
                    MultiSystemEngine = false;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Power system changed to 25kV."));
                    break;
                case 2:
                    MultiSystemEngine = true;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Power system changed to 3kV + 15kV + 25kV."));
                    switch (RouteVoltageV)
                    {
                        case 3000:
                            SwitchingVoltageMode = 0;
                            LocomotivePowerVoltage = 3000;
                            SwitchingVoltageMode_OffDC = true;
                            break;
                        case 15000:
                            SwitchingVoltageMode = 2;
                            LocomotivePowerVoltage = 15000;
                            SwitchingVoltageMode_OffAC = true;
                            break;
                        case 25000:
                            SwitchingVoltageMode = 2;
                            LocomotivePowerVoltage = 25000;
                            SwitchingVoltageMode_OffAC = true;
                            break;
                    }
                    break;
                case 3:
                    LocomotivePowerVoltage = 3000;
                    MultiSystemEngine = false;
                    Simulator.Confirmer.Information(Simulator.Catalog.GetString("Power system changed to 3kV."));
                    break;
            }
        }

        public void SetVoltageMarker(int newVoltage)
        {
            if (!Simulator.SuperUser)
                return;
            // uložím marker
            SetVoltageMarkerPosition(newVoltage);
            if (newVoltage == 3000)
            {
                RouteVoltageChange = true;
                RouteVoltageV = 3000;
            }
            if (newVoltage == 15000)
            {
                RouteVoltageChange = true;
                RouteVoltageV = 15000;
            }
            else if (newVoltage == 25000)
            {
                RouteVoltageChange = false;
                RouteVoltageV = 25000;
            }
            else if (newVoltage == 0)
                RouteVoltageV = 0;
        }

        public void DeleteVoltageMarker()
        {
            if (!Simulator.SuperUser)
                return;
            MSTSElectricLocomotive eloco = null;
            if (this is MSTSElectricLocomotive)
            {
                eloco = (MSTSElectricLocomotive)this;
            }
            else
                return;
            int markerId = eloco.marker.Id;

            cz.aspone.lkpr.WebService ws = new cz.aspone.lkpr.WebService();

            if (!VoltageMarkersDbVersionUpdated)
            {
                string result = ws.GetPowerSuplyMarkerVersion(Simulator.TRK.Tr_RouteFile.FileName);
                int v = int.Parse(result);
                VoltageMarkersDbVersion = v + 1;
                ws.UpdatePowerSupplyMarkerVersion(VoltageMarkersDbVersion, Simulator.TRK.Tr_RouteFile.FileName);
                VoltageMarkersDbVersionUpdated = true;
            }
            FileInfo fi = new FileInfo(Simulator.TRK.Tr_RouteFile.FullFileName);
            File.WriteAllText(fi.DirectoryName + "\\VoltageChangeMarkersDbVersion.ini", VoltageMarkersDbVersion.ToString());

            ws.DeleteVoltageMarker(markerId, Simulator.TRK.Tr_RouteFile.FileName);

            if (voltageMarkersXml == null)
            {
                voltageMarkersXml = new XmlDocument();
                voltageMarkersXml.Load(Simulator.RoutePath + "\\VoltageChangeMarkers.xml");
            }

            foreach (XmlNode node in voltageMarkersXml.ChildNodes)
            {
                if (node.Name == "VoltageChangeMarkers")
                {
                    foreach (XmlNode node1 in node)
                    {
                        if (node1.Name == "Marker")
                        {
                            foreach (XmlNode node2 in node1.ChildNodes)
                            {
                                if (node2.Name == "Id")
                                {
                                    if (node2.InnerText == markerId.ToString())
                                    {
                                        node.RemoveChild(node1);
                                        goto Save;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        Save:
            voltageMarkersXml.Save(Simulator.RoutePath + "\\VoltageChangeMarkers.xml");
            SetUpVoltageChangeMarkers();
            Simulator.Confirmer.Information(Simulator.Catalog.GetString("The marker has been deleted and marked for deletion in an external database."));
        }


        public enum TrainType { Pax, Cargo };
        public TrainType[] SelectedTrainType = new TrainType[3];
        public void ChangeTrainTypePaxCargo()
        {
            SelectedTrainType[LocoStation] = SelectedTrainType[LocoStation] == TrainType.Pax ? SelectedTrainType[LocoStation] = TrainType.Cargo : TrainType.Pax;
        }

        XmlDocument powerStationXml;
        int PowerSuplyStationDbVersion = 0;
        bool PowerSuplyStationDbVersionUpdated = false;
        public void SetPowerSupplyStationLocation()
        {
            if (!Simulator.SuperUser)
                return;

            cz.aspone.lkpr.WebService webService = new cz.aspone.lkpr.WebService();
            if (!PowerSuplyStationDbVersionUpdated)
            {
                int v = int.Parse(webService.GetPowerSuplyStationVersion(Simulator.TRK.Tr_RouteFile.FileName));
                PowerSuplyStationDbVersion = v + 1;
                webService.UpdatePowerSuplyStationVersion(PowerSuplyStationDbVersion, Simulator.TRK.Tr_RouteFile.FileName);
                PowerSuplyStationDbVersionUpdated = true;
            }
            FileInfo fi = new FileInfo(Simulator.TRK.Tr_RouteFile.FullFileName);
            File.WriteAllText(fi.DirectoryName + "\\PowerSupplyStationsDbVersion.ini", PowerSuplyStationDbVersion.ToString());

            double latitude = 0;
            double longitude = 0;
            new WorldLatLon().ConvertWTC(WorldPosition.TileX, WorldPosition.TileZ, WorldPosition.WorldLocation.Location, ref latitude, ref longitude);

            if (powerStationXml == null)
            {
                powerStationXml = new XmlDocument();
                powerStationXml.Load(Simulator.RoutePath + "\\PowerSupplyStations.xml");
            }

            int id = webService.SavePowerSupplyStation(-1, Simulator.TRK.Tr_RouteFile.Name, longitude.ToString(), latitude.ToString(), RouteVoltageV == 3000 ? "0" : "1", PowerSuplyStationDbVersion);

            foreach (XmlNode node in powerStationXml.ChildNodes)
            {
                if (node.Name == "PowerSupplyStations")
                {
                    XmlNode stationNode = powerStationXml.CreateElement("SupplyStation");
                    XmlNode node0 = powerStationXml.CreateElement("Id");
                    node0.InnerText = id.ToString();
                    XmlNode node1 = powerStationXml.CreateElement("Longitude");
                    node1.InnerText = latitude.ToString().Replace(",", ".");
                    XmlNode node2 = powerStationXml.CreateElement("Latitude");
                    node2.InnerText = longitude.ToString().Replace(",", ".");
                    XmlNode node3 = powerStationXml.CreateElement("PowerSystem");
                    if (RouteVoltageV == 3000)
                        node3.InnerText = "0";
                    if (RouteVoltageV == 25000)
                        node3.InnerText = "1";
                    if (RouteVoltageV == 15000)
                        node3.InnerText = "2";

                    stationNode.AppendChild(node0);
                    stationNode.AppendChild(node1);
                    stationNode.AppendChild(node2);
                    stationNode.AppendChild(node3);
                    node.AppendChild(stationNode);
                }
            }
            powerStationXml.Save(Simulator.RoutePath + "\\PowerSupplyStations.xml");
            SetUpPowerSupplyStations();
            Simulator.Confirmer.Information(Simulator.Catalog.GetString("The power station is stored in an external database."));
        }

        XmlDocument voltageMarkersXml;
        int VoltageMarkersDbVersion = 0;
        bool VoltageMarkersDbVersionUpdated = false;
        public void SetVoltageMarkerPosition(int Voltage)
        {
            if (!Simulator.SuperUser)
                return;

            cz.aspone.lkpr.WebService ws = new cz.aspone.lkpr.WebService();

            if (!VoltageMarkersDbVersionUpdated)
            {
                string result = ws.GetPowerSuplyMarkerVersion(Simulator.TRK.Tr_RouteFile.FileName);
                int v = int.Parse(result);
                VoltageMarkersDbVersion = v + 1;
                ws.UpdatePowerSupplyMarkerVersion(VoltageMarkersDbVersion, Simulator.TRK.Tr_RouteFile.FileName);
                VoltageMarkersDbVersionUpdated = true;
            }
            FileInfo fi = new FileInfo(Simulator.TRK.Tr_RouteFile.FullFileName);
            File.WriteAllText(fi.DirectoryName + "\\VoltageChangeMarkersDbVersion.ini", VoltageMarkersDbVersion.ToString());

            double latitude = 0;
            double longitude = 0;
            new WorldLatLon().ConvertWTC(WorldPosition.TileX, WorldPosition.TileZ, WorldPosition.WorldLocation.Location, ref latitude, ref longitude);

            int id = ws.SavePowerSupplyMarker(-1, Simulator.TRK.Tr_RouteFile.FileName, longitude.ToString(), latitude.ToString(), Voltage, VoltageMarkersDbVersion);

            if (voltageMarkersXml == null)
            {
                voltageMarkersXml = new XmlDocument();
                voltageMarkersXml.Load(Simulator.RoutePath + "\\VoltageChangeMarkers.xml");
            }

            foreach (XmlNode node in voltageMarkersXml.ChildNodes)
            {
                if (node.Name == "VoltageChangeMarkers")
                {
                    XmlNode stationNode = voltageMarkersXml.CreateElement("Marker");
                    XmlNode node0 = voltageMarkersXml.CreateElement("Id");
                    node0.InnerText = id.ToString();
                    XmlNode node1 = voltageMarkersXml.CreateElement("Longitude");
                    node1.InnerText = latitude.ToString().Replace(",", ".");
                    XmlNode node2 = voltageMarkersXml.CreateElement("Latitude");
                    node2.InnerText = longitude.ToString().Replace(",", ".");
                    XmlNode node3 = voltageMarkersXml.CreateElement("Voltage");
                    node3.InnerText = Voltage.ToString();
                    stationNode.AppendChild(node0);
                    stationNode.AppendChild(node1);
                    stationNode.AppendChild(node2);
                    stationNode.AppendChild(node3);
                    node.AppendChild(stationNode);
                }
            }
            voltageMarkersXml.Save(Simulator.RoutePath + "\\VoltageChangeMarkers.xml");
            SetUpVoltageChangeMarkers();
            Simulator.Confirmer.Information(Simulator.Catalog.GetString("Set ") + Voltage.ToString() + Simulator.Catalog.GetString("V and stored in an external database."));
        }

        //put here because you can have diesel helpers and electric player locomotive
        public void ToggleHelpersEngine()
        {
            var onOffFound = false; //this avoids that locomotive engines toggle in opposite directions
            var powerOn = false;
            var helperLocos = 0;

            foreach (var car in Train.Cars)
            {
                var mstsDieselLocomotive = car as MSTSDieselLocomotive;
                if (mstsDieselLocomotive != null && mstsDieselLocomotive.AcceptMUSignals)
                {
                    if (mstsDieselLocomotive.DieselEngines.Count > 0)
                    {
                        if ((car == Simulator.PlayerLocomotive))
                        {
                            if ((mstsDieselLocomotive.DieselEngines.Count > 1))
                            {
                                for (int i = 1; i < mstsDieselLocomotive.DieselEngines.Count; i++)
                                {
                                    if (!onOffFound)
                                    {
                                        onOffFound = true;
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Stopped)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Start();
                                            powerOn = true;
                                        }
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Running)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Stop();
                                        }
                                    }
                                    else
                                    {
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Stopped && powerOn)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Start();
                                        }
                                        if (mstsDieselLocomotive.DieselEngines[i].EngineStatus == DieselEngine.Status.Running && !powerOn)
                                        {
                                            mstsDieselLocomotive.DieselEngines[i].Stop();
                                        }
                                    }
                                }
                                if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Stopping)
                                    mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOff);
                                else if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Starting)
                                    mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOn);
                            }
                        }
                        else
                        {
                            foreach (DieselEngine de in mstsDieselLocomotive.DieselEngines)
                            {
                                if (!onOffFound)
                                {
                                    if (de.EngineStatus == DieselEngine.Status.Stopped)
                                    {
                                        de.Start();
                                        powerOn = true;
                                    }
                                    if (de.EngineStatus == DieselEngine.Status.Running)
                                    {
                                        de.Stop();
                                    }
                                }
                                else
                                {

                                    if (de.EngineStatus == DieselEngine.Status.Stopped && powerOn)
                                    {
                                        de.Start();
                                    }
                                    if (de.EngineStatus == DieselEngine.Status.Running && !powerOn)
                                    {
                                        de.Stop();
                                    }
                                }
                            }
                        }
                    }
                    //mstsDieselLocomotive.StartStopDiesel();

                    if ((car != Simulator.PlayerLocomotive) && (mstsDieselLocomotive.AcceptMUSignals))
                    {
                        if (mstsDieselLocomotive.DieselEngines[0].EngineStatus == DieselEngine.Status.Stopping)
                            mstsDieselLocomotive.SignalEvent(Event.EnginePowerOff);
                        else if (mstsDieselLocomotive.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting)
                            mstsDieselLocomotive.SignalEvent(Event.EnginePowerOn);
                        if (mstsDieselLocomotive.DieselEngines.Count > 1)
                        {
                            if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Stopping)
                                mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOff);
                            else if (mstsDieselLocomotive.DieselEngines[1].EngineStatus == DieselEngine.Status.Starting)
                                mstsDieselLocomotive.SignalEvent(Event.SecondEnginePowerOn);
                        }
                    }
                    helperLocos++;
                }
            }
            // One confirmation however many helper locomotives
            // <CJComment> Couldn't make one confirmation per loco work correctly :-( </CJComment>
            if (helperLocos > 0)
            {
                Simulator.Confirmer.Confirm(CabControl.HelperDiesel, powerOn ? CabSetting.On : CabSetting.Off);
            }

        }

        public override void SignalEvent(Event evt)
        {
            switch (evt)
            {
                case Event.VigilanceAlarmOn: { AlerterSnd = true; if (Simulator.Settings.Alerter) Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.On); break; }
                case Event.VigilanceAlarmOff: { AlerterSnd = false; if (Simulator.Settings.Alerter) Simulator.Confirmer.Confirm(CabControl.Alerter, CabSetting.Off); break; }
                case Event.BellOn:
                case Event.BellOff:
                    if (this == Simulator.PlayerLocomotive && Simulator.Confirmer != null)
                        Simulator.Confirmer.Confirm(CabControl.Bell, Bell ? CabSetting.On : CabSetting.Off);
                    break;
                case Event.HornOn:
                case Event.HornOff:
                    if (this == Simulator.PlayerLocomotive && Simulator.Confirmer != null)
                        Simulator.Confirmer.Confirm(this is MSTSSteamLocomotive ? CabControl.Whistle : CabControl.Horn, Horn ? CabSetting.On : CabSetting.Off);
                    break;
                case Event.SanderOn: { Sander = true; if (this.IsLeadLocomotive() && this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.On); break; }
                case Event.SanderOff: { Sander = false; if (this.IsLeadLocomotive() && this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Sander, CabSetting.Off); break; }
                case Event.WiperOn: { if (this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.On); break; }
                case Event.WiperOff: { if (this == Simulator.PlayerLocomotive) Simulator.Confirmer.Confirm(CabControl.Wipers, CabSetting.Off); break; }

                // <CJComment> The "H" key doesn't call these SignalEvents yet. </CJComment>
                case Event._HeadlightOff: { Headlight[LocoStation] = 0; break; }
                case Event._HeadlightDim: { Headlight[LocoStation] = 1; break; }
                case Event._HeadlightOn: { Headlight[LocoStation] = 2; break; }

                case Event.CompressorOn: { CompressorIsOn = true; break; }
                case Event.CompressorOff: { CompressorIsOn = false; break; }

                //Vacuum exhauster event only triggered if vacuum exhauster engine control fitted.
                case Event.VacuumExhausterOn: { if (FastVacuumExhausterFitted) VacuumExhausterPressed = true; if (this.IsLeadLocomotive() && this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.VacuumExhauster, CabSetting.On); break; }
                case Event.VacuumExhausterOff: { if (FastVacuumExhausterFitted) VacuumExhausterPressed = false; if (this.IsLeadLocomotive() && this == Simulator.PlayerLocomotive && Simulator.Confirmer != null) Simulator.Confirmer.Confirm(CabControl.VacuumExhauster, CabSetting.Off); break; }

                case Event._ResetWheelSlip: { LocomotiveAxle.Reset(Simulator.GameTime, SpeedMpS); ThrottleController.SetValue(0.0f); break; }
                case Event.TrainBrakePressureDecrease:
                case Event.TrainBrakePressureIncrease:
                    {
                        if (Train.TrainType == Train.TRAINTYPE.AI || Train.TrainType == Train.TRAINTYPE.AI_PLAYERHOSTING)
                        {
                            if (Train.Simulator.GameTime - LastBrakeSoundTime < 15) // don't repeat sound too often for AI trains (which frequently set brakes on and off)
                            {
                                return;
                            }
                            LastBrakeSoundTime = Train.Simulator.GameTime;
                        }
                        break;
                    }

                // Icik
                case Event.Compressor2On: { Compressor2IsOn = true; break; }
                case Event.Compressor2Off: { Compressor2IsOn = false; break; }
                case Event.AuxCompressorOn: { AuxCompressorIsOn = true; break; }
                case Event.AuxCompressorOff: { AuxCompressorIsOn = false; break; }
            }

            base.SignalEvent(evt);
        }

        //used by remote train locomotives
        /*       public virtual void RemoteUpdate()
               {
               }*/

        public void WheelSpeedCabCorrection(CabViewControl cvc)
        {
            if (Math.Abs(WheelSpeedMpS_Cab) < Math.Abs(cvc.PreviousData / 3.6f) - (10.0f / 3.6f) || Math.Abs(WheelSpeedMpS_Cab) > Math.Abs(cvc.PreviousData / 3.6f) + (10.0f / 3.6f))
                cvc.PreviousData = Math.Abs(WheelSpeedMpS_Cab * 3.6f);
        }


        public float elapsedTime;
        private float previousSelectedSpeed = 0;
        private float previousMaxMirelSpeed = 0;
        private float previousTrainBrakeData = 0;
        private List<float> requestedForce = new List<float>();
        public bool PositiveMask = false;
        public bool NegativeMask = false;
        public virtual float GetDataOf(CabViewControl cvc)
        {                                    
            CheckBlankDisplay(cvc);
            float data = 0;
            switch (cvc.ControlType)
            {
                case CABViewControlTypes.SPEEDOMETER:
                    {
                        WheelSpeedCabCorrection(cvc);
                        cvc.ElapsedTime += elapsedTime;
                        float speed = WheelSpeedMpS_Cab;                        
                        if (cvc.ElapsedTime < cvc.UpdateTime)
                        {
                            if (cvc.Vibration > 0 && cvc.ElapsedTime > cvc.UpdateTime / 2 && Math.Abs(speed) > 0.1f)
                            {
                                if (Up)
                                    data = cvc.PreviousData - (cvc.Vibration / 3.6f);
                                if (Down)
                                    data = cvc.PreviousData + (cvc.Vibration / 3.6f);
                                break;
                            }
                            data = cvc.PreviousData;
                            break;
                        }
                        cvc.ElapsedTime = 0;
                        //data = SpeedMpS;
                        if (AdvancedAdhesionModel)
                            data = speed;
                        else
                            data = speed;

                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        if (cvc.UpdateTime != 0 && cvc.Precision >= 0)
                        {
                            if (cvc.Precision == 0)
                                data = (float)Math.Round(data, 0);
                            else
                            {
                                data = data / cvc.Precision;
                                data = (float)Math.Round(data, 0);
                                data = data * cvc.Precision;
                            }
                        }
                        if (cvc.Vibration > 0 && data > cvc.PreviousData)
                        {
                            Up = true;
                            Down = false;
                        }
                        if (cvc.Vibration > 0 && data < cvc.PreviousData)
                        {
                            Up = false;
                            Down = true;
                        }
                        cvc.PreviousData = data;
                        break;
                    }
                case CABViewControlTypes.SPEED_PROJECTED:
                    {
                        if (Train != null)
                            data = Train.ProjectedSpeedMpS;
                        else data = 0;
                        if (cvc.Units == CABViewControlUnits.KM_PER_HOUR)
                            data *= 3.6f;
                        else // MPH
                            data *= 2.2369f;
                        data = Math.Abs(data);
                        break;
                    }
                case CABViewControlTypes.ACCELEROMETER:
                    {
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.METRES_SEC_SEC:
                                data = this.AccelerationMpSS;
                                break;

                            case CABViewControlUnits.METRES_SEC_HOUR:
                                data = this.AccelerationMpSS * 3600.0f;
                                break;

                            case CABViewControlUnits.KM_HOUR_SEC:
                                data = this.AccelerationMpSS * 3.6f;
                                break;

                            case CABViewControlUnits.KM_HOUR_HOUR:
                                data = this.AccelerationMpSS * 3.6f * 3600.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_MIN:
                                data = this.AccelerationMpSS * 2.236936f * 60.0f;
                                break;

                            case CABViewControlUnits.MILES_HOUR_HOUR:
                                // 
                                data = this.AccelerationMpSS * 2.236936f * 3600.0f;
                                break;

                            default:
                                data = this.AccelerationMpSS;
                                break;

                        }
                        break;
                    }

                case CABViewControlTypes.ORTS_WATER_SCOOP:
                    data = WaterScoopDown ? 1 : 0;
                    break;

                case CABViewControlTypes.STEAM_HEAT:
                    data = SteamHeatController.CurrentValue;
                    break;

                case CABViewControlTypes.AMMETER: // Current not modelled yet to ammeter shows tractive effort until then.
                case CABViewControlTypes.AMMETER_ABS:
                    {
                        if (cvc.MaxNeedleSpeedUp == 0 && cvc.MaxNeedleSpeedDown == 0 && cvc.MaxNeedleSpeed == 0) cvc.MaxNeedleSpeed = 5.0f;
                        cvc.ElapsedTime += elapsedTime;
                        if (cvc.ElapsedTime > cvc.UpdateTime)
                        {
                            var direction = 0; // Forwards
                            if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                                direction = ((CVCGauge)cvc).Direction;
                            if (MaxCurrentA == 0)
                                MaxCurrentA = (float)cvc.MaxValue;
                            if (LocomotiveAxle != null)
                            {
                                data = 0.0f;
                                if (ThrottlePercent > 0)
                                {
                                    //float rangeFactor = direction == 0 ? (float)cvc.MaxValue : (float)cvc.MinValue;
                                    float rangeFactor = direction == 0 ? MaxCurrentA : (float)cvc.MinValue;
                                    if (DriveForceN != 0)
                                        data = this.DriveForceN / MaxForceN * rangeFactor;
                                    else
                                        data = this.LocomotiveAxle.AxleForceN / MaxForceN * rangeFactor;
                                    data = Math.Abs(data);
                                }
                                if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                                {
                                    float rangeFactor;
                                    if (cvc.ControlType == CABViewControlTypes.AMMETER_ABS)
                                    {
                                        if (DynamicBrakeMaxCurrentA == 0)
                                            rangeFactor = direction == 0 ? (float)cvc.MaxValue : (float)cvc.MinValue;
                                        else
                                            rangeFactor = direction == 0 ? DynamicBrakeMaxCurrentA : (float)cvc.MinValue;
                                    }
                                    else
                                    {
                                        if (DynamicBrakeMaxCurrentA == 0)
                                            rangeFactor = direction == 0 ? (float)cvc.MinValue : (float)cvc.MaxValue;
                                        else
                                            rangeFactor = direction == 0 ? -DynamicBrakeMaxCurrentA : (float)cvc.MaxValue;
                                    }
                                    data = DynamicBrakeForceN / MaxDynamicBrakeForceN * rangeFactor;
                                }
                                if (direction == 1)
                                    data = -data;

                                // Icik
                                if (CurrentForceStep1Curves != null || CurrentForceCurves != null)
                                    data = FakePowerCurrent1;
                                if (CurrentBrakeForce1Curves != null && DynamicBrakeForceN != 0)
                                    data = BrakeCurrent1;

                                if (cvc.ControlType == CABViewControlTypes.AMMETER_ABS) data = Math.Abs(data);
                                break;
                            }
                            data = this.DriveForceN / MaxForceN * MaxCurrentA;

                            // Icik
                            if (CurrentForceStep1Curves != null || CurrentForceCurves != null)
                                data = FakePowerCurrent1;
                            if (CurrentBrakeForce1Curves != null && DynamicBrakeForceN != 0)
                                data = BrakeCurrent1;

                            if (cvc.ControlType == CABViewControlTypes.AMMETER_ABS) data = Math.Abs(data);
                            cvc.ElapsedTime = 0;                            
                            PreDataAmmeter = data;
                            break; 
                        }
                        else
                            data = PreDataAmmeter;                                                
                        break;
                    }                    
                // Icik
                case CABViewControlTypes.AMMETER2:
                case CABViewControlTypes.AMMETER2_ABS:
                    {
                        if (cvc.MaxNeedleSpeedUp == 0 && cvc.MaxNeedleSpeedDown == 0 && cvc.MaxNeedleSpeed == 0) cvc.MaxNeedleSpeed = 5.0f;
                        cvc.ElapsedTime += elapsedTime;
                        if (cvc.ElapsedTime > cvc.UpdateTime)
                        {                            
                            if (CurrentForceStep2Curves != null)
                                data = FakePowerCurrent2;
                            if (CurrentBrakeForce2Curves != null && DynamicBrakeForceN != 0)
                                data = BrakeCurrent2;

                            if (cvc.ControlType == CABViewControlTypes.AMMETER2_ABS) data = Math.Abs(data);                                                                   
                            cvc.ElapsedTime = 0;
                            PreDataAmmeter2 = data;
                            break;
                        }
                        else
                            data = PreDataAmmeter2;
                        break;
                    }                    
                case CABViewControlTypes.LOAD_METER:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        if (MaxCurrentA == 0)
                            MaxCurrentA = (float)cvc.MaxValue;
                        if (DynamicBrakeMaxCurrentA == 0)
                            DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                        data = 0.0f;
                        if (ThrottlePercent > 0)
                        {
                            if (FilteredMotiveForceN != 0)
                                data = this.FilteredMotiveForceN / MaxForceN * MaxCurrentA;
                            else
                                data = this.LocomotiveAxle.AxleForceN / MaxForceN * MaxCurrentA;
                            data = Math.Abs(data);
                        }
                        if (DynamicBrakePercent > 0 && MaxDynamicBrakeForceN > 0)
                        {
                            data = DynamicBrakeForceN / MaxDynamicBrakeForceN * DynamicBrakeMaxCurrentA;
                            data = -Math.Abs(data); // Ensure that dynamic force is seen as a "-ve force", changes colour on the load meter
                        }
                        if (direction == 1)
                            data = -data;
                        break;
                    }
                case CABViewControlTypes.TRACTION_BRAKING:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        if (FilteredMotiveForceN != 0)
                            data = this.FilteredMotiveForceN;
                        else
                            data = this.LocomotiveAxle.AxleForceN;
                        if (DynamicBrakePercent > 0)
                        {
                            data = DynamicBrakeForceN;
                        }
                        data = Math.Abs(data);
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.AMPS:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.MaxValue;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                                if (ThrottlePercent > 0)
                                {
                                    data = (data / MaxForceN) * MaxCurrentA;
                                }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (DynamicBrakeForceN / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                data = Math.Abs(data);
                                break;

                            case CABViewControlUnits.NEWTONS:
                                break;

                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;

                            case CABViewControlUnits.KILO_LBS:
                                data = N.ToLbf(data) * 0.001f;
                                break;
                        }
                        if (direction == 1 && !(cvc is CVCGauge))
                            data = -data;
                        break;
                    }
                case CABViewControlTypes.ORTS_SIGNED_TRACTION_BRAKING:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        if (FilteredMotiveForceN != 0)
                            data = Math.Abs(this.FilteredMotiveForceN);
                        else
                            data = Math.Abs(this.LocomotiveAxle.AxleForceN);
                        if (DynamicBrakePercent > 0)
                        {
                            data = -Math.Abs(DynamicBrakeForceN);
                        }
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.AMPS:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.MaxValue;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                                if (ThrottlePercent > 0)
                                {
                                    data = (data / MaxForceN) * MaxCurrentA;
                                }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (data / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                break;

                            case CABViewControlUnits.NEWTONS:
                                break;

                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;

                            case CABViewControlUnits.KILO_LBS:
                                data = N.ToLbf(data) * 0.001f;
                                break;
                        }
                        //                       if (direction == 1 && !(cvc is CVCGauge))
                        //                           data = -data;
                        break;
                    }
                case CABViewControlTypes.REQUESTED_FORCE:
                    float maxForce = (extendedPhysics.TotalMaxForceN / MaxForceN) * 100;
                    if (CruiseControl != null)
                    {
                        if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                        {
                            maxForce = 0;
                            foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                            {
                                foreach (ExtendedAxle ea in uc.Axles)
                                {
                                    maxForce += ea.maxForceN;
                                }
                            }
                            maxForce = (maxForce / MaxForceN) * 100;
                        }
                        if (maxForce > CruiseControl.controllerVolts)
                            maxForce = CruiseControl.controllerVolts;
                    }
                    if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                    {
                        float diff = CruiseControl.SelectedSpeedMpS - AbsSpeedMpS;
                        if (diff > 1.5 && diff > 0)
                        {
                            float mForce = maxForce;
                            maxForce = ForceHandleValue;
                            if (mForce < ForceHandleValue)
                                maxForce = mForce;
                        }
                        if (diff < 0 || TractiveForceN < 0)
                        {
                            maxForce = 0;
                            foreach (Undercarriage ucc in extendedPhysics.Undercarriages)
                            {
                                foreach (ExtendedAxle eaa in ucc.Axles)
                                {
                                    maxForce += eaa.ForceN;
                                }
                            }
                            maxForce = (maxForce / MaxDynamicBrakeForceN) * 100;
                        }
                    }
                    if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                    {
                        requestedForce.Add(maxForce);
                        if (requestedForce.Count >= 50)
                        {
                            requestedForce.RemoveAt(0);
                        }
                        maxForce = requestedForce.Average();
                    }
                    if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Manual)
                    {
                        requestedForce.Clear();
                        maxForce = 0;
                        foreach (Undercarriage ucc in extendedPhysics.Undercarriages)
                        {
                            foreach (ExtendedAxle eaa in ucc.Axles)
                            {
                                maxForce += eaa.ForceN;
                            }
                        }
                        maxForce = (maxForce / MaxForceN) * 100;
                    }
                    data = cvc is Orts.Formats.Msts.CVCDigital ? ForceHandleValue : (maxForce < ForceHandleValue ? maxForce : ForceHandleValue);
                    if (BrakeSystem.EmerBrakeTriggerActive)
                        data = 0;
                    break;
                case CABViewControlTypes.REQUESTED_MOTOR_FORCE:
                    data = 0.0f;
                    foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                    {
                        foreach (ExtendedAxle ea in uc.Axles)
                        {
                            if (ea.Id == cvc.AxleId)
                            {
                                data = ea.ForceNFilteredMotor / extendedPhysics.NumAxles * 2;
                                if (data < 0 && cvc.CurrentSource == "")
                                    cvc.IsVisible = false;
                                if (data >= 0 && cvc.CurrentSource == "")
                                    cvc.IsVisible = true;
                                if (cvc.CurrentSource.ToLower() == "negative_force" && data < 0)
                                {
                                    data = -data;
                                    cvc.IsVisible = true;
                                }
                                else if (cvc.CurrentSource.ToLower() == "negative_force")
                                {
                                    data = 0;
                                    cvc.IsVisible = false;
                                }
                            }
                        }
                    }
                    if (data > 0 && BrakeSystem.EmerBrakeTriggerActive)
                        data = 0;
                    switch (cvc.Units)
                    {
                        case CABViewControlUnits.AMPS:
                            if (MaxCurrentA == 0)
                                MaxCurrentA = (float)cvc.MaxValue;
                            if (DynamicBrakeMaxCurrentA == 0)
                                DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                            if (ThrottlePercent > 0)
                            {
                                data = (data / MaxForceN) * MaxCurrentA;
                            }
                            if (DynamicBrakePercent > 0)
                            {
                                data = (data / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                            }
                            break;

                        case CABViewControlUnits.NEWTONS:
                            break;

                        case CABViewControlUnits.KILO_NEWTONS:
                            data = data / 1000.0f;
                            break;
                        case CABViewControlUnits.KILO_LBS:
                            data = N.ToLbf(data) * 0.001f;
                            break;
                    }
                    //                       if (direction == 1 && !(cvc is CVCGauge))
                    //                           data = -data;
                    break;
                case CABViewControlTypes.TOTAL_FORCE:
                    data = 0;
                    foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                    {
                        foreach (ExtendedAxle ea in uc.Axles)
                        {
                            data += ea.ForceNFiltered;
                        }
                    }
                    if (data < 0)
                        data = (data / MaxDynamicBrakeForceN) * 100;
                    else
                        data = (data / MaxForceN) * 100;
                    if (cvc.Feature == "HideOnPositiveForce")
                    {
                        if (data >= 0)
                            cvc.IsVisible = PositiveMask = false;
                        else
                            cvc.IsVisible = PositiveMask = true;
                    }
                    if (cvc.Feature == "HideOnNegativeForce")
                    {
                        if (data <= 0)
                            cvc.IsVisible = NegativeMask = false;
                        else
                            cvc.IsVisible = NegativeMask = true;
                    }
                    break;
                case CABViewControlTypes.MOTOR_FORCE:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                        {
                            foreach (ExtendedAxle ea in uc.Axles)
                            {
                                if (ea.Id == cvc.AxleId)
                                {
                                    data = ea.ForceNFiltered / extendedPhysics.NumAxles * 2;
                                    if (cvc.CurrentSource.ToLower() == "negative_force" && data < 0)
                                        data = -data;
                                    else if (cvc.CurrentSource.ToLower() == "negative_force")
                                        data = 0;
                                }
                            }
                            if (data > 0 && BrakeSystem.EmerBrakeTriggerActive)
                                data = 0;
                        }
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.AMPS:
                                if (MaxCurrentA == 0)
                                    MaxCurrentA = (float)cvc.MaxValue;
                                if (DynamicBrakeMaxCurrentA == 0)
                                    DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                                if (ThrottlePercent > 0)
                                {
                                    data = (data / MaxForceN) * MaxCurrentA;
                                }
                                if (DynamicBrakePercent > 0)
                                {
                                    data = (data / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                }
                                break;

                            case CABViewControlUnits.NEWTONS:
                                break;

                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;

                            case CABViewControlUnits.KILO_LBS:
                                data = N.ToLbf(data) * 0.001f;
                                break;
                        }
                        //                       if (direction == 1 && !(cvc is CVCGauge))
                        //                           data = -data;
                        break;
                    }                // this considers both the dynamic as well as the train braking
                case CABViewControlTypes.ORTS_SIGNED_TRACTION_TOTAL_BRAKING:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        if (Math.Abs(SpeedMpS) == 0.0f)
                            data = 0.0f;
                        else if (Math.Abs(FilteredMotiveForceN) - Math.Abs(BrakeForceN + DynamicBrakeForceN) > 0)
                            data = Math.Abs(this.FilteredMotiveForceN);
                        else if (Math.Abs(FilteredMotiveForceN) - Math.Abs(BrakeForceN + DynamicBrakeForceN) < 0)
                            data = -Math.Abs(BrakeForceN + DynamicBrakeForceN);
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.NEWTONS:
                                break;

                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;

                            case CABViewControlUnits.KILO_LBS:
                                data = N.ToLbf(data) * 0.001f;
                                break;
                        }
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE_FORCE:
                    {
                        var direction = 0; // Forwards
                        if (cvc is CVCGauge && ((CVCGauge)cvc).Orientation == 0)
                            direction = ((CVCGauge)cvc).Direction;
                        data = 0.0f;
                        data = DynamicBrakeForceN;
                        if (data > 0 && SpeedMpS > 0 || data < 0 && SpeedMpS < 0)
                        {
                            data = 0;
                            break;
                        }
                        data = Math.Abs(data);
                        switch (cvc.Units)
                        {
                            case CABViewControlUnits.AMPS:
                                cvc.ElapsedTime += elapsedTime;
                                if (cvc.ElapsedTime > cvc.UpdateTime)
                                {
                                    if (MaxCurrentA == 0)
                                        MaxCurrentA = (float)cvc.MaxValue;
                                    if (DynamicBrakeMaxCurrentA == 0)
                                        DynamicBrakeMaxCurrentA = (float)cvc.MinValue;
                                    if (ThrottlePercent > 0)
                                    {
                                        data = 0;
                                    }
                                    if (DynamicBrakePercent > 0)
                                    {
                                        data = (DynamicBrakeForceN / MaxDynamicBrakeForceN) * DynamicBrakeMaxCurrentA;
                                    }
                                    data = Math.Abs(data);
                                    cvc.ElapsedTime = 0;
                                    PreDataAmps = data;
                                }
                                else
                                    data = PreDataAmps;
                                break;

                            case CABViewControlUnits.NEWTONS:
                                break;

                            case CABViewControlUnits.KILO_NEWTONS:
                                data = data / 1000.0f;
                                break;

                            case CABViewControlUnits.KILO_LBS:
                                data = N.ToLbf(data) * 0.001f;
                                break;
                        }
                        if (direction == 1 && !(cvc is CVCGauge))
                            data = -data;
                        break;
                    }
                case CABViewControlTypes.MAIN_RES:
                    {
                        data = ConvertFromPSI(cvc, MainResPressurePSI);
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE:
                    {
                        data = ConvertFromPSI(cvc, this.BrakeSystem.BrakeLine1PressurePSI);
                        break;
                    }
                case CABViewControlTypes.EQ_RES:
                    {
                        data = ConvertFromPSI(cvc, this.Train.EqualReservoirPressurePSIorInHg);
                        break;
                    }
                case CABViewControlTypes.BRAKE_CYL:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetCylPressurePSI());
                        break;
                    }
                case CABViewControlTypes.VACUUM_RESERVOIR_PRESSURE:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.GetVacResPressurePSI());
                        break;
                    }
                case CABViewControlTypes.RPM:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].RealRPM;
                        break;
                    }
                case CABViewControlTypes.ORTS_DIESEL_TEMPERATURE:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].FakeDieselWaterTemperatureDeg;
                        break;
                    }
                case CABViewControlTypes.ORTS_OIL_PRESSURE:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = ConvertFromPSI(cvc, mstsDieselLocomotive.DieselEngines[0].DieselOilPressurePSI);
                        break;
                    }
                case CABViewControlTypes.THROTTLE:
                case CABViewControlTypes.THROTTLE_DISPLAY:
                case CABViewControlTypes.CPH_DISPLAY:
                    {
                        if (CruiseControl != null)
                            if (CruiseControl.SkipThrottleDisplay) break;
                        if (CruiseControl != null)
                        {
                            if (CruiseControl.UseThrottleAsSpeedSelector && (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV))
                            {
                                data = (MaxSpeedMpS + (CruiseControl.SelectedSpeedMpS - MaxSpeedMpS)) / MaxSpeedMpS;
                                break;
                            }
                        }
                        data = Train.TrainType == Train.TRAINTYPE.AI_PLAYERHOSTING ? ThrottlePercent / 100f : LocalThrottlePercent / 100f;
                        break;
                    }
                case CABViewControlTypes.ENGINE_BRAKE:
                    {
                        data = (EngineBrakeController == null) ? 0.0f : EngineBrakeValue[LocoStation];
                        break;
                    }
                case CABViewControlTypes.TRAIN_BRAKE:
                    {
                        if (CruiseControl != null)
                        {
                            if (CruiseControl.arrIsBraking)
                            {
                                //data = previousTrainBrakeData;
                                data = TrainBrakeValue[LocoStation];
                                break;
                            }
                        }
                        //data = previousTrainBrakeData = (TrainBrakeController == null) ? 0.0f : TrainBrakeController.CurrentValue;
                        data = previousTrainBrakeData = (TrainBrakeController == null) ? 0.0f : TrainBrakeValue[LocoStation];
                        break;
                    }
                case CABViewControlTypes.ORTS_BAILOFF:
                    {
                        data = BailOff ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_QUICKRELEASE:
                    {
                        data = (TrainBrakeController == null || !TrainBrakeController.QuickReleaseButtonPressed) ? 0 : 1;
                        break;
                    }
                case CABViewControlTypes.ORTS_OVERCHARGE:
                    {
                        data = (TrainBrakeController == null || !TrainBrakeController.OverchargeButtonPressed) ? 0 : 1;
                        break;
                    }
                case CABViewControlTypes.FRICTION_BRAKING:
                    {
                        data = (BrakeSystem == null) ? 0.0f : BrakeSystem.GetCylPressurePSI();
                        break;
                    }
                case CABViewControlTypes.DYNAMIC_BRAKE:
                    if (DynamicBrakeIntervention != -1)
                    {
                        data = 0;
                        break;
                    }
                    data = DynamicBrakePercent / 100f;
                    break;

                case CABViewControlTypes.DYNAMIC_BRAKE_DISPLAY:
                    //case CABViewControlTypes.CP_HANDLE:
                    {
                        data = DynamicBrakePercent / 100f;
                        break;  
                    }
                case CABViewControlTypes.REQUIRED_DECELERATION:
                    {
                        data = RequiredDecelerationPercentDisplay / 100f;
                        if (data < DynamicBrakePercent / 100f)
                            data = DynamicBrakePercent / 100f;
                        if (data > RequiredDecelerationPercent / 100f && RequiredDecelerationPercent != 0)
                            data = RequiredDecelerationPercent / 100;
   
                        break;
                    }
                case CABViewControlTypes.WIPERS:
                    {
                        if (LocoWiper[LocoStation])
                            data = 1;
                        else 
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.VACUUM_EXHAUSTER:
                    {
                        if (FastVacuumExhausterFitted)
                        {
                            data = VacuumExhausterPressed ? 1 : 0;
                        }
                        else
                        {
                            data = 0;
                        }
                        break;
                    }

                case CABViewControlTypes.HORN:
                    {
                        data = Horn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.BELL:
                    {
                        data = Bell ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.RESET:
                    {
                        if (TrainControlSystem.AlerterButtonPressed)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }

                case CABViewControlTypes.ALERTER_DISPLAY:
                    {
                        if (Simulator.Settings.Alerter)
                        {
                            if (TrainControlSystem.VigilanceEmergency)
                                data = 2;
                            else if (TrainControlSystem.VigilanceAlarm)
                                data = 1;
                            else
                                data = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.OVERSPEED:
                    {
                        data = TrainControlSystem.OverspeedWarning ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.PENALTY_APP:
                    {
                        data = TrainControlSystem.PenaltyApplication ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.EMERGENCY_BRAKE:
                    {
                        data = EmergencyButtonPressed ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.DOORS_DISPLAY:
                    {
                        data = DoorLeftOpen | DoorRightOpen ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.SANDERS:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                // MultStateDisplay entry in CVF file had Type SANDING. W/O the below entry and another entry at line 3625
                // the independant sanding light found in some cabs would not work.
                case CABViewControlTypes.SANDING:
                    {
                        data = Sander ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.CLOCK:
                    {
                        data = 0;
                        break;
                    }

                case CABViewControlTypes.FRONT_HLIGHT:
                    {
                        if (HeadLightPosition[LocoStation] == 0)
                            data = 0;
                        else
                            data = HeadLightPosition[LocoStation] - 1;
                        break;
                    }
                case CABViewControlTypes.WHEELSLIP:
                    {
                        if (AdvancedAdhesionModel && Train.TrainType != Train.TRAINTYPE.AI_PLAYERHOSTING)
                            data = LocomotiveAxle.IsWheelSlipWarning ? 1 : 0;
                        else
                            data = WheelSlip ? 1 : 0;
                        break;
                    }

                case CABViewControlTypes.DIRECTION:
                case CABViewControlTypes.DIRECTION_DISPLAY:
                    {
                        data = DirectionPosition[LocoStation] + 1;
                        break;
                    }
                case CABViewControlTypes.ASPECT_DISPLAY:
                    {
                        switch (TrainControlSystem.CabSignalAspect)
                        {
                            case TrackMonitorSignalAspect.Stop:
                                {
                                    data = 0;
                                    break;
                                }
                            case TrackMonitorSignalAspect.StopAndProceed:
                                {
                                    data = 1;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Restricted:
                                {
                                    data = 2;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_1:
                                {
                                    data = 3;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_2:
                                {
                                    data = 4;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Approach_3:
                                {
                                    data = 5;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear_1:
                                {
                                    data = 6;
                                    break;
                                }
                            case TrackMonitorSignalAspect.Clear_2:
                                {
                                    data = 7;
                                    break;
                                }
                            default:
                                {
                                    data = 7;
                                    break;
                                }
                        }
                        break;
                    }
                case CABViewControlTypes.SPEEDLIMIT:
                    {
                        // Displays current allowable speed
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        data = MpS.FromMpS(TrainControlSystem.CurrentSpeedLimitMpS, metric);
                        break;
                    }
                case CABViewControlTypes.SPEEDLIM_DISPLAY:
                    {
                        // Displays allowable speed shown on next signal
                        bool metric = cvc.Units == CABViewControlUnits.KM_PER_HOUR;
                        data = MpS.FromMpS(TrainControlSystem.NextSpeedLimitMpS, metric);
                        break;
                    }
                case CABViewControlTypes.GEARS_DISPLAY:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            if (dieselLoco.DieselEngines.HasGearBox)
                                data = dieselLoco.DieselEngines[0].GearBox.CurrentGearIndex + 1;
                        }
                        break;
                    }
                case CABViewControlTypes.CAB_RADIO:
                    {
                        data = CabRadioOn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = (dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Running ||
                                dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting) ? 1 : 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_HELPERS_DIESEL_ENGINES:
                    {
                        foreach (var car in Train.Cars)
                        {
                            var dieselLoco = car as MSTSDieselLocomotive;
                            if (dieselLoco != null && dieselLoco.AcceptMUSignals)
                            {
                                if (car == Simulator.PlayerLocomotive && dieselLoco.DieselEngines.Count > 1)
                                {
                                    data = (dieselLoco.DieselEngines[1].EngineStatus == DieselEngine.Status.Running ||
                                        dieselLoco.DieselEngines[1].EngineStatus == DieselEngine.Status.Starting) ? 1 : 0;
                                    break;
                                }
                                else if (car != Simulator.PlayerLocomotive)
                                {
                                    data = (dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Running ||
                                        dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting) ? 1 : 0;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE_STATE:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            data = (int)dieselLoco.DieselEngines[0].EngineStatus;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE_STARTER:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            //data = dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Starting ? 1 : 0;
                            data = StartButtonPressed ? 1 : 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_PLAYER_DIESEL_ENGINE_STOPPER:
                    {
                        data = 0;
                        if (this is MSTSDieselLocomotive)
                        {
                            var dieselLoco = this as MSTSDieselLocomotive;
                            //data = dieselLoco.DieselEngines[0].EngineStatus == DieselEngine.Status.Stopping ? 1 : 0;
                            data = StopButtonPressed ? 1 : 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_CABLIGHT:
                    data = CabLightOn[LocoStation] ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_LEFTDOOR:
                    data = GetCabFlipped() ? (DoorRightOpen ? 1 : 0) : DoorLeftOpen ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_RIGHTDOOR:
                    data = GetCabFlipped() ? (DoorLeftOpen ? 1 : 0) : DoorRightOpen ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_MIRRORS:
                    data = MirrorOpen ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_BATTERY:
                    data = Battery ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_POWERKEY:
                    {
                        CVCWithFrames cVCWithFrames = (CVCWithFrames)cvc;
                        switch (cVCWithFrames.FramesCount)
                        {
                            case 2:
                                {
                                    CarHavePocketPowerKey = false;
                                    switch (PowerKeyPosition[LocoStation])
                                    {
                                        case 0:
                                            data = 0;
                                            break;
                                        case 1:
                                            data = 0;
                                            break;
                                        case 2:
                                            data = 1;
                                            break;
                                    }
                                }
                                break;
                            case 3:
                                {
                                    CarHavePocketPowerKey = true;
                                    switch (PowerKeyPosition[LocoStation])
                                    {
                                        case 0:
                                            data = 0;
                                            break;
                                        case 1:
                                            data = 1;
                                            break;
                                        case 2:
                                            data = 2;
                                            break;
                                    }
                                }
                                break;
                        }                        
                        break;
                    }
                case CABViewControlTypes.ORTS_2DEXTERNALWIPERS:
                    if (LocoWiper[LocoStation])
                        data = Wiper ? 1 : 0;
                    break;
                case CABViewControlTypes.ORTS_HOURDIAL:
                    float hour = (float)(Simulator.ClockTime / 3600) % 12;
                    if (hour < 0)
                        hour += 12;
                    // Icik
                    int Hx = 6;
                    if (hour + Hx > 12)
                        Hx = -6;
                    data = hour + Hx;
                    break;
                case CABViewControlTypes.ORTS_MINUTEDIAL:
                    float minute = (float)(Simulator.ClockTime / 60) % 60;
                    if (minute < 0)
                        minute += 60;
                    // Icik
                    int Mx = 30;
                    if (minute + Mx > 60)
                        Mx = -30;
                    data = minute + Mx;
                    break;
                case CABViewControlTypes.ORTS_SECONDDIAL:
                    int seconds = (int)Simulator.ClockTime % 60;
                    if (seconds < 0)
                        seconds += 60;
                    data = seconds;
                    break;

                // Train Control System controls
                case CABViewControlTypes.ORTS_TCS1:
                case CABViewControlTypes.ORTS_TCS2:
                case CABViewControlTypes.ORTS_TCS3:
                case CABViewControlTypes.ORTS_TCS4:
                case CABViewControlTypes.ORTS_TCS5:
                case CABViewControlTypes.ORTS_TCS6:
                case CABViewControlTypes.ORTS_TCS7:
                case CABViewControlTypes.ORTS_TCS8:
                case CABViewControlTypes.ORTS_TCS9:
                case CABViewControlTypes.ORTS_TCS10:
                case CABViewControlTypes.ORTS_TCS11:
                case CABViewControlTypes.ORTS_TCS12:
                case CABViewControlTypes.ORTS_TCS13:
                case CABViewControlTypes.ORTS_TCS14:
                case CABViewControlTypes.ORTS_TCS15:
                case CABViewControlTypes.ORTS_TCS16:
                case CABViewControlTypes.ORTS_TCS17:
                case CABViewControlTypes.ORTS_TCS18:
                case CABViewControlTypes.ORTS_TCS19:
                case CABViewControlTypes.ORTS_TCS20:
                case CABViewControlTypes.ORTS_TCS21:
                case CABViewControlTypes.ORTS_TCS22:
                case CABViewControlTypes.ORTS_TCS23:
                case CABViewControlTypes.ORTS_TCS24:
                case CABViewControlTypes.ORTS_TCS25:
                case CABViewControlTypes.ORTS_TCS26:
                case CABViewControlTypes.ORTS_TCS27:
                case CABViewControlTypes.ORTS_TCS28:
                case CABViewControlTypes.ORTS_TCS29:
                case CABViewControlTypes.ORTS_TCS30:
                case CABViewControlTypes.ORTS_TCS31:
                case CABViewControlTypes.ORTS_TCS32:
                case CABViewControlTypes.ORTS_TCS33:
                case CABViewControlTypes.ORTS_TCS34:
                case CABViewControlTypes.ORTS_TCS35:
                case CABViewControlTypes.ORTS_TCS36:
                case CABViewControlTypes.ORTS_TCS37:
                case CABViewControlTypes.ORTS_TCS38:
                case CABViewControlTypes.ORTS_TCS39:
                case CABViewControlTypes.ORTS_TCS40:
                case CABViewControlTypes.ORTS_TCS41:
                case CABViewControlTypes.ORTS_TCS42:
                case CABViewControlTypes.ORTS_TCS43:
                case CABViewControlTypes.ORTS_TCS44:
                case CABViewControlTypes.ORTS_TCS45:
                case CABViewControlTypes.ORTS_TCS46:
                case CABViewControlTypes.ORTS_TCS47:
                case CABViewControlTypes.ORTS_TCS48:
                    data = TrainControlSystem.CabDisplayControls[(int)cvc.ControlType - (int)CABViewControlTypes.ORTS_TCS1];
                    break;

                // Jindřich
                case CABViewControlTypes.ORTS_MULTI_POSITION_CONTROLLER:
                    if (MultiPositionControllers != null && data == 0)
                    {
                        foreach (MultiPositionController mpc in MultiPositionControllers)
                        {
                            if (mpc.ControllerId == cvc.ControlId)
                            {
                                data = mpc.GetDataOf(cvc);
                            }
                        }
                    }
                    break;
                case CABViewControlTypes.ORTS_AMPERS_BY_CONTROLLER_VOLTAGE:
                    if (extendedPhysics != null)
                    {
                        if (cvc.UpdateTime > cvc.ElapsedTime)
                        {
                            data = cvc.PreviousData;
                            cvc.ElapsedTime += elapsedTime;
                            break;
                        }
                        if (string.IsNullOrEmpty(cvc.CurrentSource))
                        {
                            data = extendedPhysics.TotalCurrent;
                            if (data < 0)
                                data = -data;
                            break;
                        }
                        else if (cvc.CurrentSource.ToLower() == "total")
                        {
                            if (string.IsNullOrEmpty(cvc.CurrentType))
                            {
                                data = extendedPhysics.TotalCurrent;
                                if (data < 0)
                                    data = -data;
                                break;
                            }
                            else if (cvc.CurrentType.ToLower() == "rotor")
                            {
                                data = extendedPhysics.RotorsCurrent;
                                if (data < 0)
                                    data = -data;
                                break;
                            }
                            else if (cvc.CurrentType.ToLower() == "stator")
                            {
                                data = extendedPhysics.StarorsCurrent;
                                if (data < 0)
                                    data = -data;
                                cvc.PreviousData = data;
                                cvc.ElapsedTime = 0;
                                break;
                            }
                        }
                        else if (cvc.CurrentSource.ToLower() == "undercarriage")
                        {
                            if (extendedPhysics.Undercarriages.Count == 0 || cvc.CurrentSourceID == -1)
                            {
                                data = extendedPhysics.TotalCurrent;
                                if (data < 0)
                                    data = -data;
                                break;
                            }
                            else
                            {
                                foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                                {
                                    if (uc.Id == cvc.CurrentSourceID)
                                    {
                                        if (string.IsNullOrEmpty(cvc.CurrentType))
                                        {
                                            data = uc.StatorsCurrent + uc.RotorsCurrent;
                                            if (data < 0)
                                                data = -data;
                                            break;
                                        }
                                        else if (cvc.CurrentType.ToLower() == "stator")
                                        {
                                            data = uc.StatorsCurrent;
                                            if (data < 0)
                                                data = -data;
                                            break;
                                        }
                                        else if (cvc.CurrentType.ToLower() == "rotor")
                                        {
                                            data = uc.RotorsCurrent;
                                            if (data < 0)
                                                data = -data;
                                            if (cvc.UpdateTime > 0)
                                                cvc.PreviousData = data;
                                            cvc.ElapsedTime = 0;
                                            break;
                                        }
                                    }
                                }
                            }
                            //cvc.ElapsedTime = 0;
                            //cvc.PreviousData = data;
                            break;
                        }
                        else if (cvc.CurrentSource.ToLower() == "motor")
                        {
                            foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                            {
                                foreach (ExtendedAxle ea in uc.Axles)
                                {
                                    foreach (ElectricMotor em in ea.ElectricMotors)
                                    {
                                        if (em.Id == cvc.CurrentSourceID)
                                        {
                                            if (string.IsNullOrEmpty(cvc.CurrentType))
                                            {
                                                data = em.RotorCurrent + em.StatorCurrent;
                                                if (data < 0)
                                                    data = -data;
                                                break;
                                            }
                                            else if (cvc.CurrentType.ToLower() == "stator")
                                            {
                                                data = em.StatorCurrent;
                                                if (data < 0)
                                                    data = -data;
                                                break;
                                            }
                                            else if (cvc.CurrentType.ToLower() == "rotor")
                                            {
                                                data = em.RotorCurrent;
                                                if (data < 0)
                                                    data = -data;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    }
                    cvc.PreviousData = data;
                    cvc.ElapsedTime = 0;
                    if (CruiseControl != null)
                    {
                        if (CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.Auto || CruiseControl.SpeedRegMode[LocoStation] == CruiseControl.SpeedRegulatorMode.AVV)
                        {
                            if (CruiseControl.controllerVolts < 0) data = -CruiseControl.controllerVolts / 100 * (MaxCurrentA * 0.8f);
                            else data = CruiseControl.controllerVolts / 100 * (MaxCurrentA * 0.8f);
                            if (data == 0 && DynamicBrakePercent > 0 && AbsSpeedMpS > 0) data = DynamicBrakePercent / 100 * (MaxCurrentA * 0.8f);
                        }
                        else
                        {
                            if (DynamicBrakePercent > 0 && AbsSpeedMpS > 0) data = DynamicBrakePercent / 200 * (MaxCurrentA * 0.8f);
                            else data = ThrottlePercent / 100 * (MaxCurrentA * 1.2f);
                        }
                    }
                    else
                    {
                        if (DynamicBrakePercent > 0 && AbsSpeedMpS > 0) data = DynamicBrakePercent / 200 * (MaxCurrentA * 0.8f);
                        else data = ThrottlePercent / 100 * (MaxCurrentA * 1.2f);
                    }
                    break;

                case CABViewControlTypes.ORTS_TRAIN_TYPE_PAX_OR_CARGO:
                    {
                        data = (int)SelectedTrainType[LocoStation];
                        break;
                    }
                case CABViewControlTypes.ORTS_DISPLAY_SPLASH_SCREEN:
                    {
                        data = SplashScreen ? 0 : 1;
                        break;
                    }
                case CABViewControlTypes.ORTS_CONTROLLER_VOLTAGE:
                    {
                        data = CruiseControl.controllerVolts;
                        break;
                    }

                case CABViewControlTypes.ORTS_SELECTED_SPEED:
                case CABViewControlTypes.ORTS_SELECTED_SPEED_DISPLAY:
                    {
                        if (CruiseControl == null)
                            break;
                        bool jumpOut = false;
                        if (cvc.DisplayID > -1)
                            cvc.BlankDisplay = true;
                        if (StringArray.StArray != null)
                        {
                            foreach (StrArray strArray in StringArray.StArray)
                            {
                                foreach (KeyValuePair<string, int> pair in strArray.Strings)
                                {
                                    int s = strArray.Strings.ElementAt(strArray.SelectedString).Value;
                                    if (s == cvc.DisplayID && s > -1)
                                    {
                                        if (cvc.DisplayID == pair.Value)
                                        {
                                            jumpOut = true;
                                            cvc.BlankDisplay = false;
                                            break;
                                        }
                                    }
                                }
                                if (jumpOut) break;
                            }
                        }
                        float temp = CruiseControl.RestrictedSpeedActive ? MpS.ToKpH(CruiseControl.CurrentSelectedSpeedMpS) : temp = MpS.ToKpH(CruiseControl.SelectedSpeedMpS);
                        if (LocoType == LocoTypes.Vectron)
                        {
                            TimeSpan ts = DateTime.Now - SelectedSpeedChangedAt;
                            if (ts.TotalSeconds < 5)
                                temp = MpS.ToKpH(CruiseControl.NextSelectedSpeedMps);
                            else
                                temp = MpS.ToKpH(CruiseControl.SelectedSpeedMpS);
                        }
                        if (cvc.ControlStyle == CABViewControlStyles.NEEDLE)
                        {
                            if (previousSelectedSpeed < temp) previousSelectedSpeed += 1f;
                            if (previousSelectedSpeed > temp) previousSelectedSpeed -= 1f;
                            data = previousSelectedSpeed;
                        }
                        else
                            data = temp;

                        if (cvc.Precision > 0)
                        {
                            data = data / cvc.Precision;
                            data = (float)Math.Round(data, 0);
                            data = data * cvc.Precision;
                        }

                        break;
                    }

                case CABViewControlTypes.ORTS_MIREL_SPEED:
                    {
                        float val = (float)Math.Round(Mirel.MirelMaximumSpeed, 0);
                        val = val - (float)cvc.MinValue;
                        CVCWithFrames cVCWithFrames = (CVCWithFrames)cvc;
                        int frames = cVCWithFrames.FramesCount - 1;
                        double howMany = (cvc.MaxValue - cvc.MinValue) / frames;

                        data = val / (float)howMany;
                        if (Mirel.MaxSpeedSetup && !Mirel.SpeedSetupConfirmed)
                        {
                            data = previousMaxMirelSpeed;
                        }
                        else
                        {
                            previousMaxMirelSpeed = data;
                        }
                        break;
                    }

                case CABViewControlTypes.ORTS_DISPLAY_BLUE_LIGHT:
                    {
                        data = (float)(Mirel.BlueLight ? 0 : 1);
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DRIVE_MODE:
                    {
                        if (Mirel.DriveModeHideModes)
                            data = 0;
                        else
                            data = (float)Mirel.mainMode;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DRIVE_MODE_OPTIONS:
                    {
                        data = (float)Mirel.driveMode;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_FLASH_MASK:
                    {
                        data = Mirel.DisplayFlashMask ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_FULL_DISPLAY:
                    {
                        data = Mirel.FullDisplay ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_NUM_1:
                    {
                        data = Mirel.MirelSpeedNum1;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_NUM_2:
                    {
                        data = Mirel.MirelSpeedNum2;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_NUM_3:
                    {
                        data = Mirel.MirelSpeedNum3;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_D1:
                    {
                        data = Mirel.initTest == Mirel.InitTest.Running ? 0 : 1;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST1:
                    {
                        data = Mirel.Test1 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST2:
                    {
                        data = Mirel.Test2 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST3:
                    {
                        data = Mirel.Test3 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST4:
                    {
                        data = Mirel.Test4 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST5:
                    {
                        data = Mirel.Test5 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST6:
                    {
                        data = Mirel.Test6 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_DISPLAY_TEST7:
                    {
                        data = Mirel.Test7 ? 1 : 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed)
                            data = 0;
                        break;
                    }

                case CABViewControlTypes.ORTS_ACTIVE_CAB:
                    {
                        if (!UsingRearCab && CurrentKeyPosition == KeyPosition.Station1)
                        {
                            data = (int)ActiveStation + 1;
                        }
                        else if (UsingRearCab && CurrentKeyPosition == KeyPosition.Station2)
                        {
                            data = (int)ActiveStation + 1;
                        }
                        else
                        {
                            data = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_NZOK:
                    {
                        data = Mirel.NZOK ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_NZ1:
                    {
                        data = Mirel.NZ1 ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_NZ2:
                    {
                        data = Mirel.NZ2 ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_NZ3:
                    {
                        data = Mirel.NZ3 ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_NZ4:
                    {
                        data = Mirel.NZ4 ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_NZ5:
                    {
                        data = Mirel.NZ5 ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_MAN:
                    {
                        data = Mirel.ManualModeDisplay ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_ZAP:
                    {
                        data = Mirel.ZAP ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_VYP:
                    {
                        data = Mirel.VYP ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_TOP_LEFT_DOT:
                    {
                        data = Mirel.ReducedSpeed ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_TRANS_FRQ:
                    {
                        if (Mirel.transmittionSignalFreq == Mirel.TransmittionSignalFreq.None) data = 0;
                        if (Mirel.transmittionSignalFreq == Mirel.TransmittionSignalFreq.Freq50Hz) data = 1;
                        if (Mirel.transmittionSignalFreq == Mirel.TransmittionSignalFreq.Freq75Hz) data = 2;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_M:
                    {
                        data = Mirel.ManualMode ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_MIREL_START_REDUCE_SPEED:
                    {
                        data = Mirel.StartReducingSpeed ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.ORTS_REPEATER_LIGHTS_MASK:
                    {
                        // data 1 = hide mask and display aspect
                        data = 1;
                        if ((Mirel.selectedDriveMode == Mirel.DriveMode.Normal || Mirel.selectedDriveMode == Mirel.DriveMode.Trailing) && !Mirel.flashFullDisplayInProggress && Mirel.RecievingRepeaterSignal)
                            data = 1;
                        else
                            data = 0;
                        if (Mirel.MirelType != Mirel.Type.Full && (Mirel.Ls90power[LocoStation] == Mirel.LS90power.Off || Mirel.Ls90power[LocoStation] == Mirel.LS90power.Start))
                            data = 0;
                        if (!Mirel.RecievingRepeaterSignal)
                            data = 0;

                        break;
                    }
                case CABViewControlTypes.ORTS_STATION:
                    {
                        data = 0;
                        if (Mirel.initTest == Mirel.InitTest.Passed && ActiveStation == DriverStation.None)
                            data = 1;
                        if (Mirel.initTest == Mirel.InitTest.Passed && ActiveStation == DriverStation.Station2 && !UsingRearCab)
                            data = 3;
                        if (Mirel.initTest == Mirel.InitTest.Passed && ActiveStation == DriverStation.Station1 && UsingRearCab)
                            data = 2;
                        break;
                    }

                case CABViewControlTypes.ORTS_LS90_POWER:
                    {
                        data = (float)Mirel.Ls90power[LocoStation];
                        break;
                    }
                case CABViewControlTypes.ORTS_LS90_LED:
                    {
                        data = (float)Mirel.Ls90led;
                        break;
                    }
                case CABViewControlTypes.ORTS_AVV_SIGNAL:
                    {
                        data = (float)CruiseControl.avvSignal;
                        if (!String.IsNullOrEmpty(cvc.Label))
                        {
                            if (cvc.Label == "Milepost" && AVVActiveLine == 0)
                            {
                                data = 1;
                                break;
                            }
                            else
                            {
                                data = 0;
                            }
                            if (cvc.Label == "Signal" && AVVActiveLine == 1)
                            {
                                data = 1;
                                break;
                            }
                            else
                            {
                                data = 0;
                            }
                            if (cvc.Label == "Station" && AVVActiveLine == 2)
                            {
                                data = 1;
                            }
                            else
                            {
                                data = 0;
                            }
                        }
                        break;
                    }
                case CABViewControlTypes.SELECTING_SYSTEM:
                    {
                        data = (float)SelectingPowerSystem;
                        break;
                    }
                case CABViewControlTypes.SELECTED_SYSTEM:
                    {
                        data = (float)SelectedPowerSystem;
                        break;
                    }
                case CABViewControlTypes.SYSTEM_ANNUNCIATOR:
                    {
                        data = SystemAnnunciator;
                        break;
                    }
                case CABViewControlTypes.PANTO_MODE:
                    {
                        switch (PantoMode)
                        {
                            case PantoModes.Auto:
                                data = 0;
                                break;
                            case PantoModes.Forward:
                                data = 1;
                                break;
                            case PantoModes.Aft:
                                data = 2;
                                break;
                            case PantoModes.Both:
                                data = 3;
                                break;
                        }
                        break;
                    }
                default:
                    if (CruiseControl != null)
                        data = CruiseControl.GetDataOf(cvc);
                    else
                        data = 0;
                    break;

                // Icik                                                
                case CABViewControlTypes.COMPRESSOR_START:
                    {
                        data = 1;
                        cvc.ElapsedTime += elapsedTime;
                        if (CompressorIsOn && cvc.ElapsedTime < cvc.UpdateTime)
                        {
                            data = 0;
                            CompressorBeep++;
                            if (CompressorBeep == 1)
                                SignalEvent(Event.CompressorBeep);
                        }
                        if (!CompressorIsOn)
                        {
                            cvc.ElapsedTime = 0;
                            CompressorBeep = 0;
                        }
                        cvc.ElapsedTime2 += elapsedTime;
                        if (Compressor2IsOn && cvc.ElapsedTime2 < cvc.UpdateTime)
                        {
                            data = 0;
                            Compressor2Beep++;
                            if (Compressor2Beep == 1)
                                SignalEvent(Event.CompressorBeep);
                        }
                        if (!Compressor2IsOn)
                        {
                            cvc.ElapsedTime2 = 0;
                            Compressor2Beep = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.COMPRESSOR_COMBINED:
                    {
                        CompressorCombined = true;
                        AuxCompressor = true;
                        Compressor_I = true;
                        data = CompressorSwitch[LocoStation];
                        break;
                    }
                case CABViewControlTypes.COMPRESSOR_COMBINED2:
                    {
                        CompressorCombined2 = true;
                        Compressor_II = true;
                        data = CompressorSwitch2[LocoStation];
                        break;
                    }
                case CABViewControlTypes.COMPRESSOR_OFFAUTOON:
                    {
                        CompressorOffAutoOn = true;
                        //AuxCompressor = true;
                        Compressor_I = true;
                        data = CompressorSwitch[LocoStation];
                        break;
                    }
                case CABViewControlTypes.COMPRESSOR_OFFAUTOON2:
                    {
                        CompressorOffAutoOn2 = true;
                        Compressor_II = true;
                        data = CompressorSwitch2[LocoStation];
                        break;
                    }
                case CABViewControlTypes.AUXCOMPRESSOR_MODE_OFFON:
                    {
                        AuxCompressor = true;
                        AuxCompressorNoActiveStation = true;
                        data = AuxCompressorMode_OffOn ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.COMPRESSOR_MODE_OFFAUTO:
                    {
                        Compressor_I = true;
                        data = CompressorMode_OffAuto[LocoStation] ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.COMPRESSOR_MODE2_OFFAUTO:
                    {
                        Compressor_II = true;
                        data = CompressorMode2_OffAuto[LocoStation] ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HEATING_OFFON:
                    {
                        HeatingEnable = true;
                        data = Heating_OffOn[LocoStation] ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.HEATING_POWER:
                    {
                        if (HeatingIsOn)
                            data = 1;
                        else data = 0;
                        break;
                    }
                case CABViewControlTypes.WARNING_NEUTRAL:
                    {
                        data = 1;
                        if (PowerOn && Direction == Direction.N)
                        {
                            data = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.QUICK_RELEASE_BUTTON:
                    {
                        QuickReleaseButtonEnable = true;
                        if (QuickReleaseButton)
                            data = 1;
                        else data = 0;                        
                        break;
                    }
                case CABViewControlTypes.LOWPRESSURE_RELEASE_BUTTON:
                    {
                        LowPressureReleaseButtonEnable = true;
                        if (LowPressureReleaseButton)
                            data = 1;
                        else data = 0;                        
                        break;
                    }
                case CABViewControlTypes.BRAKE_PIPE_FLOW:
                    {
                        if (BrakeSystem.BrakePipeFlow)
                        {
                            data = 1;
                            SignalEvent(Event.BrakePipeFlow);
                        }
                        else data = 0;
                        break;
                    }
                case CABViewControlTypes.BREAK_POWER_BUTTON:
                    {
                        BreakPowerButtonEnable = true;
                        if (BreakPowerButton)
                            data = 1;
                        else data = 0;
                        break;
                    }
                case CABViewControlTypes.AUXCONSUMPTION_CURRENT:
                    {
                        if (cvc.MaxNeedleSpeedUp == 0 && cvc.MaxNeedleSpeedDown == 0 && cvc.MaxNeedleSpeed == 0) cvc.MaxNeedleSpeed = 5.0f;
                        data = I_AuxConsumption;
                        break;
                    }
                case CABViewControlTypes.HEATING_CURRENT:
                    {
                        if (cvc.MaxNeedleSpeedUp == 0 && cvc.MaxNeedleSpeedDown == 0 && cvc.MaxNeedleSpeed == 0) cvc.MaxNeedleSpeed = 5.0f;
                        data = I_Heating;
                        break;
                    }
                case CABViewControlTypes.HEATING_OVERCURRENT:
                    {
                        if (HeatingOverCurrent)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.CHECK_POWERLOSS:
                    {
                        if (CheckPowerLoss && Battery && PowerKey)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.DONT_RAISE_PANTO:
                    {
                        if (DontRaisePanto && Battery && PowerKey)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.DIESEL_DIRECTION_CONTROLLER:
                    {
                        DieselDirectionController = true;
                        CarHavePocketPowerKey = true;
                        if (DieselDirectionController_In && StationIsActivated[LocoStation])                              
                            data = DieselDirectionControllerPosition[LocoStation];
                        else
                            data = 5;
                        break;
                    }
                case CABViewControlTypes.DIESEL_DIRECTION_CONTROLLER2:
                    {
                        DieselDirectionController2 = true;
                        CarHavePocketPowerKey = true;
                        if (DieselDirectionController_In && StationIsActivated[LocoStation])
                            data = DieselDirectionController2Position[LocoStation];
                        else
                            data = 4;
                        break;
                    }
                case CABViewControlTypes.DIESEL_DIRECTION_CONTROLLER3:
                    {
                        DieselDirectionController3 = true;
                        data = DieselDirectionControllerPosition[LocoStation];
                        break;
                    }
                case CABViewControlTypes.DIESEL_DIRECTION_CONTROLLER4:
                    {
                        DieselDirectionController4 = true;
                        data = DieselDirectionController2Position[LocoStation];
                        break;
                    }
                case CABViewControlTypes.DIESEL_CHECK_POWER_MOTOR_LAMP:
                    {
                        if (DieselCheckPowerMotorLamp)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.DIESEL_MOTOR_WATER_TEMP:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].FakeDieselWaterTemperatureDeg;
                        break;
                    }
                case CABViewControlTypes.DIESEL_MOTOR_OIL_TEMP:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].FakeDieselOilTemperatureDeg;
                        break;
                    }
                case CABViewControlTypes.DIESEL_MOTOR_TEMP_WARNING:
                    {
                        if (DieselMotorTempWarning)
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.RDST_BREAKER_RDST:
                    {
                        RDSTBreakerRDSTEnable = true;
                        if (RDSTBreaker[LocoStation])
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.RDST_BREAKER_VZ:
                    {
                        RDSTBreakerVZEnable = true;
                        if (RDSTBreaker[LocoStation])
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.RDST_BREAKER_POWER:
                    {
                        RDSTBreakerPowerEnable = true;
                        if (RDSTBreaker[LocoStation])
                            data = 1;
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.DOORSWITCH:
                    {
                        DoorSwitchEnable = true;
                        data = DoorSwitch[LocoStation];
                        break;
                    }
                case CABViewControlTypes.LAP_BUTTON:
                    {
                        LapButtonEnable = true;
                        if (LapActive[LocoStation])
                            data = 1;
                        else data = 0;
                        if (!Battery) data = 0;
                        break;
                    }
                case CABViewControlTypes.BREAK_EDB_BUTTON:
                    {
                        BreakEDBButtonEnable = true;
                        BreakEDBSwitchEnable = false;
                        if (BreakEDBButton)
                            data = 1;
                        else data = 0;
                        if (!Battery) data = 0;
                        break;
                    }
                case CABViewControlTypes.BREAK_EDB_SWITCH:
                    {
                        BreakEDBButtonEnable = true;
                        BreakEDBSwitchEnable = true;
                        if (BreakEDBButton_Activated)
                            data = 1;
                        else data = 0;
                        break;
                    }
                case CABViewControlTypes.BREAK_EDB_DISPLAY:
                    {                        
                        if (BreakEDBButton_Activated)
                            data = 1;
                        else data = 0;
                        break;
                    }
                case CABViewControlTypes.DIRECTION_BUTTON:
                    {
                        DirectionButton = true;                        
                        switch (DirectionButtonPosition)
                        {
                            case 0:
                                data = 4 + DirectionButtonPositionOffset;
                                break;
                            case 1:
                                data = 5 + DirectionButtonPositionOffset;
                                break;
                            case 2:
                                data = 2 + DirectionButtonPositionOffset;
                                break;
                            case 3:
                                data = 3 + DirectionButtonPositionOffset;
                                break;
                            case 4:
                                data = 1 + DirectionButtonPositionOffset;
                                break;
                            case 5:
                                data = 0 + DirectionButtonPositionOffset;
                                break;
                        }
                        if (!Battery) data = 10;
                        break;
                    }
                case CABViewControlTypes.TURBO_PRESSURE:
                    {
                        var mstsDieselLocomotive = this as MSTSDieselLocomotive;
                        if (mstsDieselLocomotive.DieselEngines[0] != null)
                            data = mstsDieselLocomotive.DieselEngines[0].TurboPressureBar;
                        break;
                    }
                case CABViewControlTypes.BRAKEFORCE_CONVERTER:
                    {
                        data = ConvertFromPSI(cvc, BrakeSystem.PressureConverter);                       
                        break;
                    }
                case CABViewControlTypes.ARIPOT_CONTROLLER:
                    {
                        CVCWithFrames cVCWithFrames = (CVCWithFrames)cvc;
                        data = AripotControllerValue[LocoStation] * cVCWithFrames.FramesCount;
                        break;
                    }
                case CABViewControlTypes.FRONT_LIGHT_L:
                    {
                        if (!UsingRearCab)
                            data = LightFrontLPosition + 1;
                        else
                            data = LightRearRPosition + 1;
                        break;
                    }
                case CABViewControlTypes.FRONT_LIGHT_R:
                    {
                        if (!UsingRearCab)
                            data = LightFrontRPosition + 1;
                        else
                            data = LightRearLPosition + 1;
                        break;
                    }
                case CABViewControlTypes.REAR_LIGHT_L:
                    {
                        if (!UsingRearCab)
                            data = LightRearLPosition + 1;
                        else
                            data = LightFrontRPosition + 1;
                        break;
                    }
                case CABViewControlTypes.REAR_LIGHT_R:
                    {
                        if (!UsingRearCab)
                            data = LightRearRPosition + 1;
                        else
                            data = LightFrontLPosition + 1;
                        break;
                    }
                case CABViewControlTypes.RAIN_WINDOW:
                    {
                        CVCWithFrames cVCWithFrames = (CVCWithFrames)cvc;
                        RainWindowMaxPosition = cVCWithFrames.FramesCount;                       
                        data = RainWindowPosition;
                        break;
                    }
                case CABViewControlTypes.WIPERS_WINDOW:
                    {
                        CVCWithFrames cVCWithFrames = (CVCWithFrames)cvc;
                        WipersWindowMaxPosition = cVCWithFrames.FramesCount;
                        data = WipersWindowPosition;
                        break;
                    }
                case CABViewControlTypes.SEASON_SWITCH:
                    {
                        data = SeasonSwitchPosition[LocoStation] ? 1:0;
                        break;
                    }
                case CABViewControlTypes.MIRER_CONTROLLER:
                    {                        
                        MirerControllerEnable = true;                        
                        switch (MirerControllerPosition)
                        {
                            case -2:
                                data = 4;
                                break;
                            case -1: 
                                data = 3;
                                break;
                            case 0:
                                data = 2;
                                break;
                            case 1:
                                data = 1;
                                break;
                            case 2:
                                data = 0;
                                break;
                        }
                        break;
                    }                
                case CABViewControlTypes.MIRER_DISPLAY:
                    {
                        cvc.ElapsedTime += elapsedTime;
                        data = cvc.PreviousData;
                        if (cvc.ElapsedTime > cvc.UpdateTime)
                        {
                            cvc.PreviousData = MirerControllerValue + 1;                            
                            MirerControllerValue1 = (int)cvc.PreviousData;
                            cvc.ElapsedTime = 0;                            
                        }                                                
                        break;
                    }
                case CABViewControlTypes.MIRER_DISPLAY2:
                    {
                        //cvc.UpdateTime = 3f;
                        cvc.ElapsedTime += elapsedTime;
                        data = cvc.PreviousData;
                        if (cvc.ElapsedTime > cvc.UpdateTime)
                        {
                            cvc.PreviousData = MirerControllerValue + 1;                            
                            MirerControllerValue2 = (int)cvc.PreviousData;
                            cvc.ElapsedTime = 0;                            
                        }                                                
                        break;
                    }
                case CABViewControlTypes.LTS410_DISPLAY:
                    {                        
                        data = LTS410Active;                        
                        break;
                    }
                case CABViewControlTypes.LTS510_DISPLAY:
                    {
                        data = LTS510Active;
                        break;
                    }
                case CABViewControlTypes.MIRELRS_CONTROLLER:
                    {
                        MirelRSControllerEnable = true;
                        data = MirelRSControllerPosition[LocoStation];                                                                        
                        break;
                    }
                case CABViewControlTypes.MIRELRS_DISPLAY:
                    {                        
                        cvc.ElapsedTime += elapsedTime;
                        data = cvc.PreviousData;
                        if (cvc.ElapsedTime > cvc.UpdateTime)
                        {
                            cvc.PreviousData = MirelRSControllerDisplayValue;                            
                            cvc.ElapsedTime = 0;
                        }
                        break;
                    }
                case CABViewControlTypes.MIRELRS_DISPLAY2:
                    {
                        if (DirectionControllerMirelRSPositionSh || ShModeActivated || ShModeActivated2)
                        {
                            cvc.ElapsedTime += elapsedTime;
                            data = cvc.PreviousData;
                            if (cvc.ElapsedTime > cvc.UpdateTime)
                            {
                                cvc.PreviousData = MirelRSControllerDisplay2Value;
                                cvc.ElapsedTime = 0;
                            }
                        }
                        else
                            data = 0;
                        break;
                    }
                case CABViewControlTypes.MIRELRS_DIRECTION_CONTROLLER:
                    {
                        if (MirelRSControllerEnable)
                        {
                            data = MirelRSDirectionControllerPosition[LocoStation]; 
                        }
                        break;
                    }
                case CABViewControlTypes.MIRELRS_SKIPDIODE:
                    {
                        if (MirelRSControllerEnable)
                        {
                            data = MirelRSSkipDiode;
                        }
                        break;
                    }
                case CABViewControlTypes.COMMAND_CYLINDER:
                    {
                        CommandCylinderEnable = true;
                        CVCWithFrames cVCWithFrames = (CVCWithFrames)cvc;
                        //CommandCylinderMaxPosition = cVCWithFrames.FramesCount;
                        CommandCylinderMaxPosition = ThrottleController.NotchCount();
                        data = CommandCylinderPosition[LocoStation];
                        break;
                    }
                case CABViewControlTypes.CIRCULAR_LIGHTSSWITCH_WHITE:
                    {
                        CircularSwitchEnable = true;
                        data = CircularSwitchWhitePosition[LocoStation];
                        break;
                    }
                case CABViewControlTypes.CIRCULAR_LIGHTSSWITCH_RED:
                    {
                        CircularSwitchEnable = true;
                        data = CircularSwitchRedPosition[LocoStation];
                        break;
                    }
                case CABViewControlTypes.TRACTIONMOTORS_TEMPERATURE:
                    {
                        data = TMTemperatureData0;
                        break;
                    }
                case CABViewControlTypes.DRIVERESISTANCE_TEMPERATURE:
                    {                        
                        data = DRTemperatureData0;
                        break;
                    }
                case CABViewControlTypes.MU_WHEELSLIPWARNING:
                    {
                        data = Simulator.WheelSlipWarning ? 1 : 0;
                        break;
                    }
                case CABViewControlTypes.MU_WHEELSLIP:
                    {
                        data = Simulator.WheelSlip ? 1 : 0;
                        break;
                    }

                case CABViewControlTypes.MOTOR_DISABLED:
                    {
                        if (extendedPhysics == null)
                            data = 0;
                        else
                        {
                            int id = 0;
                            foreach (Undercarriage uc in extendedPhysics.Undercarriages)
                            {
                                foreach (ExtendedAxle ea in uc.Axles)
                                {
                                    foreach (ElectricMotor em in ea.ElectricMotors)
                                    {
                                        if (id == cvc.MotorId)
                                            data = em.Disabled ? 1 : 0;
                                        id++;
                                    }
                                }
                            }
                        }
                        break;
                    }
                case CABViewControlTypes.INVERTER_TEST:
                    {
                        data = InverterTest;
                        break;
                    }
            }
            
            // max needle speed
            if (cvc.MaxNeedleSpeed > 0 && elapsedTime > 0)
            {
                double fullRange = 0;
                if (cvc.MinValueExtendedPhysics != 0 || cvc.MaxValueExtendedPhysics != 0)
                    fullRange = cvc.MaxValueExtendedPhysics - cvc.MinValueExtendedPhysics;
                else
                    fullRange = cvc.MaxValue - cvc.MinValue;
                float step = (float)fullRange / (cvc.MaxNeedleSpeed / elapsedTime);
                if (data - step > cvc.PreviousData)
                {
                    data = cvc.PreviousData + step;
                }
                if (data + step < cvc.PreviousData)
                {
                    data = cvc.PreviousData - step;
                }
                cvc.PreviousData = data;
            }
            else
            {
                if (cvc.MaxNeedleSpeedUp > 0 && elapsedTime > 0 && data > cvc.PreviousData)
                {
                    double fullRange = 0;
                    if (cvc.MinValueExtendedPhysics != 0 || cvc.MaxValueExtendedPhysics != 0)
                        fullRange = cvc.MaxValueExtendedPhysics - cvc.MinValueExtendedPhysics;
                    else
                        fullRange = cvc.MaxValue - cvc.MinValue;
                    float step = (float)fullRange / (cvc.MaxNeedleSpeedUp / elapsedTime);
                    if (data - step > cvc.PreviousData)
                    {
                        data = cvc.PreviousData + step;
                    }
                    cvc.PreviousData = data;
                }
                if (cvc.MaxNeedleSpeedDown > 0 && elapsedTime > 0 && data < cvc.PreviousData)
                {
                    double fullRange = 0;
                    if (cvc.MinValueExtendedPhysics != 0 || cvc.MaxValueExtendedPhysics != 0)
                        fullRange = cvc.MaxValueExtendedPhysics - cvc.MinValueExtendedPhysics;
                    else
                        fullRange = cvc.MaxValue - cvc.MinValue;
                    float step = (float)fullRange / (cvc.MaxNeedleSpeedDown / elapsedTime);
                    if (data + step < cvc.PreviousData)
                    {
                        data = cvc.PreviousData - step;
                    }
                    cvc.PreviousData = data;
                }
            }

            // Icik
            ResetControlUnitParameters();
            return data;
        }

        public void ConfirmSelectedSpeed()
        {
            if (LocoType != LocoTypes.Vectron)
                return;
            SelectedSpeedConfirmed = true;
            CruiseControl.CurrentSelectedSpeedMpS = CruiseControl.SelectedSpeedMpS = CruiseControl.NextSelectedSpeedMps;
            CruiseControl.SpeedChanged = true;
            Simulator.Confirmer.Information(Simulator.Catalog.GetString("Selected speed confirmed."));
            CruiseControl.OverridenMaximalForce = 50;
        }

        public float AvvDistanceToNext = 1000000;
        protected float previousSignalSpeed = 0;
        protected float previousSpeedpostSpeed = 0;
        protected float previousSignalItemDistance = 0;
        protected float maxSelSpeed = 0;
        public bool TrainBrakePriority = true;
        protected float speedPostSpeedAhead = 60;
        protected float signalSpeedAhead = 0;
        protected bool stoppedAtStation = false;
        public float OverridenSignalDistanceOdometer = 0;
        public float OverridenSignalDistance = -1;
        public float OverridenSignalSpeed = -1;
        public bool AVVBraking = false;
        public int AVVActiveLine = 0;
        public bool AVVPassStation = false;
        public bool AVVStop40 = false;
        public int AVVExpectSpeed = 0;
        public float previousStationItemDistance = 0;

        public virtual string GetDataOfS(CabViewControl crc, ElapsedTime elapsedClockSeconds, out Color? positiveColor)
        {
            positiveColor = null;
            if (crc.ControlType == CABViewControlTypes.ORTS_MIREL_DISPLAY)
            {
                return Mirel.Display;
            }
            if (crc.ControlType == CABViewControlTypes.ORTS_DIGITAL_STRING)
            {
                // ************************************************************************
                // ************************************************************************
                // ****************               AVV                 *********************
                // ************************************************************************
                // ************************************************************************

                if (StringArray.StArray == null || !string.IsNullOrEmpty(crc.StaticText))
                {
                    if (String.IsNullOrEmpty(crc.PropertyName))
                        return crc.Label;
                    else
                    {
                        string nearestItem = "";
                        float nearestStation = 100000;
                        float nearestSignal = 100000;
                        float nearestSpeedpost = 100000;
                        if (this.Train.StationStops.Count > 0)
                        {
                            Physics.Train.StationStop stationStop = Train.StationStops[0];
                            nearestStation = stationStop.DistanceToTrainM;
                        }
                        Train.TrainInfo tinfo = this.Train.GetTrainInfo();
                        List<Train.TrainObjectItem> titems = tinfo.ObjectInfoForward;
                        foreach (var titem in titems)
                        {
                            if (titem.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SPEEDPOST)
                            {
                                if (nearestSpeedpost > titem.DistanceToTrainM)
                                {
                                    nearestSpeedpost = titem.DistanceToTrainM;
                                }
                            }
                            if (titem.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SIGNAL)
                            {
                                if (nearestSignal > titem.DistanceToTrainM)
                                {
                                    nearestSignal = titem.DistanceToTrainM;
                                }
                            }
                        }
                        if (nearestStation < nearestSpeedpost && nearestStation < nearestSignal)
                            AVVActiveLine = 2;
                        if (nearestSignal < nearestSpeedpost && nearestSignal < nearestStation)
                            AVVActiveLine = 1;
                        if (nearestSpeedpost < nearestSignal && nearestSpeedpost < nearestStation)
                            AVVActiveLine = 0;
                        switch (crc.PropertyName)
                        {
                            case "StaticText":
                                {
                                    if (crc.Label == "Milepost" && AVVActiveLine == 0)
                                    {
                                        positiveColor = new Color(0, 0, 0);
                                    }
                                    if (crc.Label == "Signal" && AVVActiveLine == 1)
                                    {
                                        positiveColor = new Color(0, 0, 0);
                                    }
                                    if (crc.Label == "Station" && AVVActiveLine == 2)
                                    {
                                        positiveColor = new Color(0, 0, 0);
                                    }
                                    if (crc.Feature == "OdometerDisplay" && !OdometerDisplayActive)
                                        return "";
                                    return crc.StaticText;
                                }
                            case "TrainNumber": return TrainNumber;
                            case "BrakingPercent": return BrakingPercent;
                            case "ActiveSpeedPosts": return ActiveSpeedPosts;
                            case "UserTrainLength": return UserTrainLength;
                            case "UserTrainWeight": return UserTrainWeight;
                            case "UserTime": return UserTime;
                            case "NextStation":
                                {
                                    if (Train.StationStops.Count == 0 || CruiseControl.SpeedRegMode[LocoStation] != CruiseControl.SpeedRegulatorMode.AVV)
                                        return "";
                                    Train.StationStop stationStop = Train.StationStops[0];
                                    return stationStop.PlatformItem.Name.ToUpper();
                                }
                            case "NextStationDistance":
                                {
                                    if (AVVActiveLine == 2)
                                        positiveColor = new Color(0, 0, 0);

                                    if (this.Train.StationStops.Count == 0)
                                        return "?";
                                    Physics.Train.StationStop stationStop = Train.StationStops[0];
                                    if (stationStop.DistanceToTrainM > previousStationItemDistance + 10)
                                    {
                                        AVVPassStation = false;
                                    }
                                    previousStationItemDistance = stationStop.DistanceToTrainM - 1;
                                    string ret = "";
                                    ret = Math.Round(stationStop.DistanceToTrainM, 0).ToString();
                                    if (ret.Contains("-"))
                                        ret = "0";

                                    AvvDistanceToNext = stationStop.DistanceToTrainM;

                                    if (stationStop.DistanceToTrainM > 500)
                                        stoppedAtStation = false;
                                    if (AbsSpeedMpS == 0 && stationStop.DistanceToTrainM < 100)
                                        stoppedAtStation = true;

                                    float newSpeed = GetAvvSpeed(((AvvDistanceToNext * 0.9f) - 5), 0);
                                    if (AVVPassStation)
                                        newSpeed = MaxSpeedMpS;
                                    if (newSpeed < CruiseControl.SelectedSpeedMpS && !float.IsNaN(newSpeed) && !stoppedAtStation)
                                    {
                                        AVVBraking = true;
                                        CruiseControl.SelectedSpeedMpS = newSpeed;
                                    }
                                    else
                                    {
                                        AVVBraking = false;
                                    }
                                    if ((ControllerVolts < -9.9f || DynamicBrakePercent > 99) && !CruiseControl.DynamicBrakePriority)
                                    {
                                        AVVBraking = true;
                                    }

                                    return ret;

                                }
                            case "NextStationArrDep":
                                {
                                    if (Train.StationStops.Count == 0 || CruiseControl.SpeedRegMode[LocoStation] != CruiseControl.SpeedRegulatorMode.AVV)
                                        return "";
                                    Physics.Train.StationStop stationStop = Train.StationStops[0];
                                    if (!stoppedAtStation)
                                        return stationStop.arrivalDT.ToShortTimeString().Length == 4 ? "0" + stationStop.arrivalDT.ToShortTimeString() : stationStop.arrivalDT.ToShortTimeString();
                                    else
                                        return stationStop.departureDT.ToShortTimeString().Length == 4 ? "0" + stationStop.departureDT.ToShortTimeString() + " ODJEZD" : stationStop.departureDT.ToShortTimeString() + " ODJEZD";
                                }
                            case "NextStationSpeed":
                                {
                                    if (AVVActiveLine == 2)
                                        positiveColor = new Color(0, 0, 0);
                                    if (!AVVPassStation)
                                        return "0";
                                    else
                                        return Math.Round(MpS.ToKpH(MaxSpeedMpS), 0).ToString();
                                }
                            case "NextMilepostDistance":
                                {
                                    if (AVVActiveLine == 0)
                                        positiveColor = new Color(0, 0, 0);
                                    bool found = false;
                                    string ret = "?";
                                    Train.TrainInfo info = this.Train.GetTrainInfo();
                                    List<Train.TrainObjectItem> items = info.ObjectInfoForward;
                                    float minDistance = 1000000;
                                    foreach (var item in items)
                                    {
                                        if (item.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SPEEDPOST)
                                        {
                                            found = true;
                                            if (minDistance > item.DistanceToTrainM)
                                            {
                                                minDistance = item.DistanceToTrainM;
                                                minDistance = (float)Math.Round(minDistance, 0);
                                                ret = Math.Round(minDistance, 0).ToString();
                                            }
                                        }
                                    }
                                    if (!found)
                                    {
                                        float maxDistanceFound = 0;
                                        foreach (var item in items)
                                        {
                                            if (maxDistanceFound < item.DistanceToTrainM)
                                                maxDistanceFound = item.DistanceToTrainM;
                                            if (item.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SIGNAL && item.SignalState == TrackMonitorSignalAspect.Stop || item.SignalState == TrackMonitorSignalAspect.Approach_3)
                                            {
                                                if (minDistance > item.DistanceToTrainM)
                                                {
                                                    minDistance = item.DistanceToTrainM;
                                                    minDistance = (float)Math.Round(minDistance, 0);
                                                    minDistance += 500;
                                                    ret = Math.Round(minDistance, 0).ToString();
                                                    found = true;
                                                }
                                            }
                                        }
                                        if (!found)
                                        {
                                            maxDistanceFound = (float)Math.Round(maxDistanceFound, 0);
                                            minDistance = maxDistanceFound;
                                            ret = minDistance.ToString();
                                        }
                                    }
                                    AvvDistanceToNext = minDistance;

                                    float newSpeed = GetAvvSpeed((AvvDistanceToNext - 70), speedPostSpeedAhead);
                                    if (newSpeed < CruiseControl.SelectedSpeedMpS && !float.IsNaN(newSpeed))
                                    {
                                        AVVBraking = true;
                                        CruiseControl.SelectedSpeedMpS = newSpeed;
                                    }
                                    else
                                    {
                                        AVVBraking = false;
                                    }
                                    if ((ControllerVolts < -9.9f || DynamicBrakePercent > 99f) && !CruiseControl.DynamicBrakePriority)
                                    {
                                        AVVBraking = true;
                                    }

                                    return ret;
                                }
                            case "NextMilepostSpeed":
                                {
                                    if (AVVActiveLine == 0)
                                        positiveColor = new Color(0, 0, 0);
                                    string ret = "?";
                                    Train.TrainInfo info = this.Train.GetTrainInfo();
                                    List<Train.TrainObjectItem> items = info.ObjectInfoForward;
                                    float minDistance = 1000000;
                                    bool found = false;
                                    foreach (var item in items)
                                    {
                                        if (item.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SPEEDPOST)
                                        {
                                            found = true;
                                            if (minDistance > item.DistanceToTrainM)
                                            {
                                                minDistance = item.DistanceToTrainM;
                                                minDistance = (float)Math.Round(minDistance, 0);
                                                float newSpeed = (float)Math.Round(MpS.ToKpH(item.AllowedSpeedMpS), 0);
                                                previousSpeedpostSpeed = speedPostSpeedAhead = (float)Math.Round(newSpeed, 0);
                                                ret = newSpeed.ToString();
                                            }
                                        }
                                    }
                                    if (!found)
                                    {
                                        if (previousSpeedpostSpeed < 40)
                                            previousSpeedpostSpeed = 40;
                                        ret = Math.Round(previousSpeedpostSpeed, 0).ToString();
                                        if (previousSpeedpostSpeed == 0)
                                            previousSpeedpostSpeed = speedPostSpeedAhead = 40;
                                    }
                                    return ret;
                                }
                            case "CurrentMilepostSpeed":
                                {
                                    if (AVVActiveLine == 0)
                                        positiveColor = new Color(0, 0, 0);
                                    var thisInfo = this.Train.GetTrainInfo();
                                    return Math.Round(MpS.ToKpH(thisInfo.allowedSpeedMpS), 0).ToString();
                                }
                            case "NextSignalDistance":
                                {
                                    if (AVVActiveLine == 1)
                                        positiveColor = new Color(0, 0, 0);
                                    string ret = "?";
                                    Train.TrainInfo info = this.Train.GetTrainInfo();
                                    List<Train.TrainObjectItem> items = info.ObjectInfoForward;
                                    float minDistance = 1000000;
                                    foreach (var item in items)
                                    {
                                        if (item.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SIGNAL)
                                        {
                                            if (item.SignalObject.WorldObject != null)
                                            {
                                                if (item.SignalObject.WorldObject.SFileName.ToUpper() == "NVSTOZNAC.S" ||
                                                    item.SignalObject.WorldObject.SFileName.ToUpper() == "NVSTAS4_100M.S")
                                                {
                                                    continue;
                                                }
                                            }
                                            if (minDistance > item.DistanceToTrainM)
                                            {
                                                minDistance = (float)Math.Round(item.DistanceToTrainM, 0);
                                                ret = minDistance.ToString();
                                            }
                                        }
                                    }
                                    AvvDistanceToNext = minDistance;

                                    float newSpeed = GetAvvSpeed((AvvDistanceToNext - 72), signalSpeedAhead);
                                    if (newSpeed < CruiseControl.SelectedSpeedMpS && !float.IsNaN(newSpeed))
                                    {
                                        AVVBraking = true;
                                        CruiseControl.SelectedSpeedMpS = newSpeed;
                                    }
                                    else
                                    {
                                        AVVBraking = false;
                                    }
                                    if ((ControllerVolts < -9.9f || DynamicBrakePercent > 99) && !CruiseControl.DynamicBrakePriority)
                                    {
                                        AVVBraking = true;
                                    }

                                    return ret;
                                }
                            case "NextSignalSpeed":
                                {
                                    /*                                    if (OverridenSignalSpeed > -1)
                                                                            return OverridenSignalSpeed.ToString() + "kmh" */
                                    if (AVVActiveLine == 1)
                                        positiveColor = new Color(0, 0, 0);
                                    string ret = "?";
                                    Train.TrainInfo info = this.Train.GetTrainInfo();
                                    List<Train.TrainObjectItem> items = info.ObjectInfoForward;
                                    float minDistance = 1000000;
                                    bool overrideDistance = false;
                                    foreach (var item in items)
                                    {
                                        if (item.ItemType == Train.TrainObjectItem.TRAINOBJECTTYPE.SIGNAL)
                                        {
                                            if (item.SignalObject.WorldObject != null)
                                            {
                                                if (item.SignalObject.WorldObject.SFileName.ToUpper() == "NVSTOZNAC.S" ||
                                                    item.SignalObject.WorldObject.SFileName.ToUpper() == "NVSTAS4_100M.S")
                                                {
                                                    continue;
                                                }
                                            }
                                            if (minDistance > item.DistanceToTrainM)
                                            {
                                                minDistance = item.DistanceToTrainM;
                                                if (item.DistanceToTrainM > previousSignalItemDistance + 10)
                                                {
                                                    overrideDistance = true;
                                                    AVVStop40 = false;
                                                    Mirel.Update(elapsedTime, AbsSpeedMpS, AbsWheelSpeedMpS);
                                                }
                                                previousSignalItemDistance = item.DistanceToTrainM - 1;
                                                if (Mirel.RecievingRepeaterSignal)
                                                {
                                                    previousSignalItemDistance = item.DistanceToTrainM;
                                                    switch (item.SignalState)
                                                    {
                                                        case TrackMonitorSignalAspect.Stop:
                                                        case TrackMonitorSignalAspect.StopAndProceed:
                                                        case TrackMonitorSignalAspect.None:
                                                        case TrackMonitorSignalAspect.Permission:
                                                            {
                                                                signalSpeedAhead = 0;
                                                                CruiseControl.avvSignal = CruiseControl.AvvSignal.Stop;
                                                                break;
                                                            }
                                                        case TrackMonitorSignalAspect.Restricted:
                                                            {
                                                                signalSpeedAhead = 100;
                                                                CruiseControl.avvSignal = CruiseControl.AvvSignal.Restricted;
                                                                break;
                                                            }
                                                        case TrackMonitorSignalAspect.Clear_1:
                                                        case TrackMonitorSignalAspect.Clear_2:
                                                            {
                                                                signalSpeedAhead = MpS.ToKpH(MaxSpeedMpS);
                                                                CruiseControl.avvSignal = CruiseControl.AvvSignal.Clear;
                                                                break;
                                                            }
                                                        case TrackMonitorSignalAspect.Approach_1:
                                                        case TrackMonitorSignalAspect.Approach_2:
                                                        case TrackMonitorSignalAspect.Approach_3:
                                                            {
                                                                if (
                                                                    CruiseControl.avvSignal == CruiseControl.AvvSignal.Clear ||
                                                                    CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricted ||
                                                                    CruiseControl.avvSignal == CruiseControl.AvvSignal.Stop
                                                                    )
                                                                    CruiseControl.avvSignal = CruiseControl.AvvSignal.Restricting40;
                                                                switch (CruiseControl.avvSignal)
                                                                {
                                                                    case CruiseControl.AvvSignal.Restricting100:
                                                                        {
                                                                            signalSpeedAhead = 100;
                                                                            break;
                                                                        }
                                                                    case CruiseControl.AvvSignal.Restricting80:
                                                                        {
                                                                            signalSpeedAhead = 80;
                                                                            break;
                                                                        }
                                                                    case CruiseControl.AvvSignal.Restricting60:
                                                                        {
                                                                            signalSpeedAhead = 60;
                                                                            break;
                                                                        }
                                                                    case CruiseControl.AvvSignal.Restricting40:
                                                                        {
                                                                            signalSpeedAhead = 40;
                                                                            break;
                                                                        }
                                                                }
                                                                break;
                                                            }
                                                    }
                                                    if (signalSpeedAhead == 0 && AVVStop40)
                                                        signalSpeedAhead = 40;
                                                    ret = Math.Round(signalSpeedAhead, 0).ToString();
                                                }
                                                else if (overrideDistance)
                                                {
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Clear)
                                                    {
                                                        CruiseControl.avvSignal = CruiseControl.AvvSignal.Restricted;
                                                        ret = "120";
                                                    }
                                                    else if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricted)
                                                    {
                                                        CruiseControl.avvSignal = CruiseControl.AvvSignal.Stop;
                                                        ret = "0";
                                                    }
                                                    else if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting40 ||
                                                        CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting60 ||
                                                        CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting80 ||
                                                        CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting100 ||
                                                        CruiseControl.avvSignal == CruiseControl.AvvSignal.NoRestriction
                                                        )
                                                    {
                                                        CruiseControl.avvSignal = CruiseControl.AvvSignal.Restricted;
                                                        ret = "0";
                                                    }
                                                }
                                                if (!Mirel.RecievingRepeaterSignal)
                                                {
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Clear)
                                                    {
                                                        ret = Math.Round(MpS.ToKpH(MaxSpeedMpS), 0).ToString();
                                                        signalSpeedAhead = (int)Math.Round(MpS.ToKpH(MaxSpeedMpS), 0);
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricted)
                                                    {
                                                        ret = "120";
                                                        if (MpS.ToKpH(MaxSpeedMpS) < 120)
                                                            ret = Math.Round(MpS.ToKpH(MaxSpeedMpS), 0).ToString();
                                                        signalSpeedAhead = (int)Math.Round(MpS.ToKpH(MaxSpeedMpS), 0);
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting40)
                                                    {
                                                        signalSpeedAhead = 40;
                                                        ret = "40";
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting60)
                                                    {
                                                        ret = "60";
                                                        signalSpeedAhead = 60;
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting80)
                                                    {
                                                        ret = "80";
                                                        signalSpeedAhead = 80;
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Restricting100)
                                                    {
                                                        ret = "100";
                                                        signalSpeedAhead = 100;
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.Stop)
                                                    {
                                                        ret = "0";
                                                        signalSpeedAhead = 0;
                                                    }
                                                    if (CruiseControl.avvSignal == CruiseControl.AvvSignal.NoRestriction)
                                                    {
                                                        signalSpeedAhead = (int)Math.Round(MpS.ToKpH(MaxSpeedMpS), 0);
                                                        ret = signalSpeedAhead.ToString();
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (signalSpeedAhead < 40 && AVVStop40)
                                    {
                                        signalSpeedAhead = 40;
                                        ret = "40";
                                    }
                                    return ret;
                                }
                            default: return "--";
                        }
                    }
                }

                // ************************************************************************
                // ************************************************************************
                // ****************              End AVV              *********************
                // ************************************************************************
                // ************************************************************************


                if (StringArray.StArray == null)
                {
                    if (String.IsNullOrEmpty(crc.PropertyName))
                        return crc.Label;
                }
                foreach (StrArray strArray in StringArray.StArray)
                {
                    if (strArray.Index == crc.ArrayIndex)
                    {
                        return strArray.Strings.ElementAt(strArray.SelectedString).Key;
                    }
                }
            }
            if (crc.ControlType == CABViewControlTypes.ORTS_DATE)
            {
                return DateTime.Now.Date.ToString(crc.DateFormat);
            }
            string retVal = crc.StringValue;
            if (crc.Length > 0)
            {
                if (retVal.Length > crc.Length) retVal = retVal.Substring(0, crc.Length);
                while (retVal.Length < crc.Length) retVal = retVal + "0";
            }
            if (crc.ControlType == CABViewControlTypes.ODOMETER_DISPLAY)
            {
                if (!OdometerDisplayActive)
                    return "";
                float displayNum = DistanceM - OdometerDistancePassed;
                displayNum /= crc.Precision;
                displayNum = (float)Math.Round(displayNum, 0);
                displayNum = displayNum * 20;
                if (displayNum > 700)
                {
                    OdometerDisplayActive = false;
                    return "";
                }
                return displayNum.ToString() + "m";
            }
            return retVal;
        }

        private float GetAvvSpeed(float distanceToNext, float targetSpeed)
        {
            if (CruiseControl.SpeedRegMode[LocoStation] != CruiseControl.SpeedRegulatorMode.AVV)
                return MaxSpeedMpS;

            var thisInfo = this.Train.GetTrainInfo();

            if (distanceToNext < 0)
                distanceToNext = 0;
            float spd = 0;
            float decel = 0;
            if (AbsSpeedMpS > 0)
            {
                if (targetSpeed == 0)
                {
                   return (float)Math.Sqrt(distanceToNext / 1.25f);
                }
                else
                {
                    spd = (distanceToNext / 15) + targetSpeed;
                }
            }
            else return float.NaN;
            if (spd < targetSpeed)
                spd = targetSpeed;
            float speed = MpS.FromKpH(spd);
            if (speed < 0)
                speed = 0;
            return speed;
        }
        public void CheckBlankDisplay(CabViewControl cvc)
        {
            bool jumpOut = false;
            if (cvc.DisplayID > -1)
                cvc.BlankDisplay = true;
            if (StringArray.StArray == null) return;
            foreach (StrArray strArray in StringArray.StArray)
            {
                foreach (KeyValuePair<string, int> pair in strArray.Strings)
                {
                    int s = strArray.Strings.ElementAt(strArray.SelectedString).Value;
                    if (s == cvc.DisplayID && s > -1)
                    {
                        if (cvc.DisplayID == pair.Value)
                        {
                            jumpOut = true;
                            cvc.BlankDisplay = false;
                            break;
                        }
                    }
                }
                if (jumpOut) break;
            }
        }

        protected static float ConvertFromPSI(CabViewControl cvc, float data)
        {
            if (cvc.Units == CABViewControlUnits.BAR)
                data = Bar.FromPSI(data);
            else if (cvc.Units == CABViewControlUnits.KILOPASCALS)
                data = KPa.FromPSI(data);
            else if (cvc.Units == CABViewControlUnits.KGS_PER_SQUARE_CM)
                data *= 70.307e-3f;
            else if (cvc.Units == CABViewControlUnits.INCHES_OF_MERCURY)
                data = Vac.FromPress(data);
            return data;
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void RefillImmediately()
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual MSTSNotchController GetRefillController(uint type)
        {
            return null;
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public virtual void SetStepSize(PickupObj matchPickup)
        {
        }

        /// <summary>
        /// To be overridden by MSTSSteamLocomotive and MSTSDieselLocomotive.
        /// </summary>
        public override float GetFilledFraction(uint pickupType)
        {
            return 0f;
        }

        public override void SwitchToPlayerControl()
        {
            base.SwitchToPlayerControl();
            return;
        }

        public override void SwitchToAutopilotControl()
        {
            base.SwitchToAutopilotControl();
            return;
        }

    } // End Class MSTSLocomotive

    public class StringArray
    {
        public List<StrArray> StArray { get; set; }
    }
    public class StrArray
    {
        public Dictionary<string, int> Strings { get; set; }
        public int Index { get; set; }
        public int SelectedString { get; set; }
        public int AffectedDisplayID { get; set; }
    }

    public class CabView
    {
        public CabViewFile CVFFile;
        public List<ViewPoint> ViewPointList;
        public ExtendedCVF ExtendedCVF;
        public CabViewType CabViewType;
        public bool NoseAhead; // if cabview is not in front of engine; used to define how terrain tilts if there is freightanimation

        public CabView(CabViewFile cvfFile, List<ViewPoint> viewPointList, ExtendedCVF extendedCVF, CabViewType cabViewType, bool noseAhead)
        {
            CVFFile = cvfFile;
            ViewPointList = viewPointList;
            ExtendedCVF = extendedCVF;
            CabViewType = cabViewType;
            NoseAhead = noseAhead;
        }
    }

    public class CabView3D : CabView
    {
        public string ShapeFilePath;

        public CabView3D(CabViewFile cvfFile, List<PassengerViewPoint> cabViewpoints, ExtendedCVF extendedCVF, CabViewType cabViewType, bool noseAhead, string shapeFilePath)
            : base(cvfFile, new List<ViewPoint>(), extendedCVF, cabViewType, noseAhead)
        {
            ShapeFilePath = shapeFilePath;
            if (cabViewpoints != null)
                foreach (var point in cabViewpoints)
                    ViewPointList.Add(point);
        }

    }

    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    [ORTSPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public static Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public static Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        [ORTSPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        public Vector4 Light1Position;

        [ORTSPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        public Color Light1Color;

        [ORTSPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        public Vector4 Light2Position;

        [ORTSPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        public Color Light2Color;

    } // End Class ExtendedCVF 
}
